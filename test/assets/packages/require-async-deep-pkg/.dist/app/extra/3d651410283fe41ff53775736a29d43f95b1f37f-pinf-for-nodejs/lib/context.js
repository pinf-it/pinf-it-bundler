// @pinf-bundle-ignore: 
PINF.bundle("", function(require) {
// @pinf-bundle-header: {"helper":"amd-ish"}
var amdRequireImplementation = null;
function wrapAMD(callback) {
    function define(id, dependencies, moduleInitializer) {
        if (typeof dependencies === "undefined" && typeof moduleInitializer === "undefined") {
            if (typeof id === "function") {
                moduleInitializer = id;
            } else {
                var exports = id;
                moduleInitializer = function() { return exports; }
            }
            dependencies = ["require", "exports", "module"];
            id = null;
        } else
        if (Array.isArray(id) && typeof dependencies === "function" && typeof moduleInitializer === "undefined") {
            moduleInitializer = dependencies;
            dependencies = id;
            id = null;
        } else
        if (typeof id === "string" && typeof dependencies === "function" && typeof moduleInitializer === "undefined") {
            moduleInitializer = dependencies;
            dependencies = ["require", "exports", "module"];
        }
        return function(realRequire, exports, module) {
            function require(id) {
                if (Array.isArray(id)) {
                    var apis = [];
                    var callback = arguments[1];
                    id.forEach(function(moduleId, index) {
                        realRequire.async(moduleId, function(api) {
                            apis[index] = api
                            if (apis.length === id.length) {
                                if (callback) callback.apply(null, apis);
                            }
                        }, function(err) {
                            throw err;
                        });
                    });
                } else {
                    return realRequire(id.replace(/^[^!]*!/, ""));
                }
            }
            require.toUrl = function(id) {
                return realRequire.sandbox.id.replace(/\/[^\/]*$/, "") + realRequire.id(id);
            }
            if (typeof amdRequireImplementation !== "undefined") {
                amdRequireImplementation = require;
            }
            if (typeof moduleInitializer === "function") {
                return moduleInitializer.apply(moduleInitializer, dependencies.map(function(name) {
                    if (name === "require") return require;
                    if (name === "exports") return exports;
                    if (name === "module") return module;
                    return require(name);
                }));
            } else
            if (typeof dependencies === "object") {
                return dependencies;
            }
        }
    }
    define.amd = { jQuery: true };
    var exports = null;
    function wrappedDefine() {
        exports = define.apply(null, arguments);
    }
    function amdRequire() {
        return amdRequireImplementation.apply(null, arguments);
    }
    wrappedDefine.amd = { jQuery: true };
    callback(amdRequire, wrappedDefine);
    return exports;
}
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/context.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/context.js"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/context.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib';

require("./helpers/cycle");

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");
const URL = require("__SYSTEM__/url");
const WAITFOR = require("waitfor");
const DEEPMERGE = require("deepmerge");
const DEEPCOPY = require("deepcopy");
const JSON_FILE_STORE = require("./json-file-store").JsonFileStore;
const EVENTS = require("__SYSTEM__/events");
const UTIL = require("__SYSTEM__/util");
const PINF_PRIMITIVES = require("pinf-primitives-js");
const PACKAGE_INSIGHT = require("pinf-it-package-insight");
const PROGRAM_INSIGHT = require("pinf-it-program-insight");
const VM = require("./vm").VM;
const VFS = require("./vfs");
const LOADER = require("./loader");
const CRYPTO = require("__SYSTEM__/crypto");
const ZLIB = require("__SYSTEM__/zlib");
const SPAWN = require('__SYSTEM__/child_process').spawn;


exports.contextForProgram = function(programUri, options, callback) {
	if (typeof options === "function" && typeof callback === "undefined") {
		callback = options;
		options = null;
	}
	options = options || {};

	var opts = {};
	for (var name in options) {
		opts[name] = options[name];
	}

	opts.PINF_PROGRAM = programUri;

	if (typeof opts.PINF_RUNTIME === "undefined") {
		opts.PINF_RUNTIME = (options.$pinf && options.$pinf.env && options.$pinf.env.PINF_RUNTIME) || process.env.PINF_RUNTIME;
	}

	return exports.context(opts.PINF_PROGRAM, null, {
		env: {
			PINF_RUNTIME: opts.PINF_RUNTIME
		},
		debug: opts.debug || false,
		verbose: opts.verbose || false,
		test: opts.test || false
	}, callback);
}

exports.contextForModule = function(module, options, callback) {
	if (typeof options === "function" && typeof callback === "undefined") {
		callback = options;
		options = null;
	}
	options = options || {};

	var opts = {};
	for (var name in options) {
		opts[name] = options[name];
	}

	if (typeof opts.PINF_PROGRAM === "undefined") {
		opts.PINF_PROGRAM = (options.$pinf && options.$pinf.env && options.$pinf.env.PINF_PROGRAM) || process.env.PINF_PROGRAM;
	}
	if (typeof opts.PINF_RUNTIME === "undefined") {
		opts.PINF_RUNTIME = (options.$pinf && options.$pinf.env && options.$pinf.env.PINF_RUNTIME) || process.env.PINF_RUNTIME;
	}

	if (!opts.PINF_PROGRAM) {
		return callback(new Error("The PINF_PROGRAM environment variable must be set!"));
	}
	if (!module.filename) {
		return callback(new Error("`module.filename` must be set!"));
	}

	return PACKAGE_INSIGHT.findPackagePath(module.filename, function(err, path) {
		if (err) return callback(err);
		return exports.context(opts.PINF_PROGRAM, path, {
			env: {
				PINF_RUNTIME: opts.PINF_RUNTIME
			},
			debug: opts.debug || false,
			verbose: opts.verbose || false,
			test: opts.test || false
		}, callback);
	});
}


exports.uriToPath = function(uri) {
	return uri.replace(/[:@#]/g, "/").replace(/[\?&=]/g, "+").replace(/\/+/g, "/").replace(/\/$/, "+");
}

exports.uriToFilename = function(uri) {
	return exports.uriToPath(uri).replace(/\//g, "+");
}

exports.formatUid = function(uri) {
	if (!uri) return false;
	var parsedUri = URL.parse(uri);
	if (parsedUri) {
		uri = ((parsedUri.hostname)?parsedUri.hostname:"") + parsedUri.pathname;
	}
	return uri;
}

exports.context = function(programDescriptorPath, packageDescriptorPath, options, callback) {

	if (typeof options === "function" && typeof callback === "undefined") {
		callback = options;
		options = null;
	}

	options = options || {};

	options.API = {
		FS: (options.$pinf && options.$pinf.getAPI("FS")) || FS
	};

	var contextStartTime = Date.now();

	var originalProgramDescriptorPath = programDescriptorPath;
	var originalPackageDescriptorPath = packageDescriptorPath;

	var originalCallback = callback;
	callback = function() {
		if (options.verbose) console.log(("[pinf-for-nodejs][context][END] (" + (Date.now() - contextStartTime) + " ms) new context for package: " + packageDescriptorPath + " (program: " + programDescriptorPath + ")").inverse);
		return originalCallback.apply(this, arguments);
	}

	if (options.verbose) console.log(("[pinf-for-nodejs][context][START] new context for package: " + packageDescriptorPath + " (program: " + programDescriptorPath + ")").inverse);

	options._relpath = function(path) {
		if (!path || !options.rootPath || !/^\//.test(path)) return path;
		return PATH.relative(options.rootPath, path);
	}

	options._realpath = function(path) {
		if (!options.rootPath) return path;
		if (/^\//.test(path)) return path;
		return PATH.join(options.rootPath, path);
	}

	var env = options.env || null;

	env = PINF_PRIMITIVES.normalizeEnvironmentVariables(env, {
		PINF_PROGRAM: programDescriptorPath || (env && env.PINF_PROGRAM) || undefined,
		PINF_PACKAGE: packageDescriptorPath || (env && env.PINF_PACKAGE) || undefined
	});

	if (options.debug) console.log("[pinf-for-nodejs][context] env:", env);


	function ensurePath() {
		var path = PATH.join.apply(null, [].slice.call(arguments));
		if (FS.existsSync(path)) return path;
		FS.mkdirsSync(path);
		return path;
	}

	function ensureParentPath() {
		var path = PATH.join.apply(null, [].slice.call(arguments));
		if (FS.existsSync(PATH.dirname(path))) return path;
		FS.mkdirsSync(PATH.dirname(path));
		return path;
	}

	function reloadContext(context, callback) {
		// TODO: Make this super efficient by checking file mtimes.
		//		 At the moment we force bypass the cache on reload as modified files
		//       may have the same timestamp as the cache (since FS mtime resolution is 1 sec).
		//       We should detect changed files better (maybe by hash) and reload context
		//       only for changed files. e.g. we could check the cache and if all the same
		//       we prepopulate context with our existing info and only load in files with same mtime.
		var opts = {};
		for (var name in options) {
			opts[name] = options[name];
		}
		return exports.context(programDescriptorPath, packageDescriptorPath, opts, function(err, reloadedContext) {
			if (err) return callback(err);
			for (var name in reloadedContext) {
				if (typeof reloadedContext[name] !== "function") {
					context[name] = reloadedContext[name];
				}
			}
			// TODO: Only emit this if config has in fact changed.
			context.emit("config.changed");
			return callback(null);
		});
	}

	var Context = function() {
		this.uid = null;
		this.ns = null;
		this.debug = false;
		this.verbose = false;
		this.test = false;
		this.now = Date.now();
	    // If `ttl === -1` then force cache refresh.
	    // If `ttl === 0` then cache indefinite.
	    // If `ttl >= 1` then cache for ttl (milliseconds).
	    // If `ttl <= -1` then cache if newer than (ttl * -1).
		this.ttl = 0;
		this.env = {};
		this.paths = {};
		this.binPaths = [];
		this.config = [];
		this.descriptorPaths = [];
		this.lookupPaths = [];
		this._api = {};
		this._descriptors = {
			package: {},
			program: {}
		};
		this._programInfo = {};
		this._packageInfo = {};
	}
	UTIL.inherits(Context, EVENTS.EventEmitter);

	// @unstable
	Context.prototype.clone = function() {
		var ctx = new Context();
		for (var name in this) {
			if (this.hasOwnProperty(name)) {
				ctx[name] = this[name];
			}
		}
		return ctx;
	}

	// @unstable
	Context.prototype.stringify = function() {
		var obj = {};
		for (var name in this) {
			if (!this.hasOwnProperty(name)) continue;
			if (name === "#pinf") continue;
			if (/^_/.test(name)) continue;
			obj[name] = this[name];
		}
		return JSON.stringify.apply(null, [obj].concat(Array.prototype.slice.call(arguments, 0)));
	}

	// @experimental
	Context.prototype.makeOptions = function(options) {
		if (typeof options !== "object") {
			return options;
		}
		var opts = {};
		for (var name in options) {
			opts[name] = options[name];
		}
		var ctx = this.clone();
		function inheritProperties(parent) {
			[
				"debug",
				"verbose",
				"test",
				"ttl"
			].forEach(function(name) {
				ctx[name] = parent[name];
			});
		}
		if (!opts.$pinf || typeof opts.$pinf !== "object") {
			opts.$pinf = ctx;
			return opts;
		} else
		// Ugly but nothig else seems to work. i.e. `instanceof`, `===` without `toString()`.
		if (!(opts.$pinf.constructor.toString() === Context.toString())) {
			inheritProperties(opts.$pinf);
			opts.$pinf = ctx;
			return opts;
		}
		ctx.__proto__ = opts.$pinf;
		opts.$pinf = ctx;
		opts.$pinf._parentContext = opts.$pinf.__proto__;
		inheritProperties(opts.$pinf._parentContext);
		return opts;
	}

	// @unstable
	Context.prototype.makePath = function(type, path, options) {
		if (!this.paths[type]) return null;
		options = options || {};
		var origType = type;
		var origPath = path;
		function finalize(path) {
			if (options.shorten) {
				// NOTE: This code path is rarely used.

				path = ensurePath(path);
				var homeDir = null;
				if (/\/Volumes\//.test(path)) {
					homeDir = path.split("/").slice(0, 3).join("/");
				} else {
					ASSERT(typeof process.env.HOME, "string");
					ASSERT(FS.existsSync(process.env.HOME), true);
					homeDir = process.env.HOME;
				}
				var shortSymlinkDir = null;
				if (options.shorten === "TO_ROOT") {
					if (type) {
						shortSymlinkDir = PATH.join(homeDir, ".s");
					} else {
						shortSymlinkDir = PATH.join(homeDir, ".s");
					}
				} else {
					if (type) {
						shortSymlinkDir = PATH.join(homeDir, ".pinf", type, ".shorts");
					} else {
						shortSymlinkDir = PATH.join(homeDir, ".pinf", ".shorts");
					}
				}
				var shasum = CRYPTO.createHash("sha1");
				shasum.update(path);
				var filename = shasum.digest("hex");
				if (!FS.existsSync(shortSymlinkDir)) {
					FS.mkdirsSync(shortSymlinkDir);
				}				
				if (!FS.existsSync(PATH.join(shortSymlinkDir, filename))) {
					FS.renameSync(path, PATH.join(shortSymlinkDir, filename));
					FS.symlinkSync(PATH.join(shortSymlinkDir, filename), path);
				}
				path = PATH.join(shortSymlinkDir, filename);
			}
			return path;
		}
		if (!path) return finalize(ensureParentPath(this.paths[type]));
		if (Array.isArray(path)) {
			path = path.map(function(segment) {
				return segment.replace(/\//g, "+");
			}).join("/");
		}
		return finalize(ensureParentPath(this.paths[type], path));
	}

	// @experimental
	Context.prototype.getAPI = function(alias) {
		var obj = this;
		while(obj) {
			if (obj._api && obj._api[alias]) {
				return obj._api[alias];
			}
			obj = obj.__proto__;
		}
		if (alias === "console") {
			return console;
		}
		return null;
	}

	// @unstable
	Context.prototype.sandbox = function(sandboxIdentifier, sandboxOptions, loadedCallback, errorCallback) {
		var self = this;
		if (typeof sandboxOptions === "function" && typeof loadedCallback === "function" && typeof errorCallback === "undefined") {
			errorCallback = loadedCallback;
			loadedCallback = sandboxOptions;
			sandboxOptions = {};
		} else
		if (typeof sandboxOptions === "function" && typeof loadedCallback === "undefined") {
			loadedCallback = sandboxOptions;
			sandboxOptions = {};
		} else {
			sandboxOptions = sandboxOptions || {};
		}
		var callback = function(err, sandbox) {
			if (err) {
				if (errorCallback) {
					return errorCallback(err);
				}
				throw err;
			}
			return loadedCallback(sandbox);
		}
		return FS.stat(sandboxIdentifier, function(err, stat) {
			if (err) return callback(err);
			if (stat.isDirectory()) {
	            var vm = new VM(self);
	            return vm.loadPackage(sandboxIdentifier, sandboxOptions, callback);
			} else {
				return LOADER.sandbox(sandboxIdentifier, self.makeOptions(sandboxOptions), loadedCallback, errorCallback);
			}
		});
	}

	// @experimental
	Context.prototype.gateway = function(type, gatewayOptions) {
		var self = this;
		var gatewayStartTime = Date.now();
		gatewayOptions = gatewayOptions || {};
		if (typeof gatewayOptions.verbose === "undefined") {
			gatewayOptions.verbose = options.verbose;
		}
		if (typeof gatewayOptions.ttl === "undefined") {
			gatewayOptions.ttl = options.ttl;
		}
		// TODO: Move these into plugins.
		// If `FS` is an instance of `./vfs.js` we can bypass gateway if all written files are older than read files.
		if (type === "vfs-write-from-read-mtime-bypass") {
			// TODO: Refactor some of this into a cache module with tree-based contexts for managing expiry.
			var VFS = null;
			var rawKey = null;
			var key = null;
			var paths = {};
			var listener = function(path, method) {
				if (!paths[path]) {
					paths[path] = {};
				}
			};
			function getCachePath() {
				if (!key) {
					throw new Error("`gateway.setKey()` must be called!");
				}
				if (gatewayOptions.cacheNamespace) {
					return PATH.join(env.PINF_PROGRAM, "../.rt/cache", gatewayOptions.cacheNamespace, "gateway/" + type + "/" + key);
				} else {
					return self.makePath("cache", "gateway/" + type + "/" + key);
				}
			}
			function finalize(cacheData, callback) {
				var waitfor = WAITFOR.parallel(function(err) {
					if (err) return callback(err);
					var data = JSON.stringify(JSON.decycle({
						wtime: Date.now(),
						paths: paths,
						data: cacheData
					}));
					return ZLIB.gzip(new Buffer(data), function(err, buffer) {
						if (err) return callback(err);
						return (FS.outputFileAtomic || FS.outputFile)(getCachePath(), buffer, function(err) {
							if (err) {
								if (err.code === "ENOENT" && /rename/.test(err.message)) {
									// Rename failed likely due to other process writing file during our delete and rename.
									return callback();
								}
								return callback(err);
							}
							return callback();
						});
					});
				});
				for (var path in paths) {
					waitfor(path, function(path, done) {
						return FS.exists(path, function(exists) {
							if (!exists) {
								paths[path].mtime = -1;
								paths[path].size = 0;
								return done();
							}
							return FS.stat(path, function(err, stat) {
								if (err) return done(err);
								paths[path].mtime = stat.mtime.getTime();
								paths[path].size = stat.size;
								return done();
							});
						});
					});
				}
				return waitfor();
			}
			var api = {
				setKey: function(_key) {
					if (VFS) {
						throw new Error("`gateway.getAPI()` should not be called before `gateway.onDone()`");
					}
					if (typeof _key !== "string") {
						_key = JSON.stringify(_key);
					}
					rawKey = _key;
					var shasum = CRYPTO.createHash("sha1");
					shasum.update(_key);
					key = shasum.digest("hex");
				},
				onDone: function(callback, proceedCallback, notModifiedCallback) {
					if (VFS) {
						throw new Error("`gateway.getAPI()` should not be called before `gateway.onDone()`");
					}
					if (gatewayOptions.ttl === -1) {
						if (gatewayOptions.verbose) console.log(("[pinf-for-nodejs][context] gateway bypass due to `ttl === -1`").cyan);
						return proceedCallback(null, function() {
							var args = Array.prototype.slice.call(arguments, 0);
							return callback.apply(null, args.slice(0, args.length -1));
						});
					}
					var cachePath = getCachePath();
					function proceed(reason) {
						var startTime = Date.now();
						if (gatewayOptions.verbose) console.log(("[pinf-for-nodejs][context] gateway proceed: " + reason + " (" + cachePath + ")").yellow);
						return proceedCallback(null, function proxiedCallback(err) {
							if (gatewayOptions.verbose) console.log(("[pinf-for-nodejs][context] gateway proceed done (used " + Object.keys(paths).length + " files in " + (Date.now() - startTime) + " ms) (key: " + rawKey + ")").yellow);
							if (typeof VFS.removeListener === "function") {
								VFS.removeListener("used-path", listener);
							}
							if (err) return callback(err);
							var args = Array.prototype.slice.call(arguments, 0);
							// NOTE: We take the last argument and write it to cache in `finalize`.
							//       It is returned when bypassing.
							return finalize(args.pop(), function(err) {
								if (err) return callback(err);
								return callback.apply(null, args);
							});
						});
					}
					return FS.exists(cachePath, function(exists) {
						if (!exists) return proceed("cache-path-missing");
						return FS.stat(cachePath, function(err, stat) {
							if (err) return callback(err);
							return FS.readFile(cachePath, function(err, dataRaw) {
								if (err) return callback(err);
								return ZLIB.gunzip(dataRaw, function(err, data) {
									// NOTE: For some reason the data is not always compressed!
//									if (err) return callback(err);
									try {
										data = JSON.retrocycle(JSON.parse(data || dataRaw));
									} catch(err) {
										console.warn("Error evaling cache file '" + cachePath + "': " + err.stack);
										return proceed("error-during-cache-eval");
									}
									if (!data || !data.paths) return proceed("no-paths-in-cache");
									if (gatewayOptions.skipFSCheck) {
										if (gatewayOptions.verbose) console.log(("[pinf-for-nodejs][context] gateway skipping cache check (" + cachePath + " in " + (Date.now() - gatewayStartTime) + " ms)").green);
										// self.getAPI("console").cache("Using cached data based on path mtimes in '" + path + "'");
										return notModifiedCallback(data.data, {
											cachePath: cachePath
										});
									}
									// Find earliest mtime in write paths.
									var canBypass = true;
									// Go through all read paths to see if:
									//    * we can find one with an mtime that now does not exist (missing).
									//    * we can find one with mtime -1 that now exists (new).
									//    * we can find one with a newer mtime (changed).
									var waitfor = WAITFOR.parallel(function(err) {
										if (err) return callback(err);
										if (canBypass === true) {
											if (gatewayOptions.verbose) console.log(("[pinf-for-nodejs][context] gateway using cache (" + cachePath + " checked " + Object.keys(data.paths).length + " (key: " + rawKey + ") paths in " + (Date.now() - gatewayStartTime) + " ms)").green);
											// self.getAPI("console").cache("Using cached data based on path mtimes in '" + path + "'");
											return notModifiedCallback(data.data, {
												cachePath: cachePath
											});
										}
										if (gatewayOptions.verbose) console.log(("[pinf-for-nodejs][context] gateway found change: " + canBypass).yellow);
										// self.getAPI("console").info("Regenerating cached data based on path mtimes in '" + path + "' (" + canBypass + ")");
										return proceed("cannot-bypass-after-check");
									});
									for (var path in data.paths) {
										waitfor(path, function checkPath(path, done) {
											if (!canBypass) return done();
											return FS.exists(path, function(exists) {
												if (!canBypass) return done();
												if (exists) {
													if (data.paths[path] && data.paths[path].mtime === -1) {
														// mtime -1 that now exists.
														canBypass = "new - " + path;
														return done();
													}
													return FS.stat(path, function(err, stat) {
														if (err) return done(err);
														if (
															stat.mtime.getTime() > data.paths[path].mtime ||
															stat.size != data.paths[path].size
														) {
															// a newer mtime than `earliestMtime`.
															canBypass = "changed (" + (stat.mtime.getTime() + " - " + data.paths[path].mtime) + " - " + (stat.mtime.getTime() - data.paths[path].mtime) + ") - " + path;
															return done();
														}
														return done();
													});
												} else {
													if (data.paths[path] && data.paths[path].mtime !== -1) {
														// an mtime that now does not exist.
														canBypass = "missing - " + path;
														return done();
													}
													return done();
												}
											});
										});
									}
									return waitfor();
								});
							});
						});
					});
				},
				getAPI: function(alias) {
					if (alias !== "FS") {
						throw new Error("API for alias '" + alias + "' not supported!");
					}
					VFS = self.getAPI("FS") || FS;
					if (typeof VFS.on === "function") {
						VFS.on("used-path", listener);
					} else {
						// self.getAPI("console").optimization("If `FS` is an instance of `./vfs.js` we can bypass gateway if all written files are older than read files");
					}
					return VFS;
				}
			};
			return api;
		}
		throw new Error("Proxy of type '" + type + "' not supported!");
	}

	// @unstable
	Context.prototype.reloadConfig = function(callback) {
		var self = this;
		return reloadContext(self, function(err) {
			if (err) return callback(err);			
			return callback(null, self.config);
		});
	}

	function makeConfigKey($pinf, ns) {
		if (ns.length === 0) {
			return ["config", $pinf.uid];
		} else
		if (ns[0] === "/") {
			return ["config"].concat(ns.slice(1));
		} else
		// TODO: Deprecate. Use `ns[0] === "/"`.
		if (ns[0] === "pinf/0/runtime/control/0") {
			return ["config"].concat(ns);
		} else {
			return ["config", $pinf.uid].concat(ns);
		}
	}

	// @unstable
	Context.prototype.ensureDefaultConfig = function(ns, config, callback) {
		if (!this.uid) {
			return callback(new Error("`uid` must be set for package '" + options._realpath(this.paths.package) + "'"));
		}
		if (typeof callback === "undefined" && typeof config === "function") {
			callback = config;
			config = ns;
			ns = [];
		}
		try {
			//   3) /.program.json (~ $PINF_PROGRAM)
			var store = new JSON_FILE_STORE(this.env.PINF_PROGRAM.replace(/\/\.?([^\/]*)$/, "\/.$1"));
			if (!store.exists()) store.init();
			var key = makeConfigKey(this, ns);
			var data = store.get(key) || {};
			data = DEEPMERGE(config || {}, data);
			store.set(key, data);
			store.save();
			return reloadContext(this, function(err) {
				if (callback) {
					if (err) return callback(err);
					return callback(null, data);
				}
				return;
			});
		} catch(err) {
			return callback(err);
		}
	}

	// @unstable
	Context.prototype.updateRuntimeConfig = function(ns, config, callback) {
		if (!this.uid) {
			return callback(new Error("`uid` must be set for package '" + options._realpath(this.paths.package) + "'"));
		}
		if (typeof callback === "undefined" && typeof config === "function") {
			callback = config;
			config = ns;
			ns = [];
		}
		try {
			var store = new JSON_FILE_STORE(this.env.PINF_RUNTIME);
			if (!store.exists()) store.init();
			var key = makeConfigKey(this, ns);
			var data = store.get(key) || {};
			data = DEEPMERGE(data, config || {});
			store.set(key, data);
			store.save();
			return reloadContext(this, function(err) {
				if (err) return callback(err);
				return callback(null, data);
			});
		} catch(err) {
			return callback(err);
		}
	}

	// @unstable
	Context.prototype.getRuntimeConfig = function(ns, callback) {
		if (!this.uid) {
			return callback(new Error("`uid` must be set for package '" + options._realpath(this.paths.package) + "'"));
		}
		if (typeof callback === "undefined" && typeof ns === "function") {
			callback = ns;
			ns = [];
		}
		try {
			var store = new JSON_FILE_STORE(this.env.PINF_RUNTIME);
			if (!store.exists()) return callback(null, {});
			var key = makeConfigKey(this, ns);
			return callback(null, store.get(key) || {});
		} catch(err) {
			return callback(err);
		}
	}

	// @unstable
	Context.prototype.clearRuntimeConfig = function(ns, callback) {
		if (!this.uid) {
			return callback(new Error("`uid` must be set for package '" + options._realpath(this.paths.package) + "'"));
		}
		if (typeof callback === "undefined" && typeof ns === "function") {
			callback = ns;
			ns = [];
		}
		try {
			var store = new JSON_FILE_STORE(this.env.PINF_RUNTIME);
			if (!store.exists()) store.init();
			var key = makeConfigKey(this, ns);
			store.remove(key);
			store.save();
			return reloadContext(this, callback);
		} catch(err) {
			return callback(err);
		}
	}

	// @unstable
	Context.prototype.clearDefaultConfig = function(ns, callback) {
		if (!this.uid) {
			return callback(new Error("`uid` must be set for package '" + options._realpath(this.paths.package) + "'"));
		}
		if (typeof callback === "undefined" && typeof ns === "function") {
			callback = ns;
			ns = [];
		}
		try {
			//   3) /.program.json (~ $PINF_PROGRAM)
			var store = new JSON_FILE_STORE(this.env.PINF_PROGRAM.replace(/\/\.?([^\/]*)$/, "\/.$1"));
			if (!store.exists()) store.init();
			var key = makeConfigKey(this, ns);
			store.remove(key);
			store.save();
			return reloadContext(this, callback);
		} catch(err) {
			return callback(err);
		}
	}

	// @experimental
	Context.prototype.getPackageInfo = function(path, callback) {
		var self = this;
		if (self._packageInfo[path]) {
			if (callback) {
				return callback(null, self._packageInfo[path]);
			}
			return self._packageInfo[path];
		}
		if (!callback) {
			throw new Error("No package info found for path '" + path + "'. Specify 'callback' to check `realpath(path)`");
		}
		return FS.exists(path, function(exists) {
			if (!exists) return callback(null, null);
			return FS.realpath(path, function(err, realpath) {
				if (err) return callback(err);
				if (self._packageInfo[realpath]) {
					return callback(null, self._packageInfo[realpath]);
				}
				return callback(null, null);
			});
		});
	}

	// @experimental
	Context.prototype.getProgramInfo = function(callback) {
		if (callback) {
			return callback(new Error("Function is now sync!"));
		}
		return this._programInfo;
    }

	function notifyPackages($pinf, eventId, config, callback) {
		var info = $pinf.getProgramInfo();
		if (
			!info.program.events ||
			!info.program.events.listen ||
			!info.program.events.listen[eventId]
		) return callback(null, {});
		var waitfor = WAITFOR.serial(function(err) {
			if (err) return callback(err);
			return $pinf.updateRuntimeConfig(["pinf/0/runtime/control/0", "program"], config, callback);
		});
		info.program.events.listen[eventId].forEach(function(handler) {
			var packageInfo = info.packages[handler.package];
	    	if (!$pinf._vm) {
				$pinf._vm = new VM($pinf);
			}
			return waitfor(function(done) {
				var opts = {};
				for (var name in options) {
					opts[name] = options[name];
				}
				opts.rootModule = handler.handler.substring(packageInfo.dirpath.length + 1);
	            return $pinf._vm.loadPackage(packageInfo.dirpath, opts, function(err, sandbox) {
	                if (err) return done(err);
	                if (options.verbose) console.log("[pinf-for-nodejs][context] notifyPackages - package loaded - " + packageInfo.dirpath);
		            return exports.context($pinf.env.PINF_PROGRAM, PATH.join(packageInfo.dirpath, "package.json"), opts, function(err, ctx) {
		                if (err) return done(err);
		                if (options.verbose) console.log("[pinf-for-nodejs][context] notifyPackages - context loaded");
		                if (options.verbose) console.log("[pinf-for-nodejs][context] notifyPackages - require root module - " + opts.rootModule);
		                var mod = sandbox.require(opts.rootModule);
		                if (options.verbose) console.log("[pinf-for-nodejs][context] notifyPackages - root module required");
		                if (typeof mod.main !== "function") {
		                	return done(new Error("Main module for package '" + packageInfo.dirpath + "' does not export 'main' function."));
		                }
		                var notifyStartTime = Date.now();
		                if (options.verbose) console.log(("[pinf-for-nodejs][context][START] Notify '" + packageInfo.dirpath + "' about '" + eventId + "'").blue);
		                return mod.main({
		                	$pinf: ctx
		                }, {
		                	event: eventId
		                }, function(err, result) {
			                if (options.verbose) console.log(("[pinf-for-nodejs][context][END] (" + (Date.now()-notifyStartTime) + " ms) Notify '" + packageInfo.dirpath + "' about '" + eventId + "'").blue);
		                    if (err) {
		                    	console.error("ERROR", err.stack);
		                    	return done(err);
		                    }
		                    config.daemons[handler.uid] = result;
		                    return done();
		                });
		            });
	            });
			});
		});
		return waitfor();
	}

	// @unstable
	Context.prototype.devProgram = function(callback) {
		var self = this;
		if (!self._programInfo.package) {
			return callback(new Error("No `boot.package` declared in program descriptor!"));
		}
		var devScript = self._programInfo.package.descriptor.exports.scripts.dev;
		if (!devScript) {
			return callback(new Error("No `dev` script declared!"));
		}
        if (options.verbose) console.log(("[pinf-for-nodejs][devProgram] Running dev script: " + devScript.bold).cyan);
		devScript = devScript.split(" ");
		var proc = SPAWN(devScript.shift(), devScript, {
			cwd: self._programInfo.package.path
		});
		proc.stdout.on('data', function (data) {
			process.stdout.write(data);
		});
		proc.stderr.on('data', function (data) {
			process.stderr.write(data);
		});
		proc.on('close', function (code) {
			// TODO: Deal with exit code?
			return callback(null);
		});
	}

	// @unstable
	Context.prototype.runProgram = function(callback) {
		var self = this;
		return self.startProgram({
			run: true
		}, function(err) {
			if (err) return callback(err);
			return self.stopProgram(callback);
		});
	}

	// @unstable
	Context.prototype.startProgram = function(options, callback) {
		var self = this;
		if (typeof options === "function" && typeof callback === "undefined") {
			callback = options;
			options = null;
		}
		options = options || {};
		function ensureStopped(callback) {
			return self.getRuntimeConfig(["pinf/0/runtime/control/0", "program"], function(err, config) {
				if (err) return callback(err);
				if (config.status === "starting" || config.status === "started") {
					if (options.restart === true) {
						return self.stopProgram(callback);
					} else {
						// TODO: Log nice console message instead of error with stack trace.
						var err = new Error("Cannot start program. Program is already starting/started. (status: " + config.status + ")");
						err.code = "ALREADY_STARTED";
						return callback(err);
					}
				}
				return callback(null);
			});
		}
		return ensureStopped(function(err) {
			if (err) return callback(err);
			var config = {
				status: "starting",
				daemonize: true,
				daemons: {}
			};
			if (options.run === true) {
				config.daemonize = false;
			}
			return self.updateRuntimeConfig(["pinf/0/runtime/control/0", "program"], config, function(err, config) {
				if (err) return callback(err);
				return notifyPackages(self, "pinf/0/runtime/control/0#events/start", config, function(err, config) {
					if (err) return callback(err);
					config.status = "started";
					return self.updateRuntimeConfig(["pinf/0/runtime/control/0", "program"], config, callback);
				});
			});
		});
	}

	// @unstable
	Context.prototype.stopProgram = function(callback) {
		var self = this;
		return self.getRuntimeConfig(["pinf/0/runtime/control/0", "program"], function(err, config) {
			if (err) return callback(err);
			if (config.status !== "starting" && config.status !== "started") {
				// TODO: Log nice console message instead of error with stack trace.
				var err = new Error("Cannot stop program. Program is not running. (status: " + config.status + ")");
				err.code = "NOT_STARTED";
				return callback(err);
			}
			return self.updateRuntimeConfig(["pinf/0/runtime/control/0", "program"], {
				status: "stopping"
			}, function(err, config) {
				if (err) return callback(err);
				return notifyPackages(self, "pinf/0/runtime/control/0#events/stop", config, function(err, config) {
					if (err) return callback(err);
					config.status = "stopped";
//					return self.clearRuntimeConfig(["pinf/0/runtime/control/0", "program"], function(err) {
					return self.updateRuntimeConfig(["pinf/0/runtime/control/0", "program"], config, function(err, config) {
						if (err) return callback(err);
						return callback(null, config);
					});
				});
			});
		});
	}

	// @unstable
	Context.prototype.getProgramStatus = function(callback) {
		try {
			var store = new JSON_FILE_STORE(this.env.PINF_RUNTIME);
			if (!store.exists()) return callback(null, {});			
			return callback(null, store.get(["config"]) || {});
		} catch(err) {
			return callback(err);
		}
	}

	// @unstable
	Context.prototype.testProgram = function(callback) {
		var self = this;
		return self.startProgram(function(err) {
			if (err) return callback(err);

console.log("TODO: Run tests program.");

			return self.stopProgram(callback);
		});
	}

	// @unstable
	Context.prototype.openProgram = function(callback) {
		var self = this;

		return exports.context(programDescriptorPath, PATH.join(__dirname, ".."), {
			PINF_PROGRAM: self.env.PINF_PROGRAM,
			PINF_RUNTIME: self.env.PINF_RUNTIME,
			uid: "pinf/0/project/control/0"
		}, function(err, context) {
			if (err) return callback(err);
			if (typeof context.config.open === "undefined") {
				return callback(new Error('No open command specified in program config at `config["pinf/0/project/control/0"].open`'));				
			}

console.log("TODO: Call `context.config.open` to open program.");

			return callback(null, {
				active: false
			});
		});
	}

	// @unstable
	Context.prototype.bundleProgram = function(bundleOptions, callback) {
		var self = this;
		if (typeof bundleOptions === "function" && typeof callback === "undefined") {
			callback = bundleOptions;
			bundleOptions = null;
		}
		bundleOptions = bundleOptions || {};
		var programInfo = self.getProgramInfo();
		if (
			!programInfo ||
			!programInfo.program ||
			!programInfo.program.descriptor ||
			!programInfo.program.descriptor.boot ||
			!programInfo.program.descriptor.boot.package
		) {
			return callback(new Error("No `boot.package` property specified in program descriptor!"));
		}
		var bootPackageInfo = programInfo.packages[programInfo.program.descriptor.boot.package];
		if (
			!bootPackageInfo.descriptor ||
			!bootPackageInfo.descriptor.exports ||
			!bootPackageInfo.descriptor.exports.bundles
		) {
			return callback(new Error("No `exports.bundles` property specified in boot package descriptor!"));
		}
		var bundles = bootPackageInfo.descriptor.exports.bundles;
		var opts = {};
		for (var name in options) {
			opts[name] = options[name];
		}
		for (var name in bundleOptions) {
			opts[name] = bundleOptions[name];
		}
		opts.rootPath = bootPackageInfo.dirpath;
		opts.distPath = opts.distPath || PATH.join(self.paths.program, (
			bootPackageInfo.descriptor.layout &&
			bootPackageInfo.descriptor.layout.directories &&
			bootPackageInfo.descriptor.layout.directories.bundles
		) || "bundles");
		var vm = new VM(self);
		var summary = {
			"bundles": {}
		};
		var waitfor = WAITFOR.serial(function(err) {
			if (err) return callback(err);
			return callback(null, summary);
		});
		for (var uri in bundles) {
			waitfor(uri, function(uri, done) {
				opts.rootModule = bundles[uri];
				if (options.verbose) console.log(("[pinf-for-nodejs][context] generate bundle for: " + opts.rootModule).yellow);
		        return vm.loadPackage(".", opts, function(err, info) {
		        	if (err) return done(err);
		        	// TODO: Attach more info from the vm.
		        	summary.bundles[bundles[uri]] = {};
					return done();
		        });
			});
		}
		return waitfor();
	}


	function populateContext(context, scope, options, callback) {

		function bypassIfWeCan(proceedCallback) {
			if (!options.$pinf) {
				return proceedCallback(callback);
			}
			var gateway = options.$pinf.gateway("vfs-write-from-read-mtime-bypass", {
				cacheNamespace: "pinf-context",
				skipFSCheck: (scope === "packages" && options.scanPackages !== true)
			});
			// All criteria that makes this call (argument combination) unique.
			gateway.setKey({
				scope: scope,
				programDescriptorPath: programDescriptorPath,
				packageDescriptorPath: packageDescriptorPath,
				PINF_RUNTIME: env.PINF_RUNTIME
			});

			// NOTE: `callback` will be called by gateway right away if we can bypass.
			return gateway.onDone(callback, function(err, proxiedCallback) {
				if (err) return 
				// If callback was triggered above we will get an empty callback back so we can just stop here.
				if (!proxiedCallback) return;
				options.API.FS = gateway.getAPI("FS");
				return proceedCallback(proxiedCallback);
			}, function(cachedData) {
				if (options.verbose) console.log("[pinf-for-nodejs][context] using cached context for", programDescriptorPath, packageDescriptorPath);
				for (var name in cachedData) {
					context[name] = cachedData[name];
				}
				context["#pinf"] = {
					status: 304,
					data: cachedData
				}
				return callback(null, context);
			});
		}

		return bypassIfWeCan(function(callback) {

			try {

				function loadConfigs(callback) {
					var opts = {};
					for (var name in options) {
						opts[name] = options[name];
					}
					opts.env = env;
					opts.includeUnknownProperties = true;

					if (options.verbose) console.log("[pinf-for-nodejs][context] program path:", PATH.dirname(env.PINF_PROGRAM));

					function load(callback) {

						opts.includePackages = (scope === "packages");
						opts.lookupPaths = (scope === "packages") ? [].concat(
							PROGRAM_INSIGHT.LOOKUP_PATHS[0],
							PROGRAM_INSIGHT.LOOKUP_PATHS.slice(PROGRAM_INSIGHT.LOOKUP_PATHS.length - 2)
						) : PROGRAM_INSIGHT.LOOKUP_PATHS;

						return PROGRAM_INSIGHT.parse(PATH.dirname(env.PINF_PROGRAM), opts, function(err, descriptor) {
				            if (err) return callback(err);

				            if (descriptor.errors.length > 0) {
				            	return callback(new Error("Package insight errors for '" + PATH.dirname(env.PINF_PROGRAM) + "': " + JSON.stringify(descriptor.errors)));
				            }

				            var lookupPaths = descriptor.lookupPaths.slice(0);
				            lookupPaths.reverse();
				            context.lookupPaths = context.lookupPaths.concat(lookupPaths);

				            var descriptorPaths = descriptor.descriptorPaths.slice(0);
				            descriptorPaths.reverse();
				            context.descriptorPaths = context.descriptorPaths.concat(descriptorPaths);

							if (descriptor.combined.config) {							
								context.config.push([descriptor.combined.config, "program"]);
								delete descriptor.config;
							}

				            context._descriptors.program = descriptor;

							if (env.PINF_PACKAGE) {
								packageDescriptorPath = env.PINF_PACKAGE;
							} else
				            if (!packageDescriptorPath) {
				            	if (descriptor.combined.boot && descriptor.combined.boot.package) {
									if (/^\//.test(descriptor.combined.boot.package)) {
					            		packageDescriptorPath = options._relpath(PATH.join(descriptor.combined.boot.package.replace(/package\.json$/, "package.json")));
									} else {
					            		packageDescriptorPath = options._relpath(PATH.join(descriptor.dirpath, descriptor.combined.boot.package.replace(/package\.json$/, "package.json")));
									}
									env.PINF_PACKAGE = packageDescriptorPath;
				            	}
				            }
							if (options.verbose) console.log("[pinf-for-nodejs][context] package path:", PATH.dirname(packageDescriptorPath));

							delete opts.lookupPaths;
					        return PACKAGE_INSIGHT.parse(PATH.dirname(packageDescriptorPath), opts, function(err, descriptor) {
					            if (err) return callback(err);

					            if (descriptor.errors.length > 0) {
					            	return callback(new Error("Package insight errors for '" + PATH.dirname(packageDescriptorPath) + "': " + JSON.stringify(descriptor.errors)));
					            }

					            var lookupPaths = descriptor.lookupPaths.slice(0);
					            lookupPaths.reverse();
					            context.lookupPaths = context.lookupPaths.concat(lookupPaths);

					            var descriptorPaths = descriptor.descriptorPaths.slice(0);
					            descriptorPaths.reverse();
					            context.descriptorPaths = context.descriptorPaths.concat(descriptorPaths);

								if (descriptor.combined.config) {
									context.config.push([descriptor.combined.config, "package"]);
									delete descriptor.config;
								}
					            context._descriptors.package = descriptor;

					            // TODO: Write cache file.

					            return callback(null);
					        });
				        });
					}

					return load(function(err) {
						if (err) return callback(err);

						function importEnvVars(callback) {
							var descriptor = context._descriptors.package;
							if (!descriptor.combined.requirements || !descriptor.combined.requirements.env) {
								return callback(null);
							}
							for (var name in descriptor.combined.requirements.env) {
								if (!/[A-Z_]/.test(name)) {
									return callback(new Error("ENV var '" + name + "' declared in " + JSON.stringify(Object.keys(descriptor.normalized)) + " must follow '[A-Z_]'"));
								}
								if (/^PINF_/.test(name)) {
									return callback(new Error("'PINF_*' ENV var '" + name + "' may not be declared in " + JSON.stringify(Object.keys(descriptor.normalized))));
								}
								if (/^(CWD)$/.test(name)) {
									return callback(new Error("Reserved ENV var '" + name + "' may not be declared in " + JSON.stringify(Object.keys(descriptor.normalized))));
								}
								context.env[name] = descriptor.combined.requirements.env[name];
							}
							return callback(null);
						}

						function recordBinPaths(callback) {
							var waitfor = WAITFOR.serial(callback);
							var checked = {};
							context.lookupPaths.forEach(function(path) {
								return waitfor(function(done) {
									var binPath = options._realpath(PATH.join(PATH.dirname(path), ".bin"));
									if (checked[binPath]) return done(null);
									checked[binPath] = true;
									return FS.exists(binPath, function(exists) {
										if (exists) {
											context.binPaths.unshift(options._relpath(binPath));
										}
										binPath = options._realpath(PATH.join(PATH.dirname(path), "bin"));
										if (checked[binPath]) return done(null);
										checked[binPath] = true;
										return FS.exists(binPath, function(exists) {
											if (exists) {
												context.binPaths.unshift(options._relpath(binPath));
											}
											return done(null);
										});
									});
								});
							});
							return waitfor();
						}

						return importEnvVars(function(err) {
							if (err) return callback(err);
							return recordBinPaths(callback);
						});
					});
				}

				function collectProgramEnvVars(callback) {
					if (
						!context._descriptors.program ||
						!context._descriptors.program.combined ||
						!context._descriptors.program.combined.requirements ||
						!context._descriptors.program.combined.requirements.env
					) return callback();
					for (var name in context._descriptors.program.combined.requirements.env) {
						if (typeof env[name] === "undefined") {
							env[name] = context._descriptors.program.combined.requirements.env[name].replace(new RegExp("\\$" + name, "g"), process.env[name]);
						}
					}
					return callback();
				}

				function injectPinfVars(callback) {
					for (var name in env) {
						if (/^PINF_/.test(name)) {
							context.env[name] = env[name];
						}
					}
					return callback();
				}

				function rerootEnvPaths(callback) {
					[
						"PINF_PACKAGES",
						"PINF_PROGRAM_PARENT",
						"PINF_PROGRAM",
						"PINF_PACKAGE",
						"PINF_RUNTIME",
						"CWD"
					].forEach(function(name) {
						if (!context.env[name]) return;
						if (name === "PINF_PACKAGES") {
							context.env[name] = context.env[name].split(":").map(function(path) {
								return options._relpath(path);
							}).join(":");
						} else {
							context.env[name] = options._relpath(context.env[name]);
						}
					});
					if (
						context._descriptors.program &&
						context._descriptors.program.combined &&
						context._descriptors.program.combined.boot
					) {
						if (originalProgramDescriptorPath && !originalPackageDescriptorPath) {
							if (context._descriptors.program.combined.boot.package) {
								context.env.PINF_PACKAGE = context._descriptors.program.combined.boot.package;
							}
						}
						if (context._descriptors.program.combined.boot.runtime) {
							context.env.PINF_RUNTIME = context._descriptors.program.combined.boot.runtime;
						}
					}
					return callback(null);
				}

				function replaceEnvVars(callback) {
					var json = JSON.stringify(context.env);
					for (var name in context.env) {
						if (typeof env[name] !== "undefined") {
							json = json.replace(new RegExp("\\$" + name, "g"), env[name]);
						} else
						if (typeof process.env[name] !== "undefined") {
							json = json.replace(new RegExp("\\$" + name, "g"), process.env[name]);
						}
					}
					var m = json.match(/\$([A-Z]{1}[A-Z0-9_]*)/g);
					if (m) {
						m.forEach(function(name) {
							throw new Error("The '" + name.substring(1) + "' environment variable must be set!");
						});
					}
					context.env = JSON.parse(json);
					return callback(null);
				}

				function collectConfig(callback) {
					var config = {};
					[
						"package",
						"program"
					].forEach(function(type) {
						context.config.forEach(function(json) {
							if (json[1] === type) {
								if (json[1] === "program") {
									if (context.uid && json[0][context.uid]) {
										config = DEEPMERGE(config, json[0][context.uid]);
									}
								} else {
									config = DEEPMERGE(config, json[0]);
								}
							}
						});
					});
					context.config = config;
					return callback(null);
				}

				function formatPaths(callback) {
					var basePath = PATH.join(context.env.PINF_RUNTIME, "..");
					function makePath(dir) {
						var path = PATH.join(basePath, dir);
						if (context.ns) {
							path = PATH.join(path, context.ns);
						}
						return path;
					}
					context.paths = {
						program: PATH.join(context.env.PINF_PROGRAM, ".."),
						package: PATH.join(context.env.PINF_PACKAGE, ".."),
						run: makePath("run"),
						data: makePath("data"),
						etc: makePath("etc"),
						log: makePath("log"),
						cache: makePath("cache"),
						tmp: makePath("tmp")
					};
					if (context._descriptors.package.combined.layout && context._descriptors.package.combined.layout.directories) {
						for (var name in context._descriptors.package.combined.layout.directories) {
							context.paths[name] = PATH.join(context.env.PINF_PACKAGE, "..", context._descriptors.package.combined.layout.directories[name]);
						}
					}
					return callback(null);
				}

				function summarizeProgramInfo(callback) {
			        var info = {
				        env: {
				            CWD: process.cwd()
				        },
				        program: {
				            path: context.paths.program,
				            package: context.paths.package,
				            runtime: context.env.PINF_RUNTIME,
				            events: {},
				            descriptor: DEEPCOPY(context._descriptors.program.combined)
				        },
				        package: null,
				        packages: {}
			        };
			        // Convert paths to IDs.
			        // TODO: Maybe already do this in `pinf-it-program-insight`.
			        if (info.program.descriptor.boot && info.program.descriptor.boot.package) {
				       	info.program.descriptor.boot.package = info.program.descriptor.packages[info.program.descriptor.boot.package].id;
			        }
			        for (var uri in info.program.descriptor.packages) {
			        	info.packages[info.program.descriptor.packages[uri].id] = {
			        		dirpath: info.program.descriptor.packages[uri].dirpath,
			        		descriptor: info.program.descriptor.packages[uri].combined
			        	};
			        }
			        delete info.program.descriptor.packages;

			        // We gather all event handlers from all packages in the program.
			        for (var id in info.packages) {
			        	if (info.packages[id].descriptor.events) {
			        		for (var type in info.packages[id].descriptor.events) {
			        			if (!info.program.events[type]) {
			        				info.program.events[type] = {};
			        			}
			        			for (var name in info.packages[id].descriptor.events[type]) {
				        			if (!info.program.events[type][name]) {
				        				info.program.events[type][name] = [];
				        			}
				        			info.program.events[type][name].push({
				        				package: id,
				        				// TODO: Make `uid` handler specific. It is scoped to the package for now.
				        				uid: info.packages[id].descriptor.uid,
				        				handler: info.packages[id].descriptor.events[type][name]
				        			});
			        			}
			        		}
			        	}
			        }
			        context._programInfo = info;
					return callback(null);
			    }

				function summarizePackageInfo(callback) {
					try {
				        var packages = (context._descriptors.program.combined && context._descriptors.program.combined.packages) || {};
				        var overrides = {};
				        for (var uri in packages) {
				        	if (packages[uri].combined.overrides) {
				        		for (var override in packages[uri].combined.overrides) {
				        			var p = PATH.join(packages[uri].dirrealpath, override);
				        			if (!overrides[p]) {
				        				overrides[p] = [];
				        			}
				        			overrides[p].push(packages[uri].combined.overrides[override]);
				        		}
				        	}
				        }

						for (var uri in packages) {
							var path = packages[uri].dirpath;
							var realpath = packages[uri].dirrealpath;

					        var info = {
						        env: {
						            CWD: process.cwd(),
						            PINF_PACKAGE: PATH.join(path, "package.json")
						        },
						        package: {
						            path: path,
						            id: packages[uri].id,
						            descriptor: packages[uri].combined
						        }
					        };
							var config = packages[uri].combined.config || {};
							if (overrides[realpath]) {
								overrides[realpath].forEach(function(override) {
									if (override.descriptor && override.descriptor.config) {
										var json = JSON.stringify(override.descriptor.config);
										function replaceAll(str, find, replace) {
											while (str.indexOf(find) > -1) {
												str = str.replace(find, replace);
											}
											return str;
										}
										// Temporarily replace all `\\$__DIRNAME` (escaped) so we can keep them.
							            json = replaceAll(json, "\\\\$__DIRNAME", "__TMP_tOtAlYrAnDoM__");
							            // Replace all `$__DIRNAME`.
							            json = json.replace(/\$__DIRNAME/g, packages[uri].dirpath);
							            // Put back escaped `$__DIRNAME` as the string should be kept.
							            json = json.replace(/__TMP_tOtAlYrAnDoM__/g, "$__DIRNAME");
						    			config = DEEPMERGE(config, JSON.parse(json));
									}
								});
							}
				    		if (
				    			packages[uri].combined.uid &&
				    			context._descriptors.program.combined &&
				    			context._descriptors.program.combined.config &&
				    			context._descriptors.program.combined.config[packages[uri].combined.uid]
				    		) {
				    			config = DEEPMERGE(config, context._descriptors.program.combined.config[packages[uri].combined.uid]);
				    		}
					        info.package.config = config;
							if (path !== realpath) {
								context._packageInfo[realpath] = info;
								context._packageInfo[path] = context._packageInfo[realpath];
							} else {
								context._packageInfo[path] = info;
							}
							if (path === context._programInfo.program.package) {
								context._programInfo.package = context._packageInfo[path].package;
							}
						}
						return callback(null);
					} catch(err) {
						return callback(err);
					}
				}

                if (scope === "root" && typeof options.API.FS.notifyUsedPath === "function") {
                    options.API.FS.notifyUsedPath(env.PINF_RUNTIME, "writeFile");
                    options.API.FS.notifyUsedPath(env.PINF_PROGRAM.replace(/\/\.?([^\/]*)$/, "\/.$1"), "writeFile");
                }

				return loadConfigs(function(err) {
					if (err) return callback(err);

					if (options.uid) {
						context.uid = options.uid;
					} else
					if (context._descriptors.package.combined.uid) {
						context.uid = exports.formatUid(context._descriptors.package.combined.uid);
					}

					return collectProgramEnvVars(function(err) {
						if (err) return callback(err);

						return injectPinfVars(function(err) {
							if (err) return callback(err);

							return rerootEnvPaths(function(err) {
								if (err) return callback(err);

								return replaceEnvVars(function(err) {
									if (err) return callback(err);

									return collectConfig(function(err) {
										if (err) return callback(err);

										if (context.uid) {
											context.ns = exports.uriToFilename(context.uid);
										} else {
											context.ns = PATH.basename(PATH.dirname(context.env.PINF_PACKAGE));
										}

										return formatPaths(function(err) {
											if (err) return callback(err);

											return summarizeProgramInfo(function(err) {
												if (err) return callback(err);

												return summarizePackageInfo(function(err) {
													if (err) return callback(err);

													delete context._descriptors;

													var ctx = context.clone();
													function clearAPI(ctx) {
														if (ctx.__proto__) {
															clearAPI(ctx.__proto__);
														}
														if (ctx._api) {
															ctx._api = {};
														}
													}
													clearAPI(ctx);

													return callback(null, ctx, context);
												});
											});
										});
									});
								});
							});
						});
					});
				});

			} catch(err) {
				return callback(err);
			}
		});
	}

	var rootContext = new Context();
	var packagesContext = rootContext.clone();

	// Init a virtual filesystem so we can track FS calls.
	var opts = {};
	for (var name in options) {
		opts[name] = options[name];
	}
	opts.$pinf = rootContext;
	return VFS.open("file://", opts, function(err, vfs) {
		if (err) return callback(err);
		opts.$pinf._api.FS = vfs;

		return populateContext(rootContext, "root", opts, function(err) {
			if (err) return callback(err);

			// TODO: We should not need to set this here again. For some reason the prototype chain on the `FS` object is gone.
			opts.$pinf._api.FS = vfs;

			return populateContext(packagesContext, "packages", opts, function(err) {
				if (err) return callback(err);

				rootContext._programInfo = packagesContext._programInfo;
				rootContext._packageInfo = packagesContext._packageInfo;

				rootContext._api = {};

				return callback(null, rootContext);
			});
		});
	});
}


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/context.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/helpers/cycle.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/helpers/cycle.js"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/helpers/cycle.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/helpers';
/*
    cycle.js
    2013-02-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true, regexp: true */

/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,
    retrocycle, stringify, test, toString
*/

if (typeof JSON.decycle !== 'function') {
    JSON.decycle = function decycle(object) {
        'use strict';

// Make a deep copy of an object or array, assuring that there is at most
// one instance of each object or array in the resulting structure. The
// duplicate references (which might be forming cycles) are replaced with
// an object of the form
//      {$ref: PATH}
// where the PATH is a JSONPath string that locates the first occurance.
// So,
//      var a = [];
//      a[0] = a;
//      return JSON.stringify(JSON.decycle(a));
// produces the string '[{"$ref":"$"}]'.

// JSONPath is used to locate the unique object. $ indicates the top level of
// the object or array. [NUMBER] or [STRING] indicates a child member or
// property.

        var objects = [],   // Keep a reference to each unique object or array
            paths = [];     // Keep the path to each unique object or array

        return (function derez(value, path) {

// The derez recurses through the object, producing the deep copy.

            var i,          // The loop counter
                name,       // Property name
                nu;         // The new object or array

// typeof null === 'object', so go on if this value is really an object but not
// one of the weird builtin objects.

            if (typeof value === 'object' && value !== null &&
                    !(value instanceof Boolean) &&
                    !(value instanceof Date)    &&
                    !(value instanceof Number)  &&
                    !(value instanceof RegExp)  &&
                    !(value instanceof String)) {

// If the value is an object or array, look to see if we have already
// encountered it. If so, return a $ref/path object. This is a hard way,
// linear search that will get slower as the number of unique objects grows.

                for (i = 0; i < objects.length; i += 1) {
                    if (objects[i] === value) {
                        return {$ref: paths[i]};
                    }
                }

// Otherwise, accumulate the unique value and its path.

                objects.push(value);
                paths.push(path);

// If it is an array, replicate the array.

                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    nu = [];
                    for (i = 0; i < value.length; i += 1) {
                        nu[i] = derez(value[i], path + '[' + i + ']');
                    }
                } else {

// If it is an object, replicate the object.

                    nu = {};
                    for (name in value) {
                        if (Object.prototype.hasOwnProperty.call(value, name)) {
                            nu[name] = derez(value[name],
                                path + '[' + JSON.stringify(name) + ']');
                        }
                    }
                }
                return nu;
            }
            return value;
        }(object, '$'));
    };
}


if (typeof JSON.retrocycle !== 'function') {
    JSON.retrocycle = function retrocycle($) {
        'use strict';

// Restore an object that was reduced by decycle. Members whose values are
// objects of the form
//      {$ref: PATH}
// are replaced with references to the value found by the PATH. This will
// restore cycles. The object will be mutated.

// The eval function is used to locate the values described by a PATH. The
// root object is kept in a $ variable. A regular expression is used to
// assure that the PATH is extremely well formed. The regexp contains nested
// * quantifiers. That has been known to have extremely bad performance
// problems on some browsers for very long strings. A PATH is expected to be
// reasonably short. A PATH is allowed to belong to a very restricted subset of
// Goessner's JSONPath.

// So,
//      var s = '[{"$ref":"$"}]';
//      return JSON.retrocycle(JSON.parse(s));
// produces an array containing a single element which is the array itself.

        var px =
            /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;

        (function rez(value) {

// The rez function walks recursively through the object looking for $ref
// properties. When it finds one that has a value that is a path, then it
// replaces the $ref object with a reference to the value that is found by
// the path.

            var i, item, name, path;

            if (value && typeof value === 'object') {
                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    for (i = 0; i < value.length; i += 1) {
                        item = value[i];
                        if (item && typeof item === 'object') {
                            path = item.$ref;
                            if (typeof path === 'string' && px.test(path)) {
                                value[i] = eval(path);
                            } else {
                                rez(item);
                            }
                        }
                    }
                } else {
                    for (name in value) {
                        if (typeof value[name] === 'object') {
                            item = value[name];
                            if (item) {
                                path = item.$ref;
                                if (typeof path === 'string' && px.test(path)) {
                                    value[name] = eval(path);
                                } else {
                                    rez(item);
                                }
                            }
                        }
                    }
                }
            }
        }($));
        return $;
    };
}
return {
    JSON: (typeof JSON !== "undefined") ? JSON : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    eval: (typeof eval !== "undefined") ? eval : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/helpers/cycle.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepmerge/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"98c6b74665bd9abac5c33394e3edfcf04ef251a1-deepmerge/index.js"}
require.memoize("98c6b74665bd9abac5c33394e3edfcf04ef251a1-deepmerge/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepmerge';
module.exports = function merge (target, src) {
    var array = Array.isArray(src)
    var dst = array && [] || {}

    if (array) {
        target = target || []
        dst = dst.concat(target)
        src.forEach(function(e, i) {
            if (typeof target[i] === 'undefined') {
                dst[i] = e
            } else if (typeof e === 'object') {
                dst[i] = merge(target[i], e)
            } else {
                if (target.indexOf(e) === -1) {
                    dst.push(e)
                }
            }
        })
    } else {
        if (target && typeof target === 'object') {
            Object.keys(target).forEach(function (key) {
                dst[key] = target[key]
            })
        }
        Object.keys(src).forEach(function (key) {
            if (typeof src[key] !== 'object' || !src[key]) {
                dst[key] = src[key]
            }
            else {
                if (!target[key]) {
                    dst[key] = src[key]
                } else {
                    dst[key] = merge(target[key], src[key])
                }
            }
        })
    }

    return dst
}

return {
    module: (typeof module !== "undefined") ? module : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepmerge/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/index.js"}
require.memoize("36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy';
/*!
 * deepcopy.js Copyright(c) 2013 sasa+1
 * https://github.com/sasaplus1/deepcopy.js
 * Released under the MIT License.
 */


/** export deepcopy function. */
module.exports = require('./lib/deepcopy');

return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy/lib/deepcopy.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/lib/deepcopy.js"}
require.memoize("36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/lib/deepcopy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy/lib';
/*!
 * @license deepcopy.js Copyright(c) 2013 sasa+1
 * https://github.com/sasaplus1/deepcopy.js
 * Released under the MIT License.
 */

(function() {

  // fallback for util methods.
  var util = (typeof module !== 'undefined') ? require('__SYSTEM__/util') : (function() {

    var to = Object.prototype.toString;

    function isArray(value) {
      return (
          typeof value === 'object' &&
          to.call(value) === '[object Array]');
    }

    function isDate(value) {
      return (
          typeof value === 'object' &&
          to.call(value) === '[object Date]');
    }

    function isRegExp(value) {
      return (
          typeof value === 'object' &&
          to.call(value) === '[object RegExp]');
    }

    return {
      // use Array.isArray if implemented.
      isArray: Array.isArray || isArray,
      isDate: isDate,
      isRegExp: isRegExp
    };

  }());

  // fallback for Object.keys.
  var getKeys = Object.keys || function(object) {
    var keys = [],
        key;

    if (object === null || typeof object !== 'object') {
      throw new TypeError('parameter type is not an Object');
    }

    for (key in object) {
      object.hasOwnProperty(key) && keys.push(key);
    }

    return keys;
  };

  /**
   * get element index from array.
   *
   * @private
   * @param {Array} array target array.
   * @param {*} searchElement find element.
   * @throws {TypeError} when parameter array is not an array.
   * @return {Number} return index of array. return -1 if element not found.
   */
  function indexOfArray(array, searchElement) {
    var i, len;

    if (!util.isArray(array)) {
      throw new TypeError('parameter type is not an Array');
    }

    for (i = 0, len = array.length; i < len; ++i) {
      if (array[i] === searchElement) {
        return i;
      }
    }

    return -1;
  }

  /**
   * get deep copy of target.
   *
   * return deep copy if target is Date, RegExp or primitive types.
   * return shallow copy if target is function.
   *
   * do recursive copy if target is Array or Object.
   * also can copy if target has circular reference.
   *
   * @param {*} target target of deep copy.
   * @return {*} deep copy value.
   */
  function deepcopy(target) {
    var clone = (util.isArray(target)) ? [] : {},
        visited = [target],
        ref = [clone];

    /**
     * get deep copy of target.
     *
     * @private
     * @param {*} target target of deep copy.
     * @param {Object|Array} clone reference of deep copy value.
     * @param {Object[]} visited copied references.
     * @param {Object[]} ref reference of own.
     * @return {*} deep copy value.
     */
    function deepcopy_(target, clone, visited, ref) {
      var keys, i, len, key, value, index, object, reference;

      // number, string, boolean, null, undefined and function.
      if (target === null || typeof target !== 'object') {
        return target;
      }

      if (util.isDate(target)) {
        return new Date(Number(target));
      }

      if (util.isRegExp(target)) {
        return new RegExp(
            target.source,
            String(target).slice(target.source.length + 2));
      }

      keys = getKeys(target);

      for (i = 0, len = keys.length; i < len; ++i) {
        key = keys[i];
        value = target[key];

        if (value !== null && typeof value === 'object') {
          index = indexOfArray(visited, value);
          if (index === -1) {
            object = (util.isArray(value)) ? [] : {};
            visited.push(value);
            ref.push(object);
          } else {
            reference = ref[index];
          }
        }

        // value is not reference type if object is undefined.
        // not used object variable if target is not reference type.
        clone[key] = reference || deepcopy_(value, object, visited, ref);
        index = object = reference = null;
      }

      return clone;
    }

    return deepcopy_(target, clone, visited, ref);
  }

  // export function.
  if (typeof module !== 'undefined') {
    module.exports = deepcopy;
  } else {
    this.deepcopy = deepcopy;
  }

}());

return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    Array: (typeof Array !== "undefined") ? Array : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy/lib/deepcopy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/json-file-store.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/json-file-store.js"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/json-file-store.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib';

// TODO: Move into own project at `github.com/cadorn/json-file-store`.

const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");


var JsonFileStore = exports.JsonFileStore = function(file, options) {
    if (!(this instanceof exports.JsonFileStore))
        return new exports.JsonFileStore(file, options);

    this.file = file;
    this.options = options || {};
    if (typeof this.options.throwOnNoExist === "undefined") {
        this.options.throwOnNoExist = true;
    }

    this.data = {};
}

JsonFileStore.prototype.exists = function() {
    return FS.existsSync(this.file);
};

JsonFileStore.prototype.getFile = function() {
    return this.file;
}

JsonFileStore.prototype.init = function() {
    if(this.exists()) {
        throw new Error("Store exists. Cannot initialize store at: " + this.file);
    }
    this.data = {};
    this.save(true);
};

JsonFileStore.prototype.set = function() {
    if(arguments.length==1) {
        this.data = arguments[0];
    } else
    if(arguments.length==2) {
        var data = this.get(arguments[0], true, true);
        data[0][data[1]] = arguments[1];
    } else {
        throw new Error("Invalid argument count: " + arguments.length);
    }
    this.dirty = true;
    this.save();
};

JsonFileStore.prototype.remove = function(keysPath) {
    var data = this.get(keysPath, false, true);
    if(!data) {
        return false;
    }
    delete data[0][data[1]];
    this.dirty = true;
    this.save();
    return true;
};

exports.getFromObject = function(obj, keysPath, createObjects, returnWithKey) {
    if (!obj) {
        return null;
    }
    if(!keysPath) {
        return obj;
    }
    var keys = [];
    keysPath.forEach(function(key) {
        if(Array.isArray(key)) {
            keys.push(key.join(""));
        } else {
            keys.push(key);
        }
    });
    var data = obj,
        key;
    while(true) {
        if(keys.length==1 && returnWithKey===true) {
            return [data, keys.shift()];
        }
        if(keys.length==0) break;
        key = keys.shift();
        if(!data[key]) {
            if(createObjects===true) {
                data[key] = {};
            } else {
                return null;
            }
        }
        data = data[key];
    }
    return data;
}

JsonFileStore.prototype.get = function(keysPath, createObjects, returnWithKey) {
    this.load();
    return exports.getFromObject(this.data, keysPath, createObjects, returnWithKey);
};

JsonFileStore.prototype.has = function(keysPath) {
    return (this.get(keysPath)!==null);
};


JsonFileStore.prototype.hasFileChanged = function() {
    if(!this.exists()) return false;
    return !(""+this.fileMtime == ""+FS.statSync(this.file).mtime);
}

JsonFileStore.prototype.load = function(force) {
    if(this.dirty && !force) {
        throw new Error("Cannot load store. Unsaved data present.");
    }
    if(!this.exists()) {
        if (this.options.throwOnNoExist) {
            throw new Error("Cannot load store. Store does not exist on disk at: " + this.file);
        }
        return;
    }
    if(this.hasFileChanged()) {
        var json = false;
        try {
            json = FS.readFileSync(this.file).toString();
            this.data = JSON.parse(json);
        } catch(e) {
            console.error("JSON STRING", json);
            throw new Error("Error parsing JSON from file: " + this.file);
        }
        this.fileMtime = FS.statSync(this.file).mtime;
    }
    this.dirty = false;
};

JsonFileStore.prototype.save = function(force) {
    if(!this.exists() && !force) {
        throw new Error("Cannot save store. Store does not exist on disk at: " + this.file);
    }
    if(this.hasFileChanged() && !force) {
        throw new Error("Cannot save store. Data changed on disk: "+this.file);
    }
    if(!this.dirty && !force) return;
    if(!FS.existsSync(PATH.dirname(this.file))) FS.mkdirsSync(PATH.dirname(this.file));
    var data = JSON.stringify(this.data, null, 4);
    if (FS.existsSync(this.file)) {
        if (FS.readFileSync(this.file).toString() === data) {
            this.dirty = false;
            return;
        }
    }
    FS.writeFileSync(this.file, data);
    this.fileMtime = FS.statSync(this.file).mtime;
    this.dirty = false;
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/json-file-store.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-primitives-js/primitives.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"76a2f12f0a8696a3a9d97df34f43db89b9601bda-pinf-primitives-js/primitives.js"}
require.memoize("76a2f12f0a8696a3a9d97df34f43db89b9601bda-pinf-primitives-js/primitives.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-primitives-js';

const PATH = require("__SYSTEM__/path");
const DEEPCOPY = require("deepcopy");


exports.normalizeEnvironmentVariables = function(env, overrides) {
	overrides = overrides || {};
	var ENV = DEEPCOPY(env || process.env);
	for (var name in overrides) {
		if (typeof overrides[name] !== "undefined") {
			ENV[name] = overrides[name];
		}
	}
	if (!ENV.PINF_PROGRAM && !ENV.CWD) {
		throw new Error("Either `ENV.PINF_PROGRAM` (" + ENV.PINF_PROGRAM + ") or `ENV.CWD` (" + ENV.CWD + ") must be set!");
	}
	// `PINF_PACKAGES` contains a list of directories used to lookup packages.
	// Packages should be stored in these directories where the package directory
	// represents the global ID of the package. This is ideally a DNS-based hostname with path.
	ENV.PINF_PACKAGES = (typeof ENV.PINF_PACKAGES === "string") ? ENV.PINF_PACKAGES : (process.env.PINF_PACKAGES || "");
	// If `PINF_PROGRAM_PARENT` is set the parent descriptor will be merged on top of our descriptor.
	// Under normal conditions the `PINF_PROGRAM_PARENT` varibale should never be set in the shell directly.
	// `PINF_PROGRAM_PARENT` is used when a program boots other programs as part of its own runtime to tell sub program
	// to store runtime info in parent context.
	// e.g. `/path/to/program.json`
	ENV.PINF_PROGRAM_PARENT = (typeof ENV.PINF_PROGRAM_PARENT === "string") ? ENV.PINF_PROGRAM_PARENT : (process.env.PINF_PROGRAM_PARENT || "");
	// These environment variables declare what to boot and in which state:
	//   * A local filesystem path to a `program.json` file (how to boot & custom config).
	ENV.PINF_PROGRAM = ENV.PINF_PROGRAM || PATH.join(ENV.CWD, "program.json");
	//   * A local filesystem path to a `package.json` file (what to boot & default config).
	ENV.PINF_PACKAGE = ENV.PINF_PACKAGE || (ENV.CWD && PATH.join(ENV.CWD, "package.json")) || "";
	//   * A local filesystem path to a `program.rt.json` file (the state to boot in).
	ENV.PINF_RUNTIME = ENV.PINF_RUNTIME || PATH.join(ENV.PINF_PROGRAM_PARENT || ENV.PINF_PROGRAM, "../.rt/program.rt.json");
	//   * The mode the runtime should run it. Will load `program.$PINF_MODE.json`.
	ENV.PINF_MODE = ENV.PINF_MODE || "production";
	return ENV;
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-primitives-js/primitives.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/lib/program-insight.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"c6035683eb37f4f966e46471e9a2606bd8fc5934-pinf-it-program-insight/lib/program-insight.js"}
require.memoize("c6035683eb37f4f966e46471e9a2606bd8fc5934-pinf-it-program-insight/lib/program-insight.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/lib';

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const WAITFOR = require("waitfor");
const DEEPMERGE = require("deepmerge");
const DEEPCOPY = require("deepcopy");
const CRYPTO = require("__SYSTEM__/crypto");
const FS = require("__SYSTEM__/fs");
const PACKAGE_INSIGHT = require("pinf-it-package-insight");


// Descriptors get merged on top of each other in reverse order.
exports.LOOKUP_PATHS = [
	//   1) /program.$PINF_MODE.json (~ $PINF_PROGRAM)
	function (ENV) {
		return ENV.PINF_PROGRAM.replace(".json", "." + ENV.PINF_MODE + ".json");
	},
	//   2) /.rt/program.rt.json ($PINF_RUNTIME)
	//		The `rt` descriptor holds the runtime information for this instance of the program. There can always
	//		only be one runtime instance of a program installation. If you want to boot a second, create an
	//		inheriting program descriptor in a new directory and boot it there.
	function (ENV) {
		return ENV.PINF_RUNTIME;
	},
	//   3) /.program.json (~ $PINF_PROGRAM)
	function (ENV) {
		return ENV.PINF_PROGRAM.replace(/\/\.?([^\/]*)$/, "\/.$1");
	},
	//   5) /program.json ($PINF_PROGRAM)
	function (ENV) {
		return ENV.PINF_PROGRAM;
	},
	//   7) <parent>/program.json ($PINF_PROGRAM_PARENT)
	function (ENV) {
		return ENV.PINF_PROGRAM_PARENT;
	}
];


exports.parse = function(programPath, options, callback) {

	options = options || {};

	if (options.debug) console.log("[pinf-it-program-insight] programPath", programPath);

	// TODO: We should not need to copy `env`. It should not be modified in code below.
	if (options.env) {
		options.env = DEEPCOPY(options.env);
	}

	options._realpath = function(path) {
		if (!options.rootPath) return path;
		if (/^\//.test(path)) return path;
		return PATH.join(options.rootPath, path);
	}

	var opts = {};
	for (var name in options) {
		opts[name] = options[name];
	}
	// TODO: Get list of files to search from `pinf-for-nodejs/lib/context.LOOKUP_PATHS`. Exclude the 'package' paths.
	opts.lookupPaths = opts.lookupPaths || exports.LOOKUP_PATHS;

	var visitedDependencies = {};

	return PACKAGE_INSIGHT.parse(programPath, opts, function(err, programDescriptor) {
		if (err) return callback(err);

		function followDependencies(descriptor, callback) {
			if (
				!descriptor.combined.dependencies ||
				!descriptor.combined.dependencies.bundled
			) {
				return callback(null);
			}
			var waitfor = WAITFOR.serial(callback);
			for (var alias in descriptor.combined.dependencies.bundled) {
				waitfor(alias, function(alias, done) {
					if (!descriptor.combined.dependencies.bundled[alias]) return done();
					return followPackage(PATH.join(descriptor.dirpath, descriptor.combined.dependencies.bundled[alias]), done);
				});
			}
			return waitfor();
		}

		function followPackage(uri, callback) {
			if (
				programDescriptor.combined.packages &&
				programDescriptor.combined.packages[uri]
			) {
				return callback(null);
			}
			return FS.realpath(options._realpath(uri), function(err, realUri) {
				if (err) return callback(err);
				if (visitedDependencies[realUri]) {
					return callback(null);
				}
				return FS.exists(options._realpath(uri), function(exists) {
					if (!exists) return callback(null);
					var opts = {};
					for (var name in options) {
						opts[name] = options[name];
					}
					if (opts.env) {
						opts.env.PINF_PACKAGE = "";
					}
					delete opts.lookupPaths;
					return PACKAGE_INSIGHT.parse(uri, opts, function(err, descriptor) {
						if (err) return callback(err);

						if (!programDescriptor.combined.packages) {
							programDescriptor.combined.packages = {};
						}
						programDescriptor.combined.packages[uri] = descriptor;
						visitedDependencies[realUri] = true;

						if (!options.includePackages) return callback(null); 

						return followDependencies(descriptor, callback);
					});
				});
			});
		}

		// Now that we have the program descriptor we parse the boot package
		// and include all linked package descriptors in our program descriptor.
		if (
			!programDescriptor.combined.boot ||
			!programDescriptor.combined.boot.package
		) {
			return callback(null, programDescriptor);
		}
		return followPackage(programDescriptor.combined.boot.package, function(err) {
			if (err) return callback(err);

			return callback(null, programDescriptor);
		});
	});
}


exports.parseDescriptor = PACKAGE_INSIGHT.parseDescriptor;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/lib/program-insight.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/index.js"}
require.memoize("c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy';
// deepcopy Copyright(c) 2013 sasa+1
// https://github.com/sasaplus1/deepcopy
// Released under the MIT License.

module.exports = require('./lib/deepcopy');

return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy/lib/deepcopy.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/lib/deepcopy.js"}
require.memoize("c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/lib/deepcopy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy/lib';
// deepcopy Copyright(c) 2013 sasa+1
// https://github.com/sasaplus1/deepcopy
// Released under the MIT License.

var util = require('__SYSTEM__/util');

function deepcopy(targetObject) {
  var targetObjectType = typeof targetObject,
      stringifiedRegExp, lastSlashIndex,
      cloneObject, keys, i, len, keyValue;

  if (targetObject === null ||
      targetObjectType === 'function' ||
      targetObjectType !== 'object') {
    return targetObject;
  }

  if (util.isDate(targetObject)) {
    return new Date(targetObject);
  }

  if (util.isRegExp(targetObject)) {
    stringifiedRegExp = String(targetObject);
    lastSlashIndex = stringifiedRegExp.lastIndexOf('/');

    return new RegExp(
        stringifiedRegExp.slice(1, lastSlashIndex),
        stringifiedRegExp.slice(lastSlashIndex + 1));
  }



  cloneObject = (util.isArray(targetObject)) ? [] : {};
  keys = Object.keys(targetObject);

  for (i = 0, len = keys.length; i < len; ++i) {
    keyValue = keys[i];
    cloneObject[keyValue] = deepcopy(targetObject[keyValue]);
  }

  return cloneObject;
}

module.exports = deepcopy;

return {
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    deepcopy: (typeof deepcopy !== "undefined") ? deepcopy : null,
    String: (typeof String !== "undefined") ? String : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy/lib/deepcopy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/vm.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/vm.js"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/vm.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib';

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");
const RT_BUNDLER = require("pinf-it-bundler/lib/rt-bundler");
const LOADER = require("./loader");
const CONTEXT = require("./context");
const VFS = require("./vfs");


var VM = exports.VM = function($pinf) {
	this.$pinf = $pinf;
	this.sandboxes = {};
}

VM.prototype.loadPackage = function(uri, options, finalCallback) {
	var self = this;
	if (typeof options === "function" && typeof finalCallback === "undefined") {
		finalCallback = options;
		options = null;
	}
	options = options || {};
	var key = uri + ":" + (options.rootModule || "");

	var startTime = Date.now();
	if (options.verbose) console.log(("[pinf-for-nodejs][vm][START] load package: " + uri).inverse);

	var callback = function() {
		if (options.verbose) console.log(("[pinf-for-nodejs][vm][END] (" + (Date.now() - startTime) + " ms) load package: " + uri).inverse);
		return finalCallback.apply(this, arguments);
	}

	if (self.sandboxes[key] && options.ttl !== -1) {
		if (options.verbose) console.log(("[pinf-for-nodejs][vm] using cached sandbox: " + key).green);
		return callback(null, self.sandboxes[key]);
	}

	options._realpath = function(path) {
		if (!options.rootPath) return path;
		if (/^\//.test(path)) return path;
		return PATH.join(options.rootPath, path);
	}

	options._relpath = function(path) {
		if (!path || !options.rootPath || !/^\//.test(path)) return path;
		return PATH.relative(options.rootPath, path);
	}

	// If we can find a bundled package we use it instead of bundeling again
	// unless `forceBundle` is set.
	function loadBundledPackage(bundleCallback) {
		if (options.forceBundle) {
			return bundleCallback(null);
		}
		// Load package descriptor to look for bundle config info.
		return FS.readJson(options._realpath(PATH.join(uri, "package.json")), function(err, descriptor) {
			if (err) {
				return callback(new Error("Error '" + err.message + "' parsing package descriptor: " + options._realpath(uri)));
			}
			if (
				!descriptor.exports ||
				!descriptor.exports.main ||
				!descriptor.layout ||
				!descriptor.layout.directories ||
				!descriptor.layout.directories.bundle
			) {
				// Insufficient config info to reach pre-built bundles.
				return bundleCallback(null);
			}
			var rootBundlePath = PATH.join(uri, descriptor.layout.directories.bundle, descriptor.exports.main);
			return FS.exists(options._realpath(rootBundlePath), function(exists) {
				if (!exists) {
					// Root bundle not found where it should be. It has likely not been generated yet.
					return bundleCallback(null);
				}
				if (options.verbose) console.log(("[pinf-for-nodejs][vm] using pre-generated root bundle: " + rootBundlePath).green);
				return LOADER.sandbox(rootBundlePath, {
					verbose: options.verbose || false,
					debug: options.debug || false,
					ttl: options.ttl,
					rootPath: options.rootPath,
					globals: options.globals,
					resolveDynamicSync: function (moduleObj, pkg, sandbox, canonicalId, options) {
						if (/^\//.test(canonicalId)) {
							return PATH.join(moduleObj.bundle.replace(/\.js$/, ""), canonicalId);
						} else {
							// TODO: Deal with package alias prefixes.
						}
						console.log("canonicalId", canonicalId);
		            	throw new Error("`resolveDynamicSync` should not be called here! Make sure all dynamic links are declared in the package descriptor!");
		            },
					ensureAsync: function(moduleObj, pkg, sandbox, canonicalId, options, callback) {
						// We assume dynamic link points to a generated bundle.
						return callback(null);
		            }
				}, function(sandbox) {
					self.sandboxes[key] = sandbox;
					return callback(null, sandbox);
				}, callback);
			});			
		});
	}

	return loadBundledPackage(function(err) {
		if (err) return callback(err);

		var distPath = options.distPath || self.$pinf.makePath("cache", PATH.join("vm", CONTEXT.uriToFilename(uri), "dist"));

		if (options.verbose) console.log(("[pinf-for-nodejs][vm] load via bundler").yellow);

		var opts = self.$pinf.makeOptions({
			$pinf: options.$pinf || null,
			verbose: options.verbose || false,
			debug: options.debug || false,
			test: options.test || false,
			ttl: options.ttl,
			rootPath: options.rootPath,
			rootModule: options.rootModule,
			distPath: distPath,
			onRun: function(bundlePath, sandboxOptions, callback) {
				return LOADER.sandbox(bundlePath, sandboxOptions, function(sandbox) {
					return callback();
				}, callback);
			},
			getLoaderReport: function() {
				return LOADER.getReport();
			}
		});

		if (typeof options.ttl === "undefined" && options.$pinf) {
			options.ttl = options.$pinf.ttl;
		}
		if (options.ttl === -1) {
			// Remove the dist path to force re-generate the bundle.
			FS.removeSync(opts.distPath);
		} else {
			// TODO: We don't remove the dist path by default now that the bundler cache is working.
			//       We may still need to get the bundler to delete the dist file or clean it up
			//		 rather than just agument it if it retains stale data.
		}

		return VFS.open("file://", opts, function(err, vfs) {
			if (err) return callback(err);

			opts.$pinf._api.FS = vfs;

			if (options.verbose) console.log(("[pinf-for-nodejs][vm] bundling package: " + uri));

			return RT_BUNDLER.bundlePackage(uri, opts, function(err, bundleDescriptors, helpers) {
				if (err) return callback(err);

				FS.outputJson(bundleDescriptors["#pinf"].data.rootBundlePath + ".bundle.json", bundleDescriptors);

				if (options.verbose) console.log(("[pinf-for-nodejs][vm] using root bundle: " + bundleDescriptors["#pinf"].data.rootBundlePath));

				return LOADER.sandbox(bundleDescriptors["#pinf"].data.rootBundlePath, {
					verbose: options.verbose || false,
					debug: options.debug || false,
					ttl: options.ttl,
		            resolveDynamicSync: helpers.resolveDynamicSync,
		            ensureAsync: helpers.ensureAsync
				}, function(sandbox) {
					self.sandboxes[key] = sandbox;
					return callback(null, sandbox);
				}, callback);
			});
		});
	});
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/vm.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/rt-bundler.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/rt-bundler.js"}
require.memoize("5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/rt-bundler.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib';

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");
const Q = require("q");
const BUNDLER = require("./bundler");
const COLORS = require("colors");


exports.bundlePackage = function(bundlePackagePath, bundleOptions, callback) {

	ASSERT.equal(typeof bundleOptions, "object");
	ASSERT.equal(typeof bundleOptions.distPath, "string");
	ASSERT.equal(typeof bundleOptions.onRun, "function");

	bundleOptions.API = {
		FS: FS
	};

	var rootBundlePath = null;

	var startTime = Date.now();
	if (bundleOptions.verbose) console.log(("[pinf-it-bundler][rt-bundler][START] request bundled package: " + bundlePackagePath).inverse);

	function bypassIfWeCan(proceedCallback) {
		if (!bundleOptions.$pinf) {
			return proceedCallback(callback);
		}
		var gateway = bundleOptions.$pinf.gateway("vfs-write-from-read-mtime-bypass");
		// All criteria that makes this call (argument combination) unique.
		gateway.setKey({
			bundlePackagePath: bundlePackagePath,
			distPath: bundleOptions.distPath,
			rootModule: bundleOptions.rootModule,
			rootPath: bundleOptions.rootPath
		});
		// NOTE: `callback` will be called by gateway right away if we can bypass.
		return gateway.onDone(callback, function(err, proxiedCallback) {
			if (err) return 
			// If callback was triggered above we will get an empty callback back so we can just stop here.
			if (!proxiedCallback) return;
			bundleOptions.API.FS = gateway.getAPI("FS");
			return proceedCallback(function() {
				if (bundleOptions.verbose) console.log(("[pinf-it-bundler][rt-bundler][END] (" + (Date.now() - startTime) + " ms) request bundled package: " + bundlePackagePath + " (distPath: " + bundleOptions.distPath + ")").inverse);
				return proxiedCallback.apply(this, arguments);
			});
		}, function(cachedData, cacheMeta) {
			if (bundleOptions.verbose) console.log(("[pinf-it-bundler][rt-bundler] using cached bundle (based on: " + cacheMeta.cachePath + ")").green);
			var bundleDescriptors = cachedData.bundleDescriptors;
			bundleDescriptors["#pinf"].status = 304;
			if (bundleOptions.verbose) console.log(("[pinf-it-bundler][rt-bundler][END] (" + (Date.now() - startTime) + " ms) request bundled package: " + bundlePackagePath).inverse);
			// NOTE: Keep in sync with return values used at bottom of this code file.			
			return callback(null, bundleDescriptors, {
				ensureAsync: function(moduleObj, pkg, sandbox, canonicalId, options, callback) {

					if (bundleOptions.debug) console.log("[pinf-it-bundler][rt-bundler] ensureAsync (originally bypassed)", "moduleObj", moduleObj, "pkg", pkg, "sandbox", sandbox, "canonicalId", canonicalId);

				 	var identifier = options.resolveIdentifier(canonicalId);
				 	if (identifier && identifier[0].descriptor) {
						var sourcePath = PATH.join(identifier[0].descriptor.dirpath, identifier[1]);
						if (cachedData.bundleDescriptors[sourcePath]) {
							// We are all good. Dynamic bundle should be available as it was found in `cachedData.bundleDescriptors`
							// which gets generated when root bundle and reachable dynamic bundles get generated.
							return callback(null);
						} else {
						 	//if (bundleOptions.$pinf) bundleOptions.$pinf.getAPI("console").optimization("To avoid spinning up the bundler, ensure the '" + BUNDLER.normalizeExtension(canonicalId) + "' bundle gets generated along with the parent bundle '" + moduleObj.bundle + "' by configuring an async require rule in the package descriptor '" + pkg.id + "' for module '" + moduleObj.id + "' contained in the parent bundle.");
						}
				 	}

				 	// TODO: Match more cases above where bundle should be found.

					console.log("TODO: `require.async()` was called. We need more asynchronosly required modules. Spin up bundler based on existing bundles and generate missing bundle for module.");
					throw new Error("TODO: `require.async()` was called. We need more asynchronosly required modules. Spin up bundler based on existing bundles and generate missing bundle for module.");
				},
				resolveDynamicSync: function (moduleObj, pkg, sandbox, canonicalId, options) {
					// NOTE: We should never get here. The loader should intercept the call
					//		 and service it based on instructions from a meta file.
					throw new Error("Module `" + canonicalId + "` not found!");
				}
			});
		});
	}

	return bypassIfWeCan(function(callback) {

		if (bundleOptions.verbose) console.log(("[pinf-it-bundler][rt-bundler] bundle package: " + bundlePackagePath).yellow);

		var bundleDescriptors = {};

		function bundleDescriptorForId(bundleId) {
			for (var id in bundleDescriptors) {
				if (id === bundleId) {
					if (bundleDescriptors[id].bundles) {
						return bundleDescriptors[id].bundles[bundleDescriptors[id].exports.main];
					} else {
						return bundleDescriptors[id];
					}
				}
				for (var subid in bundleDescriptors[id].bundles) {
					if (bundleDescriptors[id].bundles[subid].bundle.path === bundleId) {
						return bundleDescriptors[id].bundles[subid];
					} else
					if ((bundleOptions.distPath + subid) === bundleId) {
						return bundleDescriptors[id].bundles[subid];
					}
				}
			}
			return null;
		}

		function getExistingModules(moduleObj) {

			var loaderReport = bundleOptions.getLoaderReport();

			ASSERT.equal(typeof loaderReport.sandboxes, "object");

			function getSandbox() {
				ASSERT.equal(typeof moduleObj.bundle, "string");

				for (var sandboxId in loaderReport.sandboxes) {

					ASSERT.equal(typeof loaderReport.sandboxes[sandboxId].bundles, "object");

					if (typeof loaderReport.sandboxes[sandboxId].bundles[moduleObj.bundle] === "undefined") continue;

					return loaderReport.sandboxes[sandboxId];
				}

				return false;
			}

			var sandbox = getSandbox();

			var modules = {};

			function forModule(moduleObj) {

				var bundleDescriptor = bundleDescriptorForId(moduleObj.bundle);

				if (bundleDescriptor) {
					for (var memoizeId in sandbox.modules) {
						if (!modules[memoizeId] && bundleDescriptor.modules[memoizeId]) {
							modules[memoizeId] = bundleDescriptor.modules[memoizeId];
							modules[memoizeId]._getBundleDescriptor = function() {
								return bundleDescriptor;
							}
						}
					}
				}

				if (moduleObj.parentModule) return forModule(moduleObj.parentModule);
			}

			forModule(moduleObj);

			return modules;
		}

		function getBundleBasePath(moduleObj) {

			ASSERT.equal(typeof moduleObj.bundle, "string");

			return moduleObj.bundle.replace(/\.js$/, "");
		}

		// `aliasid` id a mappings alias (if mappings info not memoized) or a
		// resolved package ID (if mappings info already memoized).
		function getMappingInfo(moduleObj, aliasid) {

			var loaderReport = bundleOptions.getLoaderReport();

			ASSERT.equal(typeof loaderReport.sandboxes, "object");

			var info = null;
			var packageDescriptorPaths = [];

			var packageDescriptor = null;
			var bundleDescriptor = null;
			var existingModules = getExistingModules(moduleObj);

			if (existingModules[moduleObj.pkg + "/package.json"]) {
				packageDescriptor = existingModules[moduleObj.pkg + "/package.json"].descriptor;
				bundleDescriptor = existingModules[moduleObj.pkg + "/package.json"]._getBundleDescriptor();
			} else {
				bundleDescriptor = bundleDescriptorForId(moduleObj.bundle);
				packageDescriptor = bundleDescriptor.modules[moduleObj.pkg + "/package.json"].descriptor
			}

			packageDescriptorPaths.push(PATH.join(bundleOptions.rootPath || "", packageDescriptor.dirpath));

			function forModule() {

				ASSERT.equal(typeof moduleObj.bundle, "string");

				for (var sandboxId in loaderReport.sandboxes) {

					ASSERT.equal(typeof loaderReport.sandboxes[sandboxId].bundles, "object");

					if (typeof loaderReport.sandboxes[sandboxId].bundles[moduleObj.bundle] === "undefined") continue;

					var sandbox = loaderReport.sandboxes[sandboxId];

					// See if `aliasid` is an alias for a package or resolved packge ID already.
					if (sandbox.modules[moduleObj.pkg + "/package.json"] && sandbox.modules[moduleObj.pkg + "/package.json"].mappings) {
						for (var alias in sandbox.modules["/package.json"].mappings) {
							if (sandbox.modules[moduleObj.pkg + "/package.json"].mappings[alias] === aliasid) {
								info = {
									alias: alias,
									pkg: aliasid,
									memoized: true
								};
								break;
							} else
							if (alias === aliasid) {
								info = {
									alias: aliasid,
									pkg: sandbox.modules[moduleObj.pkg + "/package.json"].mappings[alias],
									memoized: true
								};
								break;
							}
						}					
					}

					// If mapping was not found we look for it in the bundle info.
					if (!info) {
						for (var alias in packageDescriptor.combined.mappings) {
							if (packageDescriptor.combined.mappings[alias] === aliasid) {
								info = {
									alias: alias,
									pkg: aliasid,
									memoized: false
								};
								break;
							} else
							if (alias === aliasid) {
								info = {
									alias: aliasid,
									pkg: packageDescriptor.combined.mappings[alias],
									memoized: false
								};
								break;
							}
						}
					}

					if (info) {
						info.bundleDescriptor = bundleDescriptor;
						info.path = packageDescriptor.combined.dependencies.bundled[info.alias];
						var parentPath = packageDescriptor.dirpath.substring(bundlePackagePath.length + 1);
						if (parentPath) {
							info.path = "./" + PATH.join(parentPath, info.path);
						}
					}

					// We stop as we checked the sandbox 
					return;
				}
			}

			if (moduleObj.pkg === aliasid) {
				info = {
					alias: aliasid,
					pkg: aliasid,
					memoized: true,
					bundleDescriptor: bundleDescriptor,
					path: packageDescriptor.dirpath.substring(bundlePackagePath.length + 1)
				};
			} else {
				forModule(moduleObj);
			}

			if (!info) {
//				console.log("moduleObj", moduleObj);
				throw new Error("Alias '" + aliasid + "' not found in mappings for package " + JSON.stringify(packageDescriptorPaths));
			}

			return info;
		}

		if (!bundleOptions.on) {
			bundleOptions.on = {};
		}
		bundleOptions.on.newBundle = function(path, descriptor) {
			bundleDescriptors[path] = descriptor;			
		}

		return BUNDLER.bundlePackage(bundlePackagePath, bundleOptions, function(err, descriptor) {
			if (err) return callback(err);

			bundleDescriptors[bundlePackagePath] = descriptor;

			try {

				ASSERT(typeof descriptor === "object");

				if (descriptor.errors.length > 0) {
					descriptor.errors.forEach(function(error) {
						var err = new Error("Got '" + error[0] + "' error '" + error[1] + "' for '" + bundlePackagePath + "'");
						err.stack = error[2];
						throw err;
					});
				}

			} catch(err) {
				return callback(err);
			}

			var bundling = [];

			function resolveDynamicSync (moduleObj, pkg, sandbox, canonicalId, options) {

				if (bundleOptions.debug) console.log("[pinf-it-bundler] resolveDynamicSync", "moduleObj", moduleObj, "pkg", pkg, "sandbox", sandbox, "canonicalId", canonicalId);

				var path = null;

				moduleObj = moduleObj || options.lastModuleRequireContext.moduleObj;

				var bundleBasePath = getBundleBasePath(moduleObj);

				if (/^\//.test(canonicalId)) {
					path = PATH.join(bundleBasePath, canonicalId);

					if (!bundleOptions.API.FS.existsSync(PATH.join(bundleOptions.rootPath || "", path))) {
						var filePath = PATH.join(bundlePackagePath, canonicalId);
						var options = {
							$pinf: bundleOptions.$pinf || null,
							debug: bundleOptions.debug || false,
							test: bundleOptions.test || false,
							rootPath: bundleOptions.rootPath,
							distPath: bundleBasePath,
							existingModules: getExistingModules(moduleObj)
						};

						var deferred = Q.defer();
						BUNDLER.bundleFile(filePath, options, function(err, descriptor) {
							if (err) return deferred.reject(err);

							bundleDescriptors[path] = descriptor;

							return deferred.resolve();
						});
						bundling.push(deferred.promise);
						// We throw to stop sandbox execution and catch it below
						// so we can re-run sandbox when bundle is generated.
						var error = new Error("Bundling dynamic require '" + canonicalId + "' for '" + ((moduleObj.parentModule && moduleObj.parentModule.id) || "<main>") + "'.");
						error.code = "BUNDLING_DYNAMIC_REQUIRE";
						throw error;
					}
				} else {

					if (/^\./.test(canonicalId)) {
						var parentId = PATH.dirname(moduleObj.id);
						canonicalId = (parentId==="/"?".":"") + PATH.normalize(PATH.join(parentId, canonicalId));
					}

					var canonicalIdParts = canonicalId.split("/");
					var alias = canonicalIdParts.shift();
					var id = canonicalIdParts.join("/");

					var mappingInfo = null;
					if (/^\./.test(alias)) {
						mappingInfo = {
							alias: "",
							path: "",
							pkg: "",
							memoized: true
						}
					} else {
						mappingInfo = getMappingInfo(moduleObj, alias);		
					}
					// Update alias and canonicalId if alias was a resolved package ID.
					if (mappingInfo.alias !== alias) {
						alias = mappingInfo.alias;
						canonicalId = alias + "/" + id;
					}

					var distId = null;
					if (mappingInfo.pkg) {
						distId = PATH.normalize(mappingInfo.pkg + ((id) ? "/" + id : ""));//.replace(/\//g, "+")
					} else {
						distId = PATH.normalize(id);//.replace(/\//g, "+")
					}
					var distFilename = options.normalizeIdentifier(distId);

					path = PATH.join(bundleBasePath, distFilename);

					if (!bundleOptions.API.FS.existsSync(PATH.join(bundleOptions.rootPath || "", path))) {

						var filePath = PATH.join(bundlePackagePath, mappingInfo.path);

						var opts = {
							$pinf: bundleOptions.$pinf || null,
							debug: bundleOptions.debug || false,
							test: bundleOptions.test || false,
							rootPath: bundleOptions.rootPath,
							distPath: bundleBasePath,
							distFilename: distFilename,
							// TODO: Compensate for `directories.lib`
							rootModule: ((id) ? "./" + PATH.normalize(options.normalizeIdentifier(id)) : "").replace(/^\.$/, ""),
							rootPackage: mappingInfo.pkg,
							existingModules: getExistingModules(moduleObj)
						};

						var deferred = Q.defer();
						BUNDLER.bundlePackage(filePath, opts, function(err, subDescriptor) {									
							if (err) return deferred.reject(err);

							bundleDescriptors[path] = subDescriptor;

							if (mappingInfo.memoized) return deferred.resolve();

							// We need to add the package mapping to the calling bundle.

							return BUNDLER.augmentBundle(mappingInfo.bundleDescriptor.bundle.path, opts, function(err, bundle, done) {
								if (err) return deferred.reject(err);

								var moduleInfo = bundle.modules[moduleObj.pkg + "/package.json"];
								var descriptor = JSON.parse(moduleInfo[0]);
								if (!descriptor.mappings) {
									descriptor.mappings = {};
								}
								if (pkg.id !== mappingInfo.pkg) {
									descriptor.mappings[mappingInfo.alias] = mappingInfo.pkg;
								}
								moduleInfo[0] = JSON.stringify(descriptor, null, 4);
								mappingInfo.bundleDescriptor.modules[moduleObj.pkg + "/package.json"].descriptor.memoized = descriptor;

								return done(function(err) {
									if (err) return deferred.reject(err);
									return deferred.resolve();
								});
							});
						});
						bundling.push(deferred.promise);
						// We throw to stop sandbox execution and catch it below
						// so we can re-run sandbox when bundle is generated.
						var error = new Error("Bundling dynamic require '" + canonicalId + "' for '" + ((moduleObj.parentModule && moduleObj.parentModule.id) || "<main>") + "'.");
						error.code = "BUNDLING_DYNAMIC_REQUIRE";
						throw error;
					}
				}
				return path;
			}

			function ensureAsync(moduleObj, pkg, sandbox, canonicalId, options, callback) {

				if (bundleOptions.debug) console.log("[pinf-it-bundler] ensureAsync", "moduleObj", moduleObj, "pkg", pkg, "sandbox", sandbox, "canonicalId", canonicalId);

			 	// If bundle is already cached we have nothing to do.
			 	if (bundleDescriptors[BUNDLER.normalizeExtension(canonicalId)]) {
			 		return callback(null);
			 	}
				try {
					resolveDynamicSync(moduleObj, pkg, sandbox, canonicalId, options);
					return callback(null);
				} catch(err) {
					if (err.code === "BUNDLING_DYNAMIC_REQUIRE") {
						// We wait until everything is bundled and then return.
						return Q.all(bundling).then(function() {
							return callback(null);
						}).fail(callback);
					}
					return callback(err);
				}
			}

			function runBundle() {

				return Q.fcall(function() {

					var deferred = Q.defer();
					var bundlePath = PATH.join(bundleOptions.distPath, descriptor.exports.main);

					if (!rootBundlePath) {
						rootBundlePath = bundlePath;
					}

					bundleOptions.onRun(bundlePath, {
						$pinf: bundleOptions.$pinf || null,
						debug: bundleOptions.debug || false,
						test: bundleOptions.test || false,
						rootPath: bundleOptions.rootPath,
						resolveDynamicSync: resolveDynamicSync,
						ensureAsync: ensureAsync
					}, function(err) {
						if (err) return deferred.reject(err);
						return deferred.resolve();
					});

					return deferred.promise;

				}).fail(function(err) {
					// If we are generating a missing bundle, we wait for it
					// and then re-run sandbox.
					if (err.code === "BUNDLING_DYNAMIC_REQUIRE") {
						return Q.all(bundling).then(function() {
							return runBundle();
						});
					}
					return Q.reject(err);
				});
			}

			return runBundle().then(function() {
				// NOTE: Keep in sync with return values used at top of this code file.
				bundleDescriptors["#pinf"] = {
					status: 200,
					data: {
						rootBundlePath: rootBundlePath
					}
				};
				return callback(null, bundleDescriptors, {
					ensureAsync: ensureAsync,
					resolveDynamicSync: resolveDynamicSync
				},
				// NOTE: This last argument gets taken by the gateway above to cache and return when bypassing.
				{
					rootBundlePath: rootBundlePath,
					bundleDescriptors: bundleDescriptors
				});
			}, callback);
		});
	});
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/rt-bundler.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/bundler.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/bundler.js"}
require.memoize("5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/bundler.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib';

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");
const DEEPCOPY = require("deepcopy");
const WAITFOR = require("waitfor");
const MODULE_INSIGHT = require("pinf-it-module-insight");
const PACKAGE_INSIGHT = require("pinf-it-package-insight");
const BUNDLE = require("./bundle");
const WRAPPER = require("./wrapper");
const BROWSER_BUILTINS = require("browser-builtins");


exports.normalizeExtension = function (pathid) {
	if (/(^|\/)[^\.]*$/.test(pathid)) {
		pathid += ".js";
	}
	return pathid;
}

exports.augmentBundle = function(bundleFilePath, options, callback) {
	return BUNDLE.open(bundleFilePath, options, function(err, bundle) {
		if (err) return callback(err);
		return callback(null, bundle, function(callback) {
			return bundle.save(function(err) {
				if (err) return callback(err);
				return bundle.close(function(err) {
					if (err) return callback(err);
					return callback(null);
				});
			});
		});
	});
}

exports.bundlePackage = function(bundlePackagePath, options, callback) {

	ASSERT.equal(typeof options, "object");
	ASSERT.equal(typeof options.distPath, "string");

	options.API = {
		FS: (options.$pinf && options.$pinf.getAPI("FS")) || FS
	};

	options._realpath = function(path) {
		if (!options.rootPath) return path;
		if (/^\//.test(path)) return path;
		return PATH.join(options.rootPath, path);
	}

	var bundlePackageDescriptor = {
		bundles: {},
		warnings: [],
		errors: []
	};

	function bundleFile(bundleFilePath, callback) {

		if (options.debug) console.log("[pinf-it-bundler] bundlePackage/bundleFile", bundleFilePath);

		var packageDescriptors = {};

		function loadPackageDescriptorForPath(path, options, callback) {
			if (packageDescriptors[path]) {
				return callback(null, packageDescriptors[path]);
			}
			return PACKAGE_INSIGHT.parse(path, options, function(err, packageDescriptor) {
				if (err) return callback(err);

				if (packageDescriptor.errors.length > 0) {
					packageDescriptor.errors.forEach(function(error) {
						console.error(error, new Error().stack);
					});
					return callback(new Error("We had errors in package descriptor '" + path + "'!"));
				}

				return callback(null, (packageDescriptors[path] = packageDescriptor));
			});
		}

		var packages = {};

		function getPackageDescriptorForPath(path, options, callback) {
			if (packages[path]) {
				return callback(null, packages[path][0], packages[path][1]);
			}
			return loadPackageDescriptorForPath(path, options, function(err, packageDescriptor) {
				if (err) return callback(err);

				if (path === bundleFilePath) {
					packageDescriptor.id = "";
				}
				if (!packageDescriptor.memoized) {
					packageDescriptor.memoized = {};
				}
				if (
					packageDescriptor.combined.exports &&
					packageDescriptor.combined.exports.main
				) {
					packageDescriptor.memoized.main = (packageDescriptor.id || options.rootPackage || "") + packageDescriptor.combined.exports.main.replace(/^\./, "");
				}
				if (
					packageDescriptor.combined.layout &&
					packageDescriptor.combined.layout.directories &&
					packageDescriptor.combined.layout.directories.lib
				) {
					packageDescriptor.memoized.directories = {
						lib: packageDescriptor.combined.layout.directories.lib.replace(/^\.\//, "")
					};
				}

				function resolvePackageId(id, callback) {
					function checkDescriptor(packageDescriptor, callback) {
						if (packageDescriptor.combined.dependencies) {
							var dependencyLocator = null;
							[
								// TODO: Why bundled first?
								"bundled",
								"required"
								// TODO: Add more types?
							].forEach(function (type) {
								if (dependencyLocator) return;
								if (
									packageDescriptor.combined.dependencies[type] &&
									packageDescriptor.combined.dependencies[type][id]
								) {
									dependencyLocator = packageDescriptor.combined.dependencies[type][id];
								}
							});
							if (dependencyLocator) {
								// TODO: Support various `dependencyLocator` formats.
								var aliasedPackagePath = PATH.join(path, dependencyLocator);
								return getPackageDescriptorForPath(
									aliasedPackagePath,
									options,
									function(err, aliasdPackageDescriptor, packageExtras) {
										if (err) return callback(err);
										return callback(null, aliasedPackagePath, aliasdPackageDescriptor, packageExtras);
									}
								);
							}
						}
						// If we are dealing with dependencies in `node_modules` directories we go up the tree.
						// This is the default behavior.
						function resolve(path) {
							return options.API.FS.exists(PATH.join(path, "node_modules", id), function(exists) {
								if (exists) {
									return getPackageDescriptorForPath(
										options._relpath(PATH.join(path, "node_modules", id)),
										options,
										function(err, aliasdPackageDescriptor, packageExtras) {
											if (err) return callback(err);
											return callback(null, options._relpath(PATH.join(path, "node_modules", id)), aliasdPackageDescriptor, packageExtras);
										}
									);
								}
								if (PATH.dirname(path) === path) return callback(null);
								return resolve(PATH.dirname(path));
							});
						}

						if (!id && path === packageDescriptor.dirpath) {
							return callback(null, path, packages[path][0], packages[path][1]);
						}
						return resolve(PATH.dirname(options._realpath(path)));
					}
					return checkDescriptor(packageDescriptor, callback);
				}

				packages[path] = [packageDescriptor, {
					locateFileInPackage: function(descriptor, id, callback) {
						var idParts = id.split("/");

						// TODO: Relocate this elsewhere. Maybe `pinf-primitives-js`?
/*
						// TODO: Use this check but allow for inheriting default from parent package.
						if (
							packageDescriptor.combined &&
							packageDescriptor.combined.requirements &&
							packageDescriptor.combined.requirements.engines &&
							packageDescriptor.combined.requirements.engines.node
						) {
*/
							// NOTE: We assume we are running on nodejs.
							try {
								if (id !== "require" && require.resolve(id) === id) {
									// We have a system module and assume it will be provided at runtime.
									return callback(null, true, "", {});
								}
							} catch(err) {}
//						}

						return resolvePackageId(idParts[0], function(err, aliasedPackagePath, aliasdPackageDescriptor, packageExtras) {
							if (err) return callback(err);

							if (!aliasedPackagePath) {
								// We assume package will be provided at runtime.
								return callback(null, true, "", {});
							}

							try {
								if (!packageDescriptor.memoized.mappings) {
									packageDescriptor.memoized.mappings = {};
								}

								if (aliasdPackageDescriptor.dirpath === packageDescriptor.dirpath) {
									// We requested the main module from a package.
									idParts = [options.rootPackage || ""];
								}

								// Package was required.
								// Package is not a system module.
								// Package should have been found in bundled dependencies but was not.
								// Package is likely declared as optional dependency but not installed (i.e. bundled).
								if (!aliasdPackageDescriptor) {
									// TODO: Check `packageDescriptor.combined.dependencies` to see if declared as optional.
									// We assume package will be provided at runtime.
									return callback(null, true, "", {});
								}

								if (idParts[0]) {
									packageDescriptor.memoized.mappings[idParts[0]] = aliasdPackageDescriptor.id;
								}

								var modulePath = null;
								var memoizeId = null;
								if (idParts.length > 1) {
									if (
										aliasdPackageDescriptor.combined.layout &&
										aliasdPackageDescriptor.combined.layout.directories &&
										aliasdPackageDescriptor.combined.layout.directories.lib
									) {
										// HACK: We need a toggle for whether to always inject lib dir or not.
										//		 For now we simply skip injecting lib dir if second id segment matches lib dir.
										if (idParts.length >= 2 && idParts[1] !== aliasdPackageDescriptor.combined.layout.directories.lib.replace(/^\.\//, "")) {
											idParts[1] = aliasdPackageDescriptor.combined.layout.directories.lib.replace(/^\.\//, "") + "/" + idParts[1];
										}
									}
									modulePath = PATH.join(aliasedPackagePath, exports.normalizeExtension(idParts.slice(1).join("/")));
									memoizeId = aliasdPackageDescriptor.id + "/" + idParts.slice(1).join("/");
								} else {
									if (
										!aliasdPackageDescriptor.combined.exports ||
										!aliasdPackageDescriptor.combined.exports.main
									) {
										throw new Error("`exports.main` must be set if no module specified when requiring package '" + id + "' from package '" + path + "'");
									}
									modulePath = PATH.join(aliasedPackagePath, aliasdPackageDescriptor.combined.exports.main);
									memoizeId = (aliasdPackageDescriptor.id || idParts[0]) + aliasdPackageDescriptor.combined.exports.main.replace(/^\.|\.js$/, "");
								}

								return callback(null, modulePath, memoizeId, packageExtras);
							} catch(err) {
								return callback(err);
							}
						});
					}
				}];
				return callback(null, packages[path][0], packages[path][1]);
			});
		}

		return getPackageDescriptorForPath(bundleFilePath, options, function(err, packageDescriptor, packageExtras) {
			if (err) return callback(err);

			var rootModule = options.rootModule;
			if (!rootModule) {
				try {
					ASSERT.equal(typeof packageDescriptor.combined.exports, "object");
					ASSERT.equal(typeof packageDescriptor.combined.exports.main, "string");
				} catch(err) {
					return callback(new Error("Package descriptor for '" + bundleFilePath + "' does not declare `main` module"));
				}
				rootModule = packageDescriptor.combined.exports.main;
			}
			var rootPackage = options.rootPackage || "";

			var opts = {};
			for (var name in options) {
				opts[name] = options[name];
			}
			opts.packageExtras = packageExtras || null;

			opts.finalizeBundle = function(bundleDescriptor, bundle, callback) {
				for (var packagePath in packages) {

					if (options.test) {
						packages[packagePath][0].mtime = "0";
					}

					var memoized = packages[packagePath][0].memoized || {};
					memoized.dirpath = packages[packagePath][0].dirpath;

					if (Object.keys(memoized).length > 0) {
						var pkgId = packages[packagePath][0].id || options.rootPackage || "";
					}

					bundleDescriptor.modules[pkgId + "/package.json"] = {
						requireId: pkgId + "/package.json",
						memoizeId: pkgId + "/package.json",
						descriptor: packages[packagePath][0],
						wrapper: "json"
					};
					bundle.setModule(
						pkgId + "/package.json",
						JSON.stringify(memoized, null, 4), {
							filename: packages[packagePath][0].dirpath + "/package.json"
						}, {
							file: null,
							mtime: 0,
							wrapper: "json",
							format: "json"
						}
					);
				}
				return callback(null);
			}

			opts.rootModule = rootModule;

			return exports.bundleFile(PATH.join(bundleFilePath, rootModule), opts, function(err, bundleDescriptor) {
				if (err) return callback(err);

				var bundleId = rootModule.replace(/^\.\//, "/");

				bundleDescriptor.id = bundleId;

				if (
					bundleDescriptor.modules[rootPackage + "/package.json"] &&
					typeof bundleDescriptor.modules[rootPackage + "/package.json"].descriptor.dirpath === "undefined"
				) {
					packageDescriptor.memoized = bundleDescriptor.modules[rootPackage + "/package.json"].descriptor.memoized;
					bundleDescriptor.modules[rootPackage + "/package.json"].descriptor = packageDescriptor;
				}

				bundlePackageDescriptor.bundles[bundleId] = bundleDescriptor;

				bundleDescriptor.warnings.forEach(function(warning) {
					bundlePackageDescriptor.warnings.push([].concat(warning, "file", rootModule));
				});
				bundleDescriptor.errors.forEach(function(error) {
					bundlePackageDescriptor.errors.push([].concat(error, "file", rootModule));
				});

				return callback(null, bundleDescriptor);
			});
		});
	}

	if (options.debug) console.log("[pinf-it-bundler] bundlePackage", bundlePackagePath);

	return bundleFile(bundlePackagePath, function(err, bundleDescriptor) {
		if (err) return callback(err);

		bundlePackageDescriptor.exports = {
			main: bundleDescriptor.id
		};

		return callback(null, bundlePackageDescriptor);
	});
}

exports.bundleFile = function(bundleFilePath, options, callback) {
	try {

		ASSERT.equal(typeof options, "object");
		ASSERT.equal(typeof options.distPath, "string");

		options.API = {
			FS: (options.$pinf && options.$pinf.getAPI("FS")) || FS
		};

		options._realpath = function(path) {
			if (!options.rootPath) return path;
			if (/^\//.test(path)) return path;
			return PATH.join(options.rootPath, path);
		}
	
		options._relpath = function(path) {
			if (!path || !options.rootPath || !/^\//.test(path)) return path;
			return PATH.relative(options.rootPath, path);
		}

		var packageDescriptors = {};

		options.packageDescriptorForModule = function(path, callback) {
			return PACKAGE_INSIGHT.findPackagePath(options._realpath(path), function(err, path) {
				if (err) return callback(err);
				path = options._relpath(path);
				if (packageDescriptors[path]) {
					return callback(null, packageDescriptors[path]);
				}
				return PACKAGE_INSIGHT.parse(path, options, function(err, packageDescriptor) {
					if (err) return callback(err);
					if (packageDescriptor.errors.length > 0) {
						packageDescriptor.errors.forEach(function(error) {
							console.error(error, new Error().stack);
						});
						return callback(new Error("We had errors in package descriptor '" + path + "'!"));
					}					
					return callback(null, (packageDescriptors[path] = packageDescriptor));
				});
			});
		}


		var bundleDescriptor = null;
		var bundle = null;
		var rootPackage = options.rootPackage || "";
		var rootPackageDescriptor = null;


		function realpath(path, callback) {
			return options.API.FS.exists(options._realpath(path), function(exists) {
				if (exists) return callback(null, path);
				if (typeof options.locateMissingFile === "function") {
					return options.locateMissingFile(null, path, callback);
				}
				return callback(new Error("Missing dependency '" + path + "'"));
			});
		}

		function init(bundleFilePath, callback) {

			return options.packageDescriptorForModule(bundleFilePath, function(err, descriptor) {
				if (err) return callback(err);
				rootPackageDescriptor = descriptor;
				bundleDescriptor = {
					modules: {},
					expectExistingModules: {},
					bundle: {
						path: PATH.join(options.distPath,
							options.distFilename ||
							(descriptor && descriptor.dirpath !== "." && bundleFilePath.substring(descriptor.dirpath.length + 1)) ||
							(/^\//.test(bundleFilePath) ? PATH.basename(bundleFilePath) : bundleFilePath)
						)
					},
					warnings: [],
					errors: []
				};
				return callback(null);
			});
		}

		function openBundle(bundlePath, callback) {
			return BUNDLE.open(bundlePath, options, function(err, openedBundle) {
				if (err) return callback(err);
				bundle = openedBundle;
				return callback(null);
			});
		}

		function addFile(filePath, options, callback) {

			return MODULE_INSIGHT.parseFile(filePath, options, function(err, moduleDescriptor) {
				if (err) return callback(err);

				if (moduleDescriptor.errors.length > 0) {
					moduleDescriptor.errors.forEach(function(error) {
						console.error(error, new Error().stack);
					});
				}

				var descriptor = {
					requireId: options.id,
					memoizeId: exports.normalizeExtension(options.id),
					descriptor: moduleDescriptor,
					wrapper: {
						type: null,
						top: null,
						code: null,
						bottom: null
					},
					// The dependencies that the bundler will try and follow.
					dependencies: DEEPCOPY(moduleDescriptor.dependencies),
					warnings: [].concat(moduleDescriptor.warnings),
					errors: [].concat(moduleDescriptor.errors)
				};
				delete moduleDescriptor.warnings;
				delete moduleDescriptor.errors;

				if (options.existingModules && options.existingModules[descriptor.memoizeId]) {
					bundleDescriptor.expectExistingModules[descriptor.requireId] = options.existingModules[descriptor.memoizeId];
					return callback(null, descriptor);
				}

				return WRAPPER.wrapModule(descriptor, options, function(err) {
					if (err) return callback(err);

					var header = WRAPPER.headerForWrapper(descriptor.wrapper.type);
					if (header) {
						bundle.setHeader({
							helper: descriptor.wrapper.type
						}, header);							
					}
					if (options.test) {
						descriptor.descriptor.mtime = 0;
					}

					bundleDescriptor.modules[descriptor.memoizeId] = descriptor;

					bundle.setModule(
						descriptor.memoizeId,
						(descriptor.wrapper.code || [
							descriptor.wrapper.top,
							descriptor.descriptor.code,
							descriptor.wrapper.bottom
						].join("\n")), {
							filename: descriptor.descriptor.filepath
						}, {
							file: filePath,
							mtime: ((options.test) ? 0 : moduleDescriptor.mtime),
							wrapper: descriptor.wrapper.type,
							format: moduleDescriptor.format
						}
					);

					return callback(null, descriptor);
				});
			});
		}

		function resolveModuleId(descriptor, id, options, callback) {
			var memoizeId = id;
			id = exports.normalizeExtension(id);

			function finalize(callback) {
				// Assume path is relative to bundle root module.
				return callback(null, PATH.join(descriptor.descriptor.filepath, "..", id), "/" + memoizeId);
			}

			// Check for id relative to module.
			if (/^\./.test(id)) {
				return options.API.FS.exists(PATH.join(descriptor.descriptor.filepath, "..", memoizeId.replace(/\.js$/, "")), function(exists) {
					if (exists) {
						return options.API.FS.exists(PATH.join(descriptor.descriptor.filepath, "..", memoizeId.replace(/\.js$/, ""), "package.json"), function(exists) {
							if (exists) {
								// Resolve to package dependency.
								if (options.packageExtras && typeof options.packageExtras.locateFileInPackage === "function") {
									return options.packageExtras.locateFileInPackage(descriptor, PATH.normalize(PATH.join(PATH.dirname(descriptor.memoizeId), memoizeId)), function(err, path, memoizeId, packageExtras) {
										if (err) return callback(err);
										if (path === true && !memoizeId) {
											// We have a system module.
											return callback(null, true);
										}
										if (!path || !memoizeId) return finalize(callback);
										return callback(null, path, memoizeId, packageExtras);
									});
								}
							}
							return options.API.FS.exists(PATH.join(descriptor.descriptor.filepath, "..", memoizeId, "index.js"), function(exists) {
								if (exists) {
									return callback(null, PATH.join(descriptor.descriptor.filepath, "..", memoizeId, "index.js"), PATH.join(descriptor.requireId, "..", memoizeId, "index"));
								}
								return callback(null, PATH.join(descriptor.descriptor.filepath, "..",  memoizeId.replace(/\.js$/, "") + ".js"), PATH.join(descriptor.requireId, "..", memoizeId.replace(/\.js$/, "") + ".js"));
							});
						});
					}
					return callback(null, PATH.join(descriptor.descriptor.filepath, "..", id), PATH.join(descriptor.requireId, "..", memoizeId));
				});
			}
			// Resolve to package dependency.
			if (options.packageExtras && typeof options.packageExtras.locateFileInPackage === "function") {
				return options.packageExtras.locateFileInPackage(descriptor, memoizeId, function(err, path, memoizeId, packageExtras) {
					if (err) return callback(err);
					if (path === true && !memoizeId) {
						// We have a system module.
						return callback(null, true);
					}
					if (!path || !memoizeId) return finalize(callback);

					return options.API.FS.exists(options._realpath(path), function(exists) {
						if (exists) {
							return callback(null, path, memoizeId, packageExtras);
						}
						return callback(null, PATH.join(path.replace(/\.js$/, ""), "index.js"), PATH.join(memoizeId, "index"));
					});
					return callback(null, path, memoizeId, packageExtras);
				});
			}
			return finalize(callback);
		}

		function addStatic(path, memoizeId, options, callback) {
			return realpath(path, function(err, path) {
				if (err) return callback(err);
				options.id = memoizeId;
				return bundleStaticallyLinkedFiles(path, options, callback);
			});
		}

		function addDynamic(path, memoizeId, opts, callback) {
			if (!opts.existingModules) {
				opts.existingModules = {};
			}
			for (var id in bundleDescriptor.modules) {
				opts.existingModules[id] = {};
			}
			if (/^\//.test(memoizeId)) {
				opts.distPath = PATH.join(opts.distPath, opts.parentMemoizeId.replace(/^\/|\.js$/g, ""));
				delete opts.rootModule;
				return exports.bundleFile(path, opts, function(err, descriptor) {
					if (err) return callback(err);
					if (options.on && options.on.newBundle) {
						options.on.newBundle(path, descriptor);
					}
					return callback(null, descriptor);
				});
			} else {
				return options.packageDescriptorForModule(path, function(err, packageDescriptor) {
					if (err) return callback(err);
					opts.distPath = PATH.join(opts.distPath, PATH.basename(bundleFilePath.replace(/\.js$/, "")), PATH.dirname(memoizeId.replace(/^\//, "")));
					opts.distFilename = PATH.basename(path);
					opts.rootModule = exports.normalizeExtension(memoizeId.replace(packageDescriptor.id, "."));
					opts.rootPackage = packageDescriptor.id;
					return exports.bundlePackage(packageDescriptor.dirpath, opts, function(err, descriptor) {									
						if (err) return callback(err);
						if (options.on && options.on.newBundle) {
							options.on.newBundle(path, descriptor);
						}
						return callback(null, descriptor);
					});
				});
			}
		}

		function bundleStaticallyLinkedFiles(filePath, options, callback) {

			if (bundleDescriptor.modules[exports.normalizeExtension(options.id)]) return callback(null);

			return addFile(filePath, options, function(err, descriptor) {
				if (err) return callback(err);

				return options.packageDescriptorForModule(filePath, function(err, packageDescriptor) {
					if (err) return callback(err);

					var waitfor = WAITFOR.serial(function(err) {
						if (err) return callback(err);
						descriptor.warnings.forEach(function(warning) {
							bundleDescriptor.warnings.push([].concat(warning, "module", descriptor.memoizeId));
						});
						descriptor.errors.forEach(function(error) {
							bundleDescriptor.errors.push([].concat(error, "module", descriptor.memoizeId));
						});
						return callback(null, descriptor);
					});

					function addDependency(type, id, done) {

						function callback(err) {
							if (err) {
								var stack = err.stack;
								if (options.test) {
									stack = stack.replace(/at [\S\s]*/, "");
								}
								descriptor.errors.push([
									"bundle-" + type, err.message, stack
								]);
							}
							return done(null);
						}
						return resolveModuleId(descriptor, id, options, function(err, path, memoizeId, packageExtras) {
							if (err) return callback(err);

							if (
								bundleDescriptor.modules[exports.normalizeExtension(memoizeId)] ||
								bundleDescriptor.expectExistingModules[exports.normalizeExtension(memoizeId)]
							) return callback(null);

							if (options.existingModules && options.existingModules[exports.normalizeExtension(memoizeId)]) {
								bundleDescriptor.expectExistingModules[memoizeId] = options.existingModules[exports.normalizeExtension(memoizeId)];
								return callback(null, descriptor);
							}

							if (path === true && !memoizeId) {
								var bundle = false;
								// See if we should convert module from default (nodejs) to other format.
								// TODO: Do this in a plugin (it.pinf.nodejs)
								if (options.$pinf) {
									var programInfo = options.$pinf.getProgramInfo();
									if (
										programInfo &&
										programInfo.program &&
										programInfo.program.descriptor &&
										programInfo.program.descriptor.config &&
										programInfo.program.descriptor.config["github.com/pinf-it/pinf-it-bundler/0"] &&
										programInfo.program.descriptor.config["github.com/pinf-it/pinf-it-bundler/0"].target
									) {
										if (programInfo.program.descriptor.config["github.com/pinf-it/pinf-it-bundler/0"].target === "browser") {
											// Use `browserify` to convert system module to browser format.
											if (BROWSER_BUILTINS[id]) {
												memoizeId = "/__SYSTEM__/" + id;
												path = BROWSER_BUILTINS[id];
											}
										}
									}
								}
								// We have a system module.
								if (path === true) return callback(null);
							}
							var opts = {};
							for (var key in options) {
								opts[key] = options[key];
							}
							opts.packageExtras = packageExtras || opts.packageExtras || null;
							if (type === "static") {
								return addStatic(path, memoizeId, opts, callback);
							}
							if (options.forceMemoizeFiles && options.forceMemoizeFiles[exports.normalizeExtension(memoizeId)]) {
								return addStatic(path, memoizeId, opts, callback);
							}

							opts.parentMemoizeId = exports.normalizeExtension(options.id);

							return addDynamic(path, memoizeId, opts, callback);
						});
					}

					for (var id in descriptor.dependencies.static) {
						waitfor("static", id, addDependency);
					}
					for (var id in descriptor.dependencies.dynamic) {
						waitfor("dynamic", id, addDependency);
					}

					if (
						packageDescriptor &&
						packageDescriptor.combined["require.async"]
					) {
						var lookupId = null;
						if (packageDescriptor.id === rootPackageDescriptor.id) {
							lookupId = exports.normalizeExtension("." + options.id);
						} else {
							lookupId = exports.normalizeExtension(options.id.replace(packageDescriptor.id, "."));
						}
						var rules = packageDescriptor.combined["require.async"];

						// TODO: Expand on these matching rules to incrorporate '*' wildcard selectors.
						if (rules[lookupId]) {
							waitfor("dynamic", rules[lookupId], addDependency);
						}
					}

					return waitfor();
				});
			});
		}

		function finalizeBundle(callback) {
			function finalize(callback) {
				return bundle.save(function(err) {
					if (err) return callback(err);
					return bundle.close(function(err) {
						if (err) return callback(err);
						return callback(null);
					});
				});
			}
			if (typeof options.finalizeBundle === "function") {
				return options.finalizeBundle(bundleDescriptor, bundle, function(err) {
					if (err) return callback(err);
					return finalize(callback);
				});
			}
			return finalize(callback);
		}

		if (options.debug) console.log("[pinf-it-bundler] bundleFile", bundleFilePath);

		return realpath(bundleFilePath, function(err, bundleFilePath) {
			if (err) return callback(err);

			return init(bundleFilePath, function(err) {
				if (err) return callback(err);

				return openBundle(bundleDescriptor.bundle.path, function(err) {
					if (err) return callback(err);

					var opts = {};
					for (var key in options) {
						opts[key] = options[key];
					}

					opts.id = PATH.normalize(rootPackage + "/" + (options.rootModule || PATH.basename(bundleFilePath)).replace(/\.js/, ""));

					return bundleStaticallyLinkedFiles(bundleFilePath, opts, function(err, moduleDescriptor) {
						if (err) return callback(err);

						var waitfor = WAITFOR.serial(function(err) {
							if (err) return callback(err);

							if (options.existingModules && options.existingModules[rootPackage + "/package.json"]) {
								bundleDescriptor.expectExistingModules[rootPackage + "/package.json"] = options.existingModules[rootPackage + "/package.json"];
							} else {
								if (!bundleDescriptor.modules[rootPackage + "/main"] && !bundleDescriptor.modules[rootPackage + "/package.json"]) {									
									bundleDescriptor.modules[rootPackage + "/package.json"] = {
										requireId: rootPackage + "/package.json",
										memoizeId: rootPackage + "/package.json",
										descriptor: {
											memoized: {
												main: moduleDescriptor.memoizeId
											}
										},
										wrapper: "json"
									};
									bundle.setModule(
										exports.normalizeExtension(rootPackage + "/package.json"), JSON.stringify({
											main: moduleDescriptor.memoizeId
										}, null, 4), {
											filename: moduleDescriptor.descriptor.filepath
										}, {
											file: "",
											mtime: 0,
											wrapper: "json",
											format: "json"
										}
									);
								}
							}

							return finalizeBundle(function(err) {
								if (err) return callback(err);

								return callback(null, bundleDescriptor);
							});
						});

						if (options.forceMemoizeFiles) {
							for (var memoizeId in options.forceMemoizeFiles) {
								waitfor(memoizeId, function(memoizeId, done) {
									addStatic(options.forceMemoizeFiles[memoizeId], memoizeId.replace(/\.js/, ""), options, done);
								});
							}
						}
						waitfor();
					});
				});
			});
		});

	} catch(err) {
		return callback(err);
	}
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/bundler.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/index.js"}
require.memoize("a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy';
// deepcopy Copyright(c) 2013 sasa+1
// https://github.com/sasaplus1/deepcopy
// Released under the MIT License.

module.exports = require('./lib/deepcopy');

return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy/lib/deepcopy.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/lib/deepcopy.js"}
require.memoize("a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/lib/deepcopy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy/lib';
// deepcopy Copyright(c) 2013 sasa+1
// https://github.com/sasaplus1/deepcopy
// Released under the MIT License.

var util = require('__SYSTEM__/util');

function deepcopy(targetObject) {
  var targetObjectType = typeof targetObject,
      stringifiedRegExp, lastSlashIndex,
      cloneObject, keys, i, len, keyValue;

  if (targetObject === null ||
      targetObjectType === 'function' ||
      targetObjectType !== 'object') {
    return targetObject;
  }

  if (util.isDate(targetObject)) {
    return new Date(targetObject);
  }

  if (util.isRegExp(targetObject)) {
    stringifiedRegExp = String(targetObject);
    lastSlashIndex = stringifiedRegExp.lastIndexOf('/');

    return new RegExp(
        stringifiedRegExp.slice(1, lastSlashIndex),
        stringifiedRegExp.slice(lastSlashIndex + 1));
  }



  cloneObject = (util.isArray(targetObject)) ? [] : {};
  keys = Object.keys(targetObject);

  for (i = 0, len = keys.length; i < len; ++i) {
    keyValue = keys[i];
    cloneObject[keyValue] = deepcopy(targetObject[keyValue]);
  }

  return cloneObject;
}

module.exports = deepcopy;

return {
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    deepcopy: (typeof deepcopy !== "undefined") ? deepcopy : null,
    String: (typeof String !== "undefined") ? String : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy/lib/deepcopy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/bundle.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/bundle.js"}
require.memoize("5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/bundle.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib';

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");

// HACK: Can remove require when `require.resolve` is inspected for static requires.
require("pinf-loader-js/loader");
const LOADER_PATH = require.resolve("pinf-loader-js/loader.js");


var openBundles = {};


exports.open = function(filePath, options, callback) {
	try {
		options = options || {};

        options.API = {
            FS: (options.$pinf && options.$pinf.getAPI("FS")) || FS
        };

		if (options.debug) console.log("Open bundle:", filePath);

		var bundle = new Bundle(filePath, options);

		return bundle.open(function(err) {
			if (err) return callback(err);

			return callback(null, bundle);
		});
	} catch(err) {
		return callback(err);
	}
}


function Bundle(path, options) {
    this.path = path;
    this._options = options || {};
    if (!this._options.API) {
        this._options.API = {
            FS: FS
        };
    }
    this.reset();
}

Bundle.prototype.reset = function() {
	if (this.fd) {
		try {
			this._options.API.FS.closeSync(this.fd);
		} catch(err) {}
	}
    this.fd = null;
    this.headers = {};
    this.descriptors = {};
    this.modules = {};
    this.report = {};
    this.bundleLoader = null;
}

Bundle.prototype.saveTo = function(filePath, callback) {
	var self = this;
	var bundle = new Bundle(filePath);
    self._options.API.FS.createFileSync(filePath, "");
	return bundle.open(function(err) {
		if (err) return callback(err);
	    bundle.headers = self.headers;
	    bundle.descriptors = self.descriptors;
	    bundle.modules = self.modules;
	    bundle.report = self.report;
	    bundle.bundleLoader = self.bundleLoader;
	    return bundle.save(function(err) {
	    	if (err) return callback(err);
		    return bundle.close(callback);
	    });
	});
}

Bundle.prototype.open = function(done) {
    var self = this;
    if (self.fd) return callback(new Error("Cannot open. Bundle already open. Call `close()` first."));
    if (openBundles[self.path]) return callback(new Error("Cannot open. Bundle already open by other instance."));
    function callback(err) {
    	if (err) self.reset();
    	return done.apply(null, arguments);
    }
    return self._options.API.FS.exists(self.path, function(exists) {
    	if (!exists) {
            self._options.API.FS.createFileSync(self.path, "");
    	}
        // TODO: Write lock file to ensure synchronized access.
        openBundles[self.path] = true;
	    return self._options.API.FS.open(self.path, "r+", function(err, fd) {
	    	if (err) return callback(err);

	    	self.fd = fd;

			return self._options.API.FS.fstat(self.fd, function(err, stats) {
				if (err) return callback(err);
                if (typeof self._options.API.FS.notifyUsedPath === "function") {
                    self._options.API.FS.notifyUsedPath(self.path, "fstat");
                }

				if (stats.size === 0) {
					return callback(null);
				}

		    	var buffer = new Buffer(stats.size);

		    	return self._options.API.FS.read(self.fd, buffer, 0, stats.size, 0, function(err, bytesRead, buffer) {
		    		if (err) return callback(err);
                    if (typeof self._options.API.FS.notifyUsedPath === "function") {
                        self._options.API.FS.notifyUsedPath(self.path, "read");
                    }

		    		if (bytesRead !== buffer.length || bytesRead !== stats.size) {
		    			return callback(new Error("Did not read entire file"));
		    		}

		    		return self.parseCode(buffer.toString("utf8"), callback);
		    	});
			});
		});
	});
}

Bundle.prototype.close = function(callback) {
	var self = this;
    if (!self.fd) return callback(new Error("Cannot close. Bundle not open. Call `open()` first."));
    return self._options.API.FS.close(self.fd, function(err) {
    	if (err) return callback(err);
        self.fd = null;
        delete openBundles[self.path];
        return callback(null);
    });
}

Bundle.prototype.parseCode = function(code, callback) {
    var self = this;
    try {
        var codeParts = code.split(/(?:^|\n)\s*\/\/\s*@(pinf-bundle-[^:]*)\s*:/);
        var i;
        var sectionParts;
        var bundleLoaderTop = false;
        for (i = 1 ; i < (codeParts.length-1) ; i += 2) {
            sectionParts = codeParts[i+1].match(/^\s*([^\n]*)\s*(\n([\S\s]*))?$/);

            if (codeParts[i] === "pinf-bundle-ignore") {
                // Ignore.
            } else
            if (codeParts[i] === "pinf-bundle-header") {
                self.setHeader(JSON.parse(sectionParts[1]), sectionParts[3]);
            } else
            if (codeParts[i] === "pinf-bundle-loader-top") {
                bundleLoaderTop = [JSON.parse(sectionParts[1]), sectionParts[3]];
            } else
            if (codeParts[i] === "pinf-bundle-loader-bottom") {
                if (!bundleLoaderTop) throw new Error("We should have already found '// @pinf-bundle-loader-top:'");
                self.setLoader(bundleLoaderTop[0], [bundleLoaderTop[1], codeParts[i+1].replace(/^\s*\n/, "")]);
            } else
            if (codeParts[i] === "pinf-bundle-module") {
                var parts = sectionParts[3].match(/^.*\n([\s\S]+)\n(?:,\s*(.*))?\);$/);
                self.setModule(null, parts[1], JSON.parse(parts[2] || "{}"), JSON.parse(sectionParts[1]));
            } else
            if (codeParts[i] === "pinf-bundle-descriptor") {
                var parts = sectionParts[3].match(/^.*\n([\s\S]+)\n(?:,\s*(.*))?\);$/);
                self.setDescriptor(null, parts[1], JSON.parse(parts[2] || "{}"), JSON.parse(sectionParts[1]));
            } else
            if (codeParts[i] === "pinf-bundle-report") {
                self.setReport(JSON.parse(sectionParts[1]));
            } else {
                throw new Error("Found unknown section type '" + codeParts[i] + "'!");
            }
        }
        return callback(null);
    } catch(err) {
    	return callback(err);
    }
}

Bundle.prototype.setLoader = function(info, code) {
    this.bundleLoader = [info || {}, code || null];
}

Bundle.prototype.setHeader = function(info, code) {
    this.headers[JSON.stringify(info)] = code;
}

Bundle.prototype.setDescriptor = function(id, code, meta, info) {
    id = id || info.id;
    info.id = id;
    this.descriptors[id] = [code, meta || {}, info];
}

Bundle.prototype.setModule = function(id, code, meta, info) {
    id = id || info.id;
    info.id = id;
    this.modules[id] = [code, meta || {}, info];
}

Bundle.prototype.setReport = function(obj) {
    this.report = obj;
}

Bundle.prototype.save = function(callback) {
    var self = this;

    if (!this.fd) return callback(new Error("Cannot save. Bundle is not open. Call `open()` first."));

    function generateCode(callback) {

	    var code = [];

        function writeLoader(callback) {

        	if (!self.bundleLoader) {

        		writePayload();

        		return callback(null);
        	}

            code.push('// @pinf-bundle-loader-top: ' + JSON.stringify(self.bundleLoader[0]));

            if (self.bundleLoader[1]) {
                code.push(self.bundleLoader[1][0]);
            } else {
            	code = code.concat([
                    'var require, sourcemint;',
                    '(function() {',
                    '    var rootBundleLoader = function(uri, loadedCallback) {'
                ]);
            }

            writePayload();

            code.push('// @pinf-bundle-loader-bottom: ');

            if (self.bundleLoader[1]) {
                code.push(self.bundleLoader[1][1]);
                return callback(null);
            }

            code = code.concat([
                '        if (typeof loadedCallback === "function") loadedCallback();',
                '    }',
                '    function initLoader(exports) {'
            ]);

            return self._options.API.FS.readFile(LOADER_PATH, "utf8", function (err, loaderCode) {
            	if (err) return callback(err);

            	code.push(loaderCode);

                if (typeof self.bundleLoader[0].platformLoaderSource === "function") {

                	return self.bundleLoader[0].platformLoaderSource(function(err, platformCode) {
                		if (err) return callback(err);

                        code = code.concat([
                            '    };',
                            '    if (typeof sourcemint === "undefined") {',
                            '        sourcemint = {};',
                            '        var LOADER_INJECTED = {};',
                            '        initLoader(LOADER_INJECTED);',
                            '        (function(require, exports) {',
                            '            ' + platformCode,
                            '        })(require, sourcemint);',
                            '        var platformRequire = require;',
                            '        var isMain = ((platformRequire && platformRequire.main === module)?true:false);',
                            '        require = LOADER_INJECTED.require;',
                            '        sourcemint.bundle = require.bundle;',
                            '        sourcemint.sandbox(((typeof __dirname !== "undefined")?__dirname:".") + "/' + ((self.bundleLoader[0].bundleUrlPrefix)?"/{host}"+self.bundleLoader[0].bundleUrlPrefix:"") + PATH.basename(self.path) + '", function(sandbox) {',
                            '            if (typeof exports === "object") {',
                            '                var mainExports = sandbox.boot();',
                            '                if (typeof mainExports === "function") {',
                            '                    module.exports = mainExports;',
                            '                } else {',
                            '                    for (var key in mainExports) {',
                            '                        exports[key] = mainExports[key];',
                            '                    }',
                            '                }',
                            '            } else {',
                            '                sandbox.main();',
                            '            }',
                            '        }, {',
                            '            rootBundleLoader: rootBundleLoader,',
                            '            isMain: isMain',
                            '        });',
                            '    } else {',
                            '        rootBundleLoader();',
                            '    }',
                            '})();',
                        ]);

						return callback(null);
                	});

                } else {
                    code = code.concat([
                        '    };',
                        '    if (typeof sourcemint === "undefined") {',
                        '        var exports = {};',
                        '        initLoader(exports);',
                        '        sourcemint = exports.require;',
                        '        if (!require) require = sourcemint;',
                        '        sourcemint.sandbox("' + ((self.bundleLoader[0].bundleUrlPrefix)?"/{host}"+self.bundleLoader[0].bundleUrlPrefix:"") + PATH.basename(self.path) + '", function(sandbox) {',
                        '            sandbox.main();',
                        '        }, {',
                        '            rootBundleLoader: rootBundleLoader',
                        '        });',
                        '    } else {',
                        '        rootBundleLoader();',
                        '    }',
                        '})();'                  
                    ]);

					return callback(null);
                }
            });
        }

        function writePayload() {
            code.push('// @pinf-bundle-ignore: \nPINF.bundle("", function(require) {');

            for (var key in self.headers) {
                code.push('// @pinf-bundle-header: ' + key);
                code.push(self.headers[key]);
            }

            for (var key in self.modules) {
                code.push('// @pinf-bundle-module: ' + JSON.stringify(self.modules[key][2]));
                code.push('require.memoize("' + key + '", ');
                code.push(self.modules[key][0]);
                code.push(', ' + JSON.stringify(self.modules[key][1]) + ');');
            }

            for (var key in self.descriptors) {
                code.push('// @pinf-bundle-descriptor: ' + JSON.stringify(self.descriptors[key][2]));
                code.push('require.memoize("' + key + '", ');
                code.push(self.descriptors[key][0]);
                code.push(', ' + JSON.stringify(self.descriptors[key][1]) + ');');
            }

            code.push('// @pinf-bundle-ignore: \n});');
        }
        
        function writeFooter() {
            code.push('// @pinf-bundle-report: ' + JSON.stringify(self.report));
        }

        return writeLoader(function(err) {
        	if (err) return callback(err);

        	writeFooter();

        	return callback(null, code);
        });
    }

	return generateCode(function(err, code) {
		if (err) return callback(err);

		code = code.join("\n");

		var buffer = new Buffer(code, "utf8");

	    return self._options.API.FS.ftruncate(self.fd, 0, function(err) {
	    	if (err) return callback(err);
            if (typeof self._options.API.FS.notifyUsedPath === "function") {
                self._options.API.FS.notifyUsedPath(self.path, "ftruncate");
            }

            return self._options.API.FS.write(self.fd, buffer, 0, buffer.length, 0, function(err, written, buffer) {
            	if (err) return callback(err);
                if (typeof self._options.API.FS.notifyUsedPath === "function") {
                    self._options.API.FS.notifyUsedPath(self.path, "write");
                }

            	if (written !== buffer.length) return callback(new Error("Did not write entire buffer to file."));
            	return callback(null);
            });
	    });
	});
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/bundle.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/wrapper.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/wrapper.js"}
require.memoize("5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/wrapper.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib';

const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");
const REQUIREJS = require("requirejs");


REQUIREJS.config({
    nodeRequire: require,
	baseUrl: PATH.join(__dirname, "r.js/build/jslib")
});


exports.wrapModule = function(descriptor, options, callback) {

	if (descriptor.errors.length > 0) {
		descriptor.errors.forEach(function(error) {
			console.error(error, new Error().stack);
		});
		return callback(new Error("We had errors in package descriptor '" + descriptor.descriptor.filepath + "'!"));
	}

	var packageDescriptorForModule = options.packageDescriptorForModule || function(path, callback) {
		return callback(null, null);
	}

	return packageDescriptorForModule(descriptor.descriptor.filepath, function(err, packageDescriptor) {
		if (err) return callback(err);

		try {

			var dirnameForModule = descriptor.descriptor.filepath;
			if (options.rootPath) dirnameForModule = PATH.join(options.rootPath, dirnameForModule);
			dirnameForModule = PATH.dirname(dirnameForModule);

			function wrap(callback) {

				if (descriptor.descriptor.syntax === "javascript") {

					// `define(function() {`
					// `define("<id>", function() {`
					// `define("<id>", ["dep"], function() {`
					// `define(["dep"], function() {`
					if (descriptor.descriptor.format === "amd") {

						// We can write a clean `define()` wrapper.
						descriptor.wrapper.type = "amd";

						// These dependencies don't need to be followed as they are handled by the AMD header.
						delete descriptor.dependencies.static.require;
						delete descriptor.dependencies.static.exports;
						delete descriptor.dependencies.static.module;

						// Cleanup `define` call using r.js
						return wrapAMD(descriptor, function(err) {
							if (err) return callback(err);

							// If the `define` wrapped call needs an AMD-style `require` we provide it
							// if it is not declared.
							if (descriptor.descriptor.globals["require"] && !descriptor.descriptor.dependencies.static["require"]) {
								descriptor.wrapper.type = "amd-ish";
								descriptor.wrapper.code = [
									"wrapAMD(function(require, define) {",
									descriptor.wrapper.code,
									"})"
								].join("\n");
							}
							return callback(null);
						});

					} else
					// `<code> define(`
					// `define(<id>, function() {`
					// `define("<id>", [<dep>], function() {`
					// `define(<id>, [<dep>], function() {`
					// `define([<dep>], function() {`
					if (descriptor.descriptor.format === "amd-ish") {

						// These dependencies don't need to be followed as they are handled by the AMD header.
						delete descriptor.dependencies.static.require;
						delete descriptor.dependencies.static.exports;
						delete descriptor.dependencies.static.module;

						// The `define()` wrapper is part of `descriptor.code` as it could not be stripped safely.
						// We write a `defineish()` wrapper that declares a `define` function
						// used to intercept id and dependency declarations.

						descriptor.wrapper.type = "amd-ish";
						descriptor.wrapper.top = "wrapAMD(function(require, define) {";
						descriptor.wrapper.bottom = "})";

					} else
					if (descriptor.descriptor.format === "commonjs") {
						descriptor.wrapper.type = "commonjs";
						descriptor.wrapper.top = "function(require, exports, module) {" +
							"var __dirname = " + ((options.test && options.rootPath)?"TEST_ROOT_PATH + '/' + ":"") + "'" + options._relpath(dirnameForModule) + "';";
						descriptor.wrapper.bottom = "}";

					} else
					if (descriptor.descriptor.format === "leaky") {

						// We wrap code to export all leaked globals.
						var exports = [];
						for (var name in descriptor.descriptor.globals) {
							// If module uses `require.main` we don't want to export the `main` function.
							if (name === "main" && descriptor.descriptor.uses["require.main"]) {
								// Don't export function.
							} else {
								// Guard against a variable being undefined. This happens if variable is used
								// but never declared and is an error in the code! We ignore this here
								// as some code still runs and if this happens in a dependency we don't want things to break.
								exports.push('    ' + name + ': (typeof ' + name + ' !== "undefined") ? ' + name + ' : null');
							}
						}
						descriptor.wrapper.type = "commonjs/leaky";
						descriptor.wrapper.top = "function(require, exports, module) {" +
							"var __dirname = " + ((options.test && options.rootPath)?"TEST_ROOT_PATH + '/' + ":"") + "'" + options._relpath(dirnameForModule) + "';";
						descriptor.wrapper.bottom = "return {\n" + exports.join(",\n") + "\n};\n}";

					} else
					if (descriptor.descriptor.format === "encapsulated") {

						// We wrap module even though we cannot penetrate it.
						descriptor.wrapper.type = "commonjs/encapsulated";
						descriptor.wrapper.top = "function(require, exports, module) {";
						descriptor.wrapper.bottom = "}";

					} else {
						return callback(new Error("Unrecognized format '" + descriptor.descriptor.format + "' for syntax '" + descriptor.descriptor.syntax + "'"));
					}

				} else
				if (descriptor.descriptor.syntax === "json") {

					descriptor.wrapper.type = "json";

				} else
				if (descriptor.descriptor.syntax === null) {

					if (descriptor.descriptor.format === "utf8") {

						descriptor.wrapper.type = "url-encoded";
						descriptor.wrapper.code = "'" + encodeURIComponent(descriptor.descriptor.code).replace(/'/g, "\\'") + "'";

					} else {
						return callback(new Error("Unrecognized format '" + descriptor.descriptor.format + "' for syntax '" + descriptor.descriptor.syntax + "'"));
					}

				} else {
					return callback(new Error("Unrecognized syntax '" + descriptor.descriptor.syntax + "'"));
				}

				return callback(null);
			}

			function replace(callback) {

				function replaceRequireIds(callback) {
					if (!packageDescriptor) return callback(null);

					if (
	/*
	// TODO: Comment this back in once package descriptor inherits default engine requirements from parent package.
						packageDescriptor.combined.requirements &&
						packageDescriptor.combined.requirements.engines &&
						packageDescriptor.combined.requirements.engines.node &&
	*/
						descriptor.descriptor.dependencies &&
						descriptor.descriptor.dependencies.static
					) {

						var code = (descriptor.wrapper.code || [
										descriptor.wrapper.top,
										descriptor.descriptor.code,
										descriptor.wrapper.bottom
									].join("\n"));

						for (var id in descriptor.descriptor.dependencies.static) {
							// NOTE: We assume we are running on nodejs.
							try {
								if (id !== "require" && require.resolve(id) === id) {
									// We have a system module.
									code = code.replace(new RegExp("(\\Wrequire\\(['\"])" + id + "(['\"]\\))", "g"), "$1" + "__SYSTEM__/" + id + "$2");
								}
							} catch(err) {}
						}

						descriptor.wrapper.code = code;
					}

					return callback(null);
				}

				function replacePlatformGlobals(callback) {

					var code = (descriptor.wrapper.code || [
									descriptor.wrapper.top,
									descriptor.descriptor.code,
									descriptor.wrapper.bottom
								].join("\n"));

//					var path = descriptor.descriptor.filepath;
//					if (options.rootPath) path = PATH.join(options.rootPath, path);
//					code = code.replace(/\__dirname/ig, '"' + PATH.dirname(path) + '"');

					descriptor.wrapper.code = code;

					return callback(null);
				}

				return replaceRequireIds(function(err) {
					if (err) return callback(err);
					return replacePlatformGlobals(callback);
				});
			}

			return wrap(function(err) {
				if (err) return callback(err);
				return replace(callback);
			});

		} catch(err) {
			return callback(err);
		}
	});
}

exports.headerForWrapper = function(type) {
	if (type === "amd") {
		return [
		    'function define(id, dependencies, moduleInitializer) {',
		    '    if (typeof dependencies === "undefined" && typeof moduleInitializer === "undefined") {',
		    '        if (typeof id === "function") {',
		    '            moduleInitializer = id;',
		    '        } else {',
		    '            var exports = id;',
		    '            moduleInitializer = function() { return exports; }',
		    '        }',
		    '        dependencies = ["require", "exports", "module"];',
		    '        id = null;',
		    '    } else',
		    '    if (Array.isArray(id) && typeof dependencies === "function" && typeof moduleInitializer === "undefined") {',
		    '        moduleInitializer = dependencies;',
		    '        dependencies = id;',
		    '        id = null;',
		    '    } else',
		    '    if (typeof id === "string" && typeof dependencies === "function" && typeof moduleInitializer === "undefined") {',
		    '        moduleInitializer = dependencies;',
		    '        dependencies = ["require", "exports", "module"];',
		    '    }',
		    '    return function(realRequire, exports, module) {',
	        '        function require(id) {',
	        '            if (Array.isArray(id)) {',
	        '                var apis = [];',
	        '                var callback = arguments[1];',
	        '                id.forEach(function(moduleId, index) {',
	        '                    realRequire.async(moduleId, function(api) {',
	        '                        apis[index] = api',
	        '                        if (apis.length === id.length) {',
	        '                            if (callback) callback.apply(null, apis);',
	        '                        }',
	        '                    }, function(err) {',
	        '                        throw err;',
	        '                    });',
	        '                });',
	        '            } else {',
	        '                return realRequire(id.replace(/^[^!]*!/, ""));',
	        '            }',
	        '        }',
	        '        require.toUrl = function(id) {',
	        '            return realRequire.sandbox.id.replace(/\\/[^\\/]*$/, "") + realRequire.id(id);',
	        '        }',
	        '        if (typeof amdRequireImplementation !== "undefined") {',
	        '            amdRequireImplementation = require;',
	        '        }',
	        // @see http://requirejs.org/docs/api.html#cjsmodule
		    '        if (typeof moduleInitializer === "function") {',
		    '            return moduleInitializer.apply(moduleInitializer, dependencies.map(function(name) {',
		    '                if (name === "require") return require;',
		    '                if (name === "exports") return exports;',
		    '                if (name === "module") return module;',
		    '                return require(name);',
		    '            }));',
		    '        } else',
		    // @see http://requirejs.org/docs/api.html#defsimple
	        '        if (typeof dependencies === "object") {',
	        '            return dependencies;',
	        '        }',
		    '    }',
		    '}',
		    'define.amd = { jQuery: true };'
		].join("\n");
	} else
	if (type === "amd-ish") {
		return [
			'var amdRequireImplementation = null;',
		    'function wrapAMD(callback) {',
		    exports.headerForWrapper("amd").split("\n").map(function(line) {
		    	return "    " + line;
		    }).join("\n"),
		    '    var exports = null;',
		    '    function wrappedDefine() {',
		    '        exports = define.apply(null, arguments);',
		    '    }',
		    '    function amdRequire() {',
		    '        return amdRequireImplementation.apply(null, arguments);',
		    '    }',
		    '    wrappedDefine.amd = { jQuery: true };',
		    '    callback(amdRequire, wrappedDefine);',
		    '    return exports;',
		    '}'
		].join("\n");
	}
	return null;
}


function wrapAMD(descriptor, callback) {
	return REQUIREJS(["transform"], function(TRANSFORM) {
        try {
			var code = TRANSFORM.toTransport(false, false, descriptor.descriptor.filepath, descriptor.descriptor.code, false, false);
    		descriptor.wrapper.code = code.replace(/;[\s\n]*$/, "");
			return callback(null);
        } catch (err) {
        	return callback(err);
        }
	});
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/lib/wrapper.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/loader.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/loader.js"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/loader.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib';

const ASSERT = require("__SYSTEM__/assert");
const PATH = require("__SYSTEM__/path");
const FS = require("fs-extra");
const HTTP = require("__SYSTEM__/http");
const HTTPS = require("__SYSTEM__/https");
const VM = require("__SYSTEM__/vm");
const REQUEST = require("request");
const LOADER = require("pinf-loader-js/loader");


exports.sandbox = function(sandboxIdentifier, sandboxOptions, loadedCallback, errorCallback) {

	if (!sandboxIdentifier) {
		if (errorCallback) return errorCallback(new Error("'sandboxIdentifier' not specified"));
		throw new Error("'sandboxIdentifier' not specified");
	}

	if (typeof sandboxOptions === "function" && typeof loadedCallback === "function" && typeof errorCallback === "undefined") {
		errorCallback = loadedCallback;
		loadedCallback = sandboxOptions;
		sandboxOptions = {};
	} else
	if (typeof sandboxOptions === "function" && typeof loadedCallback === "undefined") {
		loadedCallback = sandboxOptions;
		sandboxOptions = {};
	} else {
		sandboxOptions = sandboxOptions || {};
	}

	var options = {};

	for (var key in sandboxOptions) {
		options[key] = sandboxOptions[key];
	}

	delete options.globals;

	sandboxOptions._realpath = function(path) {
		if (!sandboxOptions.rootPath) return path;
		if (/^\/|:\/\//.test(path)) return path;
		return PATH.join(sandboxOptions.rootPath, path);
	}

	// Set our own loader for the sandbox.
	options.load = function(uri, loadedCallback) {		
		function loadCode(uri, callback) {
            if (/:\/\//.test(uri)) {
                return REQUEST(uri, function(err, result) {
                	if (err) return callback(err);
                	return callback(null, result.body);
                });
            } else {
                return FS.readFile(sandboxOptions._realpath(uri), "utf8", callback);
            }
        }
        return loadCode(uri, function(err, code) {
			if (err) {
				console.error("Error reading file: " + sandboxOptions._realpath(uri));
				return loadedCallback(err);
			}
			try {
		    	evalBundle(sandboxOptions._realpath(uri), code);
		        return loadedCallback(null);
		    } catch(err) {
		        return loadedCallback(err);
		    }
        });
	}

	function evalBundle(uri, code) {
    	// NOTE: If there are sytnax errors in code this will print
    	//		 error to stdout (if fourth argument set to `true`).
    	//		 There is no way to capture errors from here.
    	// @see https://github.com/joyent/node/issues/1307#issuecomment-1551157
    	// TODO: Find a better solution to handle errors here.
    	// TODO: Capture errors by watching this processe's stdout file log from
    	//		 another process.
    	var globals = {
		    // TODO: Inject and fix environment based on options.
        	PINF: LOADER,
        	// TODO: Wrap to `console` object provided by `sandboxOptions` and inject module info.
        	console: console,
        	// NodeJS globals.
        	// @see http://nodejs.org/docs/latest/api/globals.html
        	global: global,
        	process: process,
        	Buffer: Buffer,
        	setTimeout: setTimeout,
        	clearTimeout: clearTimeout,
        	setInterval: setInterval,
        	clearInterval: clearInterval,
        	setImmediate: setImmediate,
        	// Browser
        	navigator: {}
    	};
    	if (sandboxOptions.globals) {
    		for (var name in sandboxOptions.globals) {
    			globals[name] = sandboxOptions.globals[name];
    		}
    	}
    	if (sandboxOptions.test && sandboxOptions.rootPath) {
    		globals.TEST_ROOT_PATH = sandboxOptions.rootPath;
    	}
        VM.runInNewContext(code, globals, uri, true);
	}

	function loadResolvedDynamicSync(uri, bundleIdentifier, options) {
		if (sandboxOptions.debug) console.log("[loader-for-nodejs] loadResolveDynamicSync", "uri", uri, "bundleIdentifier", bundleIdentifier);

		// Load the bundle SYNCHRONOUSLY as new modules must be available before we return.
		var code = null;
		try {
			code = FS.readFileSync(sandboxOptions._realpath(uri), "utf8");
		} catch(err) {
			console.error("Error reading file: " + sandboxOptions._realpath(uri));
			throw err;
		}
		evalBundle(uri, code);

		// Activate the new modules from the bundle.
		return options.finalizeLoad(bundleIdentifier);
	}

	function getBundleBasePath(moduleObj) {

		ASSERT.equal(typeof moduleObj.bundle, "string");

		return moduleObj.bundle.replace(/\.js$/, "");
	}

	var lastModuleRequireContext = null;

	options.onInitModule = function(moduleInterface, moduleObj, pkg, sandbox, options) {
		if (typeof sandboxOptions.onInitModule === "function") {
			sandboxOptions.onInitModule(moduleInterface, moduleObj);
		}

		moduleInterface.filename = sandboxOptions._realpath(moduleInterface.filename);

		var origRequire = moduleObj.require;

		moduleObj.require = function(identifier) {

			lastModuleRequireContext = {
				moduleObj: moduleObj
			};

			if (/^\./.test(identifier)) {

				var moduleIdentifier = PATH.normalize(options.resolveIdentifier(identifier)[1]).replace(/^[\/\.]$/, "");

	            if (moduleIdentifier) {
	            	if (!/^\//.test(moduleIdentifier)) {
		                moduleIdentifier = "/" + options.libPath + moduleIdentifier;
		            }
					var canonicalId = pkg.id + moduleIdentifier;
	            } else {
	            	moduleIdentifier = pkg.main;
					var canonicalId = moduleIdentifier;
	            }

				if (options.initializedModules[canonicalId] || options.moduleInitializers[canonicalId]) {
					return origRequire(identifier);
				}

				if (options.initializedModules[canonicalId.replace(/\.js$/, "/index.js")] || options.moduleInitializers[canonicalId.replace(/\.js$/, "/index.js")]) {
					return origRequire(identifier + "/index");
				}

				// We encountered a dynamic sync require.

				if (sandboxOptions.debug) console.log("[loader-for-nodejs][moduleObj.require] relative", "identifier", identifier, "pkg.id", pkg.id, "moduleIdentifier", moduleIdentifier, "canonicalId", canonicalId);

				var bundleBasePath = getBundleBasePath(moduleObj);

				var uri = null;

				if (typeof sandboxOptions.resolveDynamicSync === "function") {
					// We have a runtime bundler.
					uri = sandboxOptions.resolveDynamicSync(moduleObj, pkg, sandbox, canonicalId, options);
				} else {
//					uri = PATH.join(bundleBasePath, canonicalId.replace(/^\//, "").replace(/\//g, "+"));
					uri = PATH.join(bundleBasePath, canonicalId.replace(/^\//, ""));
				}

//				loadResolvedDynamicSync(uri, PATH.join(bundleBasePath, canonicalId.replace(/^\//, "").replace(/\//g, "+")), options);
				loadResolvedDynamicSync(uri, PATH.join(bundleBasePath, canonicalId.replace(/^\//, "")), options);

				// Now let the loader continue.
				return origRequire(identifier);

			} else {

				var splitIdentifier = identifier.split("/");

				if (typeof pkg.mappings[splitIdentifier[0]] !== "undefined") return origRequire(identifier);

				try {
					var canonicalId = options.resolveIdentifier(identifier)[1];

					if (options.initializedModules[canonicalId] || options.moduleInitializers[canonicalId]) {
						return origRequire(identifier);
					}
				} catch(err) {
					// We get here when running `pinf-it-bundler` tests.
				}

				// Check if we are delaing with a native nodejs module.
				// TODO: Use a better flag than '__' to indicate that module should be loaded here! Use proper versioned uri.
				if (splitIdentifier[0] === "__SYSTEM__") {
					// Check if the system module is memoized first. If it is it takes precedence.
					var canonicalId = identifier + ".js";
					if (options.initializedModules[canonicalId] || options.moduleInitializers[canonicalId]) {
						return origRequire(identifier);
					}
					return require(splitIdentifier.slice(1).join("/"));
				}
				// HACK: We catch any module IDs that were not re-written in the hope that we catch any system modules.
				// This happens when wrapping r.js for example which tests for nodejs and requires system modules.
				// These system module requires should be rewritten by now.
				// TODO: Set in config file how to resolve these system modules.
				try {
					if (require.resolve(identifier) === identifier) {
						return require(identifier);
					}
				} catch(err) {}		

				// We encountered a dynamic sync require.

				if (sandboxOptions.debug) console.log("[loader-for-nodejs][moduleObj.require] absolute", "identifier", identifier, "pkg.id", pkg.id);

				if (typeof sandboxOptions.resolveDynamicSync === "function") {
					// We have a runtime bundler.

					var uri = sandboxOptions.resolveDynamicSync(moduleObj, pkg, sandbox, identifier, options);

					loadResolvedDynamicSync(uri, PATH.join(moduleObj.bundle.replace(/\.js$/, ""), identifier), options);

					// Now let the loader continue.
					return origRequire(identifier);
				}
			}

			// HACK: We catch any module IDs that were not re-written in the hope that we catch any system modules.
			// TODO: Set in config file how to resolve these system modules.
			try {
				if (require.resolve(identifier) === identifier) {
					return require(identifier);
				}
			} catch(err) {}

			throw new Error("Could not find module '" + identifier + "'");

/*
			// We assume we have a 'dynamic sync require' (`require(<id>)`) vs a 'static sync require' (`require("<id>")`) as module
			// should already be in bundle in the latter case. If we do have a 'static sync require'
			// and module is not in bundle, the bundler should use `async require` (`require.async(<id>, callback)`).
			throw new Error("Could not resolve dynamic sync require for '" + identifier + "'");
*/
		}

		for (var property in origRequire) {
			moduleObj.require[property] = origRequire[property];
		}

		// @see http://nodejs.org/docs/latest/api/globals.html
		moduleObj.require.resolve = function() {
			return origRequire.id.apply(null, arguments);
		}

		moduleObj.require.async = function(id, successCallback, errorCallback) {
			if (sandboxOptions.ensureAsync) {
				return sandboxOptions.ensureAsync(moduleObj, pkg, sandbox, id, options, function(err) {
					if (err) return errorCallback(err);
					return origRequire.async(id, successCallback, errorCallback);
				});
			}
			return origRequire.async(id, successCallback, errorCallback);
		}
	};

	options.onInitPackage = function(pkg, sandbox, options) {
		var origRequire = pkg.require;
		
		pkg.require = function(moduleIdentifier) {
			var origModuleIdentifier = PATH.normalize(moduleIdentifier).replace(/^\.$/, "").replace(/^\/$/, "");
			var canonicalId = null;
			if (origModuleIdentifier) {
				moduleIdentifier = origModuleIdentifier;
            	if (!/^\//.test(moduleIdentifier)) {
	                moduleIdentifier = "/" + ((moduleIdentifier.substring(0, pkg.libPath.length)===pkg.libPath)?"":pkg.libPath) + moduleIdentifier;
	            }
				canonicalId = pkg.id + moduleIdentifier;
			} else
			if (pkg.descriptor && pkg.descriptor.main) {
				canonicalId = moduleIdentifier = pkg.descriptor.main;
			} else {
				moduleIdentifier = "";
				canonicalId = pkg.id;
			}

			if (options.initializedModules[canonicalId] || options.moduleInitializers[canonicalId]) {
				return origRequire(origModuleIdentifier);
			}

			// If `canonicalId` is just an alias we assume that the main module is memoized
			// if the package descriptor for the alias is memoized.

			if (!/\//.test(canonicalId)) {
				if (options.initializedModules[canonicalId + "/package.json"] || options.moduleInitializers[canonicalId + "/package.json"]) {
					return origRequire(origModuleIdentifier);
				}
			}
/*
console.log("pkg.id", pkg.id);
console.log("canonicalId", canonicalId);

			if (pkg.id === "__SYSTEM__") {
				return require(canonicalId.replace(/^__SYSTEM__\/|\.js$/g, ""));
			}
*/
			// We encountered a dynamic sync require.

			if (sandboxOptions.debug) console.log("[loader-for-nodejs][pkg.require]", "moduleIdentifier", moduleIdentifier, "pkg.id", pkg.id, "canonicalId", canonicalId);

			var bundleBasePath = getBundleBasePath(lastModuleRequireContext.moduleObj);

			var uri = null;

			if (typeof sandboxOptions.resolveDynamicSync === "function") {
				// We have a runtime bundler.

				var opts = {};
				for (var name in options) {
					opts[name] = options[name];
				}
				opts.lastModuleRequireContext = lastModuleRequireContext;

				uri = sandboxOptions.resolveDynamicSync(null, pkg, sandbox, canonicalId, opts);
			} else {

				// We assume that `canonicalId` is a package ID (not an alias) as the package mapping should
				// already be loaded if requiring a dependency by alias using pure bundles (without runtime bundler).

				var canonicalIdParts = canonicalId.split("/");
				var packageId = canonicalIdParts.shift();
				var moduleId = canonicalIdParts.join("/");
//				uri = PATH.join(bundleBasePath, options.normalizeIdentifier((packageId + ((moduleId) ? "/" + moduleId : "")).replace(/\//g, "+")));
				uri = PATH.join(bundleBasePath, options.normalizeIdentifier(packageId + ((moduleId) ? "/" + moduleId : "")));
			}

//			loadResolvedDynamicSync(uri, PATH.join(bundleBasePath, canonicalId.replace(/\//g, "+")), options);
			loadResolvedDynamicSync(uri, PATH.join(bundleBasePath, canonicalId), options);

			// Now let the loader continue.
			return origRequire(origModuleIdentifier);
/*
			// We assume we have a 'dynamic sync require' (`require(<id>)`) vs a 'static sync require' (`require("<id>")`) as module
			// should already be in bundle in the latter case. If we do have a 'static sync require'
			// and module is not in bundle, the bundler should use `async require` (`require.async(<id>, callback)`).
			throw new Error("Could not resolve dynamic sync require for '" + origModuleIdentifier + "'");
*/
		};

		for (var property in origRequire) {
			pkg.require[property] = origRequire[property];
		}
	}

	return LOADER.sandbox(sandboxIdentifier, options, loadedCallback, errorCallback);
}

exports.getReport = LOADER.getReport;

exports.reset = LOADER.reset;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/loader.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"e8f0a2e912c12fb986839ec2212f3c6e4aa79037-request/index.js"}
require.memoize("e8f0a2e912c12fb986839ec2212f3c6e4aa79037-request/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request';
// Copyright 2010-2012 Mikeal Rogers
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

var http = require('__SYSTEM__/http')
  , https = false
  , tls = false
  , url = require('__SYSTEM__/url')
  , util = require('__SYSTEM__/util')
  , stream = require('__SYSTEM__/stream')
  , qs = require('qs')
  , querystring = require('__SYSTEM__/querystring')
  , crypto = require('__SYSTEM__/crypto')

  , oauth = require('oauth-sign')
  , hawk = require('hawk')
  , aws = require('aws-sign')
  , httpSignature = require('http-signature')
  , uuid = require('node-uuid')
  , mime = require('mime')
  , tunnel = require('tunnel-agent')
  , safeStringify = require('json-stringify-safe')

  , ForeverAgent = require('forever-agent')
  , FormData = require('form-data')

  , Cookie = require('cookie-jar')
  , CookieJar = Cookie.Jar
  , cookieJar = new CookieJar
  ;

try {
  https = require('__SYSTEM__/https')
} catch (e) {}

try {
  tls = require('__SYSTEM__/tls')
} catch (e) {}

var debug
if (/\brequest\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    console.error('REQUEST %s', util.format.apply(util, arguments))
  }
} else {
  debug = function() {}
}

function toBase64 (str) {
  return (new Buffer(str || "", "ascii")).toString("base64")
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

// Hacky fix for pre-0.4.4 https
if (https && !https.Agent) {
  https.Agent = function (options) {
    http.Agent.call(this, options)
  }
  util.inherits(https.Agent, http.Agent)
  https.Agent.prototype._getConnection = function (host, port, cb) {
    var s = tls.connect(port, host, this.options, function () {
      // do other checks here?
      if (cb) cb()
    })
    return s
  }
}

function isReadStream (rs) {
  if (rs.readable && rs.path && rs.mode) {
    return true
  }
}

function copy (obj) {
  var o = {}
  Object.keys(obj).forEach(function (i) {
    o[i] = obj[i]
  })
  return o
}

var isUrl = /^https?:/

var globalPool = {}

function Request (options) {
  stream.Stream.call(this)
  this.readable = true
  this.writable = true

  if (typeof options === 'string') {
    options = {uri:options}
  }

  var reserved = Object.keys(Request.prototype)
  for (var i in options) {
    if (reserved.indexOf(i) === -1) {
      this[i] = options[i]
    } else {
      if (typeof options[i] === 'function') {
        delete options[i]
      }
    }
  }

  if (options.method) {
    this.explicitMethod = true
  }

  this.init(options)
}
util.inherits(Request, stream.Stream)
Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) options = {}

  if (!self.method) self.method = options.method || 'GET'
  self.localAddress = options.localAddress

  debug(options)
  if (!self.pool && self.pool !== false) self.pool = globalPool
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback && self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) return // Print a warning maybe?
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on('error', self.callback.bind())
    self.on('complete', self.callback.bind(self, null))
  }

  if (self.url) {
    // People use this property instead all the time so why not just support it.
    self.uri = self.url
    delete self.url
  }

  if (!self.uri) {
    // this will throw if unhandled but is handleable when in a redirect
    return self.emit('error', new Error("options.uri is a required argument"))
  } else {
    if (typeof self.uri == "string") self.uri = url.parse(self.uri)
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (self.proxy) {
    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)

    // do the HTTP CONNECT dance using koichik/node-tunnel
    if (http.globalAgent && self.uri.protocol === "https:") {
      var tunnelFn = self.proxy.protocol === "http:"
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps

      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth
                                   , headers: { Host: self.uri.hostname + ':' +
                                        (self.uri.port || self.uri.protocol === 'https:' ? 443 : 80) }}
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: this.ca }

      self.agent = tunnelFn(tunnelOptions)
      self.tunnel = true
    }
  }

  if (!self.uri.host || !self.uri.pathname) {
    // Invalid URI: it may generate lot of bad errors, like "TypeError: Cannot call method 'indexOf' of undefined" in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = 'Invalid URI "' + faultyUri + '"'
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (he didn't call request directly with this URL)
      // he should be warned that it can be caused by a redirection (can save some hair)
      message += '. This can be caused by a crappy redirection.'
    }
    self.emit('error', new Error(message))
    return // This error was fatal
  }

  self._redirectsFollowed = self._redirectsFollowed || 0
  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10
  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true
  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false
  if (self.followRedirect || self.followAllRedirects)
    self.redirects = self.redirects || []

  self.headers = self.headers ? copy(self.headers) : {}

  self.setHost = false
  if (!(self.headers.host || self.headers.Host)) {
    self.headers.host = self.uri.hostname
    if (self.uri.port) {
      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&
           !(self.uri.port === 443 && self.uri.protocol === 'https:') )
      self.headers.host += (':'+self.uri.port)
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.pathname) {self.uri.pathname = '/'}
  if (!self.uri.port) {
    if (self.uri.protocol == 'http:') {self.uri.port = 80}
    else if (self.uri.protocol == 'https:') {self.uri.port = 443}
  }

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  self.clientErrorHandler = function (error) {
    if (self._aborted) return

    if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
        && self.agent.addRequestNoreuse) {
      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
      self.start()
      self.req.end()
      return
    }
    if (self.timeout && self.timeoutTimer) {
      clearTimeout(self.timeoutTimer)
      self.timeoutTimer = null
    }
    self.emit('error', error)
  }

  self._parserErrorHandler = function (error) {
    if (this.res) {
      if (this.res.request) {
        this.res.request.emit('error', error)
      } else {
        this.res.emit('error', error)
      }
    } else {
      this._httpMessage.emit('error', error)
    }
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.qs) self.qs(options.qs)

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || "")
  }

  if (self.path.length === 0) self.path = '/'


  // Auth must happen last in case signing is dependent on other headers
  if (options.oauth) {
    self.oauth(options.oauth)
  }

  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    self.auth(
      (options.auth.user==="") ? options.auth.user : (options.auth.user || options.auth.username ),
      options.auth.pass || options.auth.password,
      options.auth.sendImmediately)
  }

  if (self.uri.auth && !self.headers.authorization) {
    var authPieces = self.uri.auth.split(':').map(function(item){ return querystring.unescape(item) })
    self.auth(authPieces[0], authPieces.slice(1).join(':'), true)
  }
  if (self.proxy && self.proxy.auth && !self.headers['proxy-authorization'] && !self.tunnel) {
    self.headers['proxy-authorization'] = "Basic " + toBase64(self.proxy.auth.split(':').map(function(item){ return querystring.unescape(item)}).join(':'))
  }


  if (self.proxy && !self.tunnel) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)

  if (options.json) {
    self.json(options.json)
  } else if (options.multipart) {
    self.boundary = uuid()
    self.multipart(options.multipart)
  }

  if (self.body) {
    var length = 0
    if (!Buffer.isBuffer(self.body)) {
      if (Array.isArray(self.body)) {
        for (var i = 0; i < self.body.length; i++) {
          length += self.body[i].length
        }
      } else {
        self.body = new Buffer(self.body)
        length = self.body.length
      }
    } else {
      length = self.body.length
    }
    if (length) {
      if(!self.headers['content-length'] && !self.headers['Content-Length'])
      self.headers['content-length'] = length
    } else {
      throw new Error('Argument error, options.body.')
    }
  }

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
    , defaultModules = {'http:':http, 'https:':https}
    , httpModules = self.httpModules || {}
    ;
  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) return this.emit('error', new Error("Invalid protocol"))

  if (options.ca) self.ca = options.ca

  if (!self.agent) {
    if (options.agentOptions) self.agentOptions = options.agentOptions

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getAgent()
    if (self.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.maxSockets
    }
    if (self.pool.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.pool.maxSockets
    }
  }

  self.once('pipe', function (src) {
    if (self.ntick && self._started) throw new Error("You cannot pipe to this stream after the outbound request has started.")
    self.src = src
    if (isReadStream(src)) {
      if (!self.headers['content-type'] && !self.headers['Content-Type'])
        self.headers['content-type'] = mime.lookup(src.path)
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.headers[i]) {
            self.headers[i] = src.headers[i]
          }
        }
      }
      if (self._json && !self.headers['content-type'] && !self.headers['Content-Type'])
        self.headers['content-type'] = 'application/json'
      if (src.method && !self.explicitMethod) {
        self.method = src.method
      }
    }

    self.on('pipe', function () {
      console.error("You have already piped to this stream. Pipeing twice is likely to break the request.")
    })
  })

  process.nextTick(function () {
    if (self._aborted) return

    if (self._form) {
      self.setHeaders(self._form.getHeaders())
      self._form.pipe(self)
    }
    if (self.body) {
      if (Array.isArray(self.body)) {
        self.body.forEach(function (part) {
          self.write(part)
        })
      } else {
        self.write(self.body)
      }
      self.end()
    } else if (self.requestBodyStream) {
      console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.")
      self.requestBodyStream.pipe(self)
    } else if (!self.src) {
      if (self.method !== 'GET' && typeof self.method !== 'undefined') {
        self.headers['content-length'] = 0
      }
      self.end()
    }
    self.ntick = true
  })
}

// Must call this when following a redirect from https to http or vice versa
// Attempts to keep everything as identical as possible, but update the
// httpModule, Tunneling agent, and/or Forever Agent in use.
Request.prototype._updateProtocol = function () {
  var self = this
  var protocol = self.uri.protocol

  if (protocol === 'https:') {
    // previously was doing http, now doing https
    // if it's https, then we might need to tunnel now.
    if (self.proxy) {
      self.tunnel = true
      var tunnelFn = self.proxy.protocol === 'http:'
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps
      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: self.ca }
      self.agent = tunnelFn(tunnelOptions)
      return
    }

    self.httpModule = https
    switch (self.agentClass) {
      case ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        break
      case http.Agent:
        self.agentClass = https.Agent
        break
      default:
        // nothing we can do.  Just hope for the best.
        return
    }

    // if there's an agent, we need to get a new one.
    if (self.agent) self.agent = self.getAgent()

  } else {
    // previously was doing https, now doing http
    // stop any tunneling.
    if (self.tunnel) self.tunnel = false
    self.httpModule = http
    switch (self.agentClass) {
      case ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        break
      case https.Agent:
        self.agentClass = http.Agent
        break
      default:
        // nothing we can do.  just hope for the best
        return
    }

    // if there's an agent, then get a new one.
    if (self.agent) {
      self.agent = null
      self.agent = self.getAgent()
    }
  }
}

Request.prototype.getAgent = function () {
  var Agent = this.agentClass
  var options = {}
  if (this.agentOptions) {
    for (var i in this.agentOptions) {
      options[i] = this.agentOptions[i]
    }
  }
  if (this.ca) options.ca = this.ca
  if (typeof this.rejectUnauthorized !== 'undefined') options.rejectUnauthorized = this.rejectUnauthorized

  if (this.cert && this.key) {
    options.key = this.key
    options.cert = this.cert
  }

  var poolKey = ''

  // different types of agents are in different pools
  if (Agent !== this.httpModule.Agent) {
    poolKey += Agent.name
  }

  if (!this.httpModule.globalAgent) {
    // node 0.4.x
    options.host = this.host
    options.port = this.port
    if (poolKey) poolKey += ':'
    poolKey += this.host + ':' + this.port
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = this.proxy
  if (typeof proxy === 'string') proxy = url.parse(proxy)
  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'
  if (isHttps) {
    if (options.ca) {
      if (poolKey) poolKey += ':'
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== 'undefined') {
      if (poolKey) poolKey += ':'
      poolKey += options.rejectUnauthorized
    }

    if (options.cert)
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')
  }

  if (!poolKey && Agent === this.httpModule.Agent && this.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return this.httpModule.globalAgent
  }

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = this.uri.protocol + poolKey

  // already generated an agent for this setting
  if (this.pool[poolKey]) return this.pool[poolKey]

  return this.pool[poolKey] = new Agent(options)
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self._aborted) return

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  if (self.src && self.src.stat && self.src.stat.size && !self.headers['content-length'] && !self.headers['Content-Length']) {
    self.headers['content-length'] = self.src.stat.size
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug('make request', self.uri.href)
  self.req = self.httpModule.request(reqOptions, self.onResponse.bind(self))

  if (self.timeout && !self.timeoutTimer) {
    self.timeoutTimer = setTimeout(function () {
      self.req.abort()
      var e = new Error("ETIMEDOUT")
      e.code = "ETIMEDOUT"
      self.emit("error", e)
    }, self.timeout)

    // Set additional timeout on socket - in case if remote
    // server freeze after sending headers
    if (self.req.setTimeout) { // only works on node 0.6+
      self.req.setTimeout(self.timeout, function () {
        if (self.req) {
          self.req.abort()
          var e = new Error("ESOCKETTIMEDOUT")
          e.code = "ESOCKETTIMEDOUT"
          self.emit("error", e)
        }
      })
    }
  }

  self.req.on('error', self.clientErrorHandler)
  self.req.on('drain', function() {
    self.emit('drain')
  })
  self.on('end', function() {
    if ( self.req.connection ) self.req.connection.removeListener('error', self._parserErrorHandler)
  })
  self.emit('request', self.req)
}
Request.prototype.onResponse = function (response) {
  var self = this
  debug('onResponse', self.uri.href, response.statusCode, response.headers)
  response.on('end', function() {
    debug('response end', self.uri.href, response.statusCode, response.headers)
  });

  if (response.connection.listeners('error').indexOf(self._parserErrorHandler) === -1) {
    response.connection.once('error', self._parserErrorHandler)
  }
  if (self._aborted) {
    debug('aborted', self.uri.href)
    response.resume()
    return
  }
  if (self._paused) response.pause()
  else response.resume()

  self.response = response
  response.request = self
  response.toJSON = toJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
      self.strictSSL &&
      !response.client.authorized) {
    debug('strict ssl error', self.uri.href)
    var sslErr = response.client.authorizationError
    self.emit('error', new Error('SSL Error: '+ sslErr))
    return
  }

  if (self.setHost) delete self.headers.host
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var addCookie = function (cookie) {
    if (self._jar) self._jar.add(new Cookie(cookie))
    else cookieJar.add(new Cookie(cookie))
  }

  if (response.headers['set-cookie'] && (!self._disableCookies)) {
    if (Array.isArray(response.headers['set-cookie'])) response.headers['set-cookie'].forEach(addCookie)
    else addCookie(response.headers['set-cookie'])
  }

  var redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
    debug('redirect', response.headers.location)

    if (self.followAllRedirects) {
      redirectTo = response.headers.location
    } else if (self.followRedirect) {
      switch (self.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = response.headers.location
          break
      }
    }
  } else if (response.statusCode == 401 && self._hasAuth && !self._sentAuth) {
    var authHeader = response.headers['www-authenticate']
    var authVerb = authHeader && authHeader.split(' ')[0]
    debug('reauth', authVerb)

    switch (authVerb) {
      case 'Basic':
        self.auth(self._user, self._pass, true)
        redirectTo = self.uri
        break

      case 'Digest':
        // TODO: More complete implementation of RFC 2617.  For reference:
        // http://tools.ietf.org/html/rfc2617#section-3
        // https://github.com/bagder/curl/blob/master/lib/http_digest.c

        var matches = authHeader.match(/([a-z0-9_-]+)="([^"]+)"/gi)
        var challenge = {}

        for (var i = 0; i < matches.length; i++) {
          var eqPos = matches[i].indexOf('=')
          var key = matches[i].substring(0, eqPos)
          var quotedValue = matches[i].substring(eqPos + 1)
          challenge[key] = quotedValue.substring(1, quotedValue.length - 1)
        }

        var ha1 = md5(self._user + ':' + challenge.realm + ':' + self._pass)
        var ha2 = md5(self.method + ':' + self.uri.path)
        var digestResponse = md5(ha1 + ':' + challenge.nonce + ':1::auth:' + ha2)
        var authValues = {
          username: self._user,
          realm: challenge.realm,
          nonce: challenge.nonce,
          uri: self.uri.path,
          qop: challenge.qop,
          response: digestResponse,
          nc: 1,
          cnonce: ''
        }

        authHeader = []
        for (var k in authValues) {
          authHeader.push(k + '="' + authValues[k] + '"')
        }
        authHeader = 'Digest ' + authHeader.join(', ')
        self.setHeader('authorization', authHeader)
        self._sentAuth = true

        redirectTo = self.uri
        break
    }
  }

  if (redirectTo) {
    debug('redirect to', redirectTo)

    // ignore any potential response body.  it cannot possibly be useful
    // to us at this point.
    if (self._paused) response.resume()

    if (self._redirectsFollowed >= self.maxRedirects) {
      self.emit('error', new Error("Exceeded maxRedirects. Probably stuck in a redirect loop "+self.uri.href))
      return
    }
    self._redirectsFollowed += 1

    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(self.uri.href, redirectTo)
    }

    var uriPrev = self.uri
    self.uri = url.parse(redirectTo)

    // handle the case where we change protocol from https to http or vice versa
    if (self.uri.protocol !== uriPrev.protocol) {
      self._updateProtocol()
    }

    self.redirects.push(
      { statusCode : response.statusCode
      , redirectUri: redirectTo
      }
    )
    if (self.followAllRedirects && response.statusCode != 401) self.method = 'GET'
    // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215
    delete self.src
    delete self.req
    delete self.agent
    delete self._started
    if (response.statusCode != 401) {
      // Remove parameters from the previous response, unless this is the second request
      // for a server that requires digest authentication.
      delete self.body
      delete self._form
      if (self.headers) {
        delete self.headers.host
        delete self.headers['content-type']
        delete self.headers['content-length']
      }
    }

    self.emit('redirect');

    self.init()
    return // Ignore the rest of the response
  } else {
    self._redirectsFollowed = self._redirectsFollowed || 0
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function () {
      if (!self._ended) self.response.emit('end')
    })

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error("Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.")
      } else {
        response.setEncoding(self.encoding)
      }
    }

    self.emit('response', response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    response.on("data", function (chunk) {
      self._destdata = true
      self.emit("data", chunk)
    })
    response.on("end", function (chunk) {
      self._ended = true
      self.emit("end", chunk)
    })
    response.on("close", function () {self.emit("close")})

    if (self.callback) {
      var buffer = []
      var bodyLen = 0
      self.on("data", function (chunk) {
        buffer.push(chunk)
        bodyLen += chunk.length
      })
      self.on("end", function () {
        debug('end event', self.uri.href)
        if (self._aborted) {
          debug('aborted', self.uri.href)
          return
        }

        if (buffer.length && Buffer.isBuffer(buffer[0])) {
          debug('has body', self.uri.href, bodyLen)
          var body = new Buffer(bodyLen)
          var i = 0
          buffer.forEach(function (chunk) {
            chunk.copy(body, i, 0, chunk.length)
            i += chunk.length
          })
          if (self.encoding === null) {
            response.body = body
          } else {
            response.body = body.toString(self.encoding)
          }
        } else if (buffer.length) {
          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
          if (self.encoding === 'utf8' && buffer[0].length > 0 && buffer[0][0] === "\uFEFF") {
            buffer[0] = buffer[0].substring(1)
          }
          response.body = buffer.join('')
        }

        if (self._json) {
          try {
            response.body = JSON.parse(response.body)
          } catch (e) {}
        }
        debug('emitting complete', self.uri.href)
        if(response.body == undefined && !self._json) {
          response.body = "";
        }
        self.emit('complete', response, response.body)
      })
    }
  }
  debug('finish init function', self.uri.href)
}

Request.prototype.abort = function () {
  this._aborted = true

  if (this.req) {
    this.req.abort()
  }
  else if (this.response) {
    this.response.abort()
  }

  this.emit("abort")
}

Request.prototype.pipeDest = function (dest) {
  var response = this.response
  // Called after the response is received
  if (dest.headers) {
    dest.headers['content-type'] = response.headers['content-type']
    if (response.headers['content-length']) {
      dest.headers['content-length'] = response.headers['content-length']
    }
  }
  if (dest.setHeader) {
    for (var i in response.headers) {
      dest.setHeader(i, response.headers[i])
    }
    dest.statusCode = response.statusCode
  }
  if (this.pipefilter) this.pipefilter(response, dest)
}

// Composable API
Request.prototype.setHeader = function (name, value, clobber) {
  if (clobber === undefined) clobber = true
  if (clobber || !this.headers.hasOwnProperty(name)) this.headers[name] = value
  else this.headers[name] += ',' + value
  return this
}
Request.prototype.setHeaders = function (headers) {
  for (var i in headers) {this.setHeader(i, headers[i])}
  return this
}
Request.prototype.qs = function (q, clobber) {
  var base
  if (!clobber && this.uri.query) base = qs.parse(this.uri.query)
  else base = {}

  for (var i in q) {
    base[i] = q[i]
  }

  if (qs.stringify(base) === ''){
    return this
  }

  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base))
  this.url = this.uri
  this.path = this.uri.path

  return this
}
Request.prototype.form = function (form) {
  if (form) {
    this.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8'
    this.body = qs.stringify(form).toString('utf8')
    return this
  }
  // create form-data object
  this._form = new FormData()
  return this._form
}
Request.prototype.multipart = function (multipart) {
  var self = this
  self.body = []

  if (!self.headers['content-type']) {
    self.headers['content-type'] = 'multipart/related; boundary=' + self.boundary
  } else {
    self.headers['content-type'] = self.headers['content-type'].split(';')[0] + '; boundary=' + self.boundary
  }

  if (!multipart.forEach) throw new Error('Argument error, options.multipart.')

  if (self.preambleCRLF) {
    self.body.push(new Buffer('\r\n'))
  }

  multipart.forEach(function (part) {
    var body = part.body
    if(body == null) throw Error('Body attribute missing in multipart.')
    delete part.body
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part).forEach(function (key) {
      preamble += key + ': ' + part[key] + '\r\n'
    })
    preamble += '\r\n'
    self.body.push(new Buffer(preamble))
    self.body.push(new Buffer(body))
    self.body.push(new Buffer('\r\n'))
  })
  self.body.push(new Buffer('--' + self.boundary + '--'))
  return self
}
Request.prototype.json = function (val) {
  var self = this;
  var setAcceptHeader = function() {
  	if (!self.headers['accept'] && !self.headers['Accept']) {
			  self.setHeader('accept', 'application/json')
		}
	}
  setAcceptHeader();
  this._json = true
  if (typeof val === 'boolean') {
    if (typeof this.body === 'object') {
      setAcceptHeader();
      this.body = safeStringify(this.body)
      self.setHeader('content-type', 'application/json')
    }
  } else {
    setAcceptHeader();
    this.body = safeStringify(val)
    self.setHeader('content-type', 'application/json')
  }
  return this
}
function getHeader(name, headers) {
    var result, re, match
    Object.keys(headers).forEach(function (key) {
        re = new RegExp(name, 'i')
        match = key.match(re)
        if (match) result = headers[key]
    })
    return result
}
Request.prototype.auth = function (user, pass, sendImmediately) {
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
    throw new Error('auth() received invalid user or password')
  }
  this._user = user
  this._pass = pass
  this._hasAuth = true
  if (sendImmediately || typeof sendImmediately == 'undefined') {
    this.setHeader('authorization', 'Basic ' + toBase64(user + ':' + pass))
    this._sentAuth = true
  }
  return this
}
Request.prototype.aws = function (opts, now) {
  if (!now) {
    this._aws = opts
    return this
  }
  var date = new Date()
  this.setHeader('date', date.toUTCString())
  var auth =
    { key: opts.key
    , secret: opts.secret
    , verb: this.method.toUpperCase()
    , date: date
    , contentType: getHeader('content-type', this.headers) || ''
    , md5: getHeader('content-md5', this.headers) || ''
    , amazonHeaders: aws.canonicalizeHeaders(this.headers)
    }
  if (opts.bucket && this.path) {
    auth.resource = '/' + opts.bucket + this.path
  } else if (opts.bucket && !this.path) {
    auth.resource = '/' + opts.bucket
  } else if (!opts.bucket && this.path) {
    auth.resource = this.path
  } else if (!opts.bucket && !this.path) {
    auth.resource = '/'
  }
  auth.resource = aws.canonicalizeResource(auth.resource)
  this.setHeader('authorization', aws.authorization(auth))

  return this
}
Request.prototype.httpSignature = function (opts) {
  var req = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return getHeader(header, req.headers)
    },
    setHeader: function(header, value) {
      req.setHeader(header, value)
    },
    method: this.method,
    path: this.path
  }, opts)
  debug('httpSignature authorization', getHeader('authorization', this.headers))

  return this
}

Request.prototype.hawk = function (opts) {
  this.headers.Authorization = hawk.client.header(this.uri, this.method, opts).field
}

Request.prototype.oauth = function (_oauth) {
  var form
  if (this.headers['content-type'] &&
      this.headers['content-type'].slice(0, 'application/x-www-form-urlencoded'.length) ===
        'application/x-www-form-urlencoded'
     ) {
    form = qs.parse(this.body)
  }
  if (this.uri.query) {
    form = qs.parse(this.uri.query)
  }
  if (!form) form = {}
  var oa = {}
  for (var i in form) oa[i] = form[i]
  for (var i in _oauth) oa['oauth_'+i] = _oauth[i]
  if (!oa.oauth_version) oa.oauth_version = '1.0'
  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')

  oa.oauth_signature_method = 'HMAC-SHA1'

  var consumer_secret = oa.oauth_consumer_secret
  delete oa.oauth_consumer_secret
  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret
  var timestamp = oa.oauth_timestamp

  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname
  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret)

  // oa.oauth_signature = signature
  for (var i in form) {
    if ( i.slice(0, 'oauth_') in _oauth) {
      // skip
    } else {
      delete oa['oauth_'+i]
      if (i !== 'x_auth_mode') delete oa[i]
    }
  }
  oa.oauth_timestamp = timestamp
  this.headers.Authorization =
    'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'="'+oauth.rfc3986(oa[i])+'"'}).join(',')
  this.headers.Authorization += ',oauth_signature="' + oauth.rfc3986(signature) + '"'
  return this
}
Request.prototype.jar = function (jar) {
  var cookies

  if (this._redirectsFollowed === 0) {
    this.originalCookieHeader = this.headers.cookie
  }

  if (jar === false) {
    // disable cookies
    cookies = false
    this._disableCookies = true
  } else if (jar) {
    // fetch cookie from the user defined cookie jar
    cookies = jar.get({ url: this.uri.href })
  } else {
    // fetch cookie from the global cookie jar
    cookies = cookieJar.get({ url: this.uri.href })
  }

  if (cookies && cookies.length) {
    var cookieString = cookies.map(function (c) {
      return c.name + "=" + c.value
    }).join("; ")

    if (this.originalCookieHeader) {
      // Don't overwrite existing Cookie header
      this.headers.cookie = this.originalCookieHeader + '; ' + cookieString
    } else {
      this.headers.cookie = cookieString
    }
  }
  this._jar = jar
  return this
}


// Stream API
Request.prototype.pipe = function (dest, opts) {
  if (this.response) {
    if (this._destdata) {
      throw new Error("You cannot pipe after data has been emitted from the response.")
    } else if (this._ended) {
      throw new Error("You cannot pipe after the response has been ended.")
    } else {
      stream.Stream.prototype.pipe.call(this, dest, opts)
      this.pipeDest(dest)
      return dest
    }
  } else {
    this.dests.push(dest)
    stream.Stream.prototype.pipe.call(this, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  if (!this._started) this.start()
  return this.req.write.apply(this.req, arguments)
}
Request.prototype.end = function (chunk) {
  if (chunk) this.write(chunk)
  if (!this._started) this.start()
  this.req.end()
}
Request.prototype.pause = function () {
  if (!this.response) this._paused = true
  else this.response.pause.apply(this.response, arguments)
}
Request.prototype.resume = function () {
  if (!this.response) this._paused = false
  else this.response.resume.apply(this.response, arguments)
}
Request.prototype.destroy = function () {
  if (!this._ended) this.end()
  else if (this.response) this.response.destroy()
}

// organize params for patch, post, put, head, del
function initParams(uri, options, callback) {
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
    uri = options.uri
  }
  return { uri: uri, options: options, callback: callback }
}

function request (uri, options, callback) {
  if (typeof uri === 'undefined') throw new Error('undefined is not a valid uri or options object.')
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
  }

  options = copy(options)

  if (callback) options.callback = callback
  var r = new Request(options)
  return r
}

module.exports = request

request.debug = process.env.NODE_DEBUG && /request/.test(process.env.NODE_DEBUG)

request.initParams = initParams

request.defaults = function (options, requester) {
  var def = function (method) {
    var d = function (uri, opts, callback) {
      var params = initParams(uri, opts, callback)
      for (var i in options) {
        if (params.options[i] === undefined) params.options[i] = options[i]
      }
      if(typeof requester === 'function') {
        if(method === request) {
          method = requester
        } else {
          params.options._requester = requester
        }
      }
      return method(params.options, params.callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.patch = def(request.patch)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  de.del = def(request.del)
  de.cookie = def(request.cookie)
  de.jar = request.jar
  return de
}

request.forever = function (agentOptions, optionsArg) {
  var options = {}
  if (optionsArg) {
    for (option in optionsArg) {
      options[option] = optionsArg[option]
    }
  }
  if (agentOptions) options.agentOptions = agentOptions
  options.forever = true
  return request.defaults(options)
}

request.get = request
request.post = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'POST'
  return request(params.uri || null, params.options, params.callback)
}
request.put = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PUT'
  return request(params.uri || null, params.options, params.callback)
}
request.patch = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PATCH'
  return request(params.uri || null, params.options, params.callback)
}
request.head = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'HEAD'
  if (params.options.body ||
      params.options.requestBodyStream ||
      (params.options.json && typeof params.options.json !== 'boolean') ||
      params.options.multipart) {
    throw new Error("HTTP HEAD requests MUST NOT include a request body.")
  }
  return request(params.uri || null, params.options, params.callback)
}
request.del = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'DELETE'
  if(typeof params.options._requester === 'function') {
    request = params.options._requester
  }
  return request(params.uri || null, params.options, params.callback)
}
request.jar = function () {
  return new CookieJar
}
request.cookie = function (str) {
  if (str && str.uri) str = str.uri
  if (typeof str !== 'string') throw new Error("The cookie function only accepts STRING as param")
  return new Cookie(str)
}

// Safe toJSON

function getSafe (self, uuid) {
  if (typeof self === 'object' || typeof self === 'function') var safe = {}
  if (Array.isArray(self)) var safe = []

  var recurse = []

  Object.defineProperty(self, uuid, {})

  var attrs = Object.keys(self).filter(function (i) {
    if (i === uuid) return false
    if ( (typeof self[i] !== 'object' && typeof self[i] !== 'function') || self[i] === null) return true
    return !(Object.getOwnPropertyDescriptor(self[i], uuid))
  })


  for (var i=0;i<attrs.length;i++) {
    if ( (typeof self[attrs[i]] !== 'object' && typeof self[attrs[i]] !== 'function') ||
          self[attrs[i]] === null
        ) {
      safe[attrs[i]] = self[attrs[i]]
    } else {
      recurse.push(attrs[i])
      Object.defineProperty(self[attrs[i]], uuid, {})
    }
  }

  for (var i=0;i<recurse.length;i++) {
    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)
  }

  return safe
}

function toJSON () {
  return getSafe(this, '__' + (((1+Math.random())*0x10000)|0).toString(16))
}

Request.prototype.toJSON = toJSON

return {
    http: (typeof http !== "undefined") ? http : null,
    require: (typeof require !== "undefined") ? require : null,
    https: (typeof https !== "undefined") ? https : null,
    tls: (typeof tls !== "undefined") ? tls : null,
    url: (typeof url !== "undefined") ? url : null,
    util: (typeof util !== "undefined") ? util : null,
    stream: (typeof stream !== "undefined") ? stream : null,
    qs: (typeof qs !== "undefined") ? qs : null,
    querystring: (typeof querystring !== "undefined") ? querystring : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    oauth: (typeof oauth !== "undefined") ? oauth : null,
    hawk: (typeof hawk !== "undefined") ? hawk : null,
    aws: (typeof aws !== "undefined") ? aws : null,
    httpSignature: (typeof httpSignature !== "undefined") ? httpSignature : null,
    uuid: (typeof uuid !== "undefined") ? uuid : null,
    mime: (typeof mime !== "undefined") ? mime : null,
    tunnel: (typeof tunnel !== "undefined") ? tunnel : null,
    safeStringify: (typeof safeStringify !== "undefined") ? safeStringify : null,
    ForeverAgent: (typeof ForeverAgent !== "undefined") ? ForeverAgent : null,
    FormData: (typeof FormData !== "undefined") ? FormData : null,
    Cookie: (typeof Cookie !== "undefined") ? Cookie : null,
    CookieJar: (typeof CookieJar !== "undefined") ? CookieJar : null,
    cookieJar: (typeof cookieJar !== "undefined") ? cookieJar : null,
    debug: (typeof debug !== "undefined") ? debug : null,
    process: (typeof process !== "undefined") ? process : null,
    console: (typeof console !== "undefined") ? console : null,
    toBase64: (typeof toBase64 !== "undefined") ? toBase64 : null,
    md5: (typeof md5 !== "undefined") ? md5 : null,
    isReadStream: (typeof isReadStream !== "undefined") ? isReadStream : null,
    copy: (typeof copy !== "undefined") ? copy : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    isUrl: (typeof isUrl !== "undefined") ? isUrl : null,
    globalPool: (typeof globalPool !== "undefined") ? globalPool : null,
    Request: (typeof Request !== "undefined") ? Request : null,
    clearTimeout: (typeof clearTimeout !== "undefined") ? clearTimeout : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    setTimeout: (typeof setTimeout !== "undefined") ? setTimeout : null,
    JSON: (typeof JSON !== "undefined") ? JSON : null,
    getHeader: (typeof getHeader !== "undefined") ? getHeader : null,
    Date: (typeof Date !== "undefined") ? Date : null,
    Math: (typeof Math !== "undefined") ? Math : null,
    initParams: (typeof initParams !== "undefined") ? initParams : null,
    request: (typeof request !== "undefined") ? request : null,
    module: (typeof module !== "undefined") ? module : null,
    getSafe: (typeof getSafe !== "undefined") ? getSafe : null,
    toJSON: (typeof toJSON !== "undefined") ? toJSON : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/qs/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"a13b2b95ca51018b6d405a7e337ddb2d9da913d6-qs/index.js"}
require.memoize("a13b2b95ca51018b6d405a7e337ddb2d9da913d6-qs/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/qs';
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      ret.push(key);
    }
  }
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = {}
  var t = {};
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  
  // illegal
  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;
  
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = {};
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: {} }).base;

  return compact(ret);
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/qs/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/oauth-sign/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"0a2767d204df2a563b9513a5b12e7f2ef737e245-oauth-sign/index.js"}
require.memoize("0a2767d204df2a563b9513a5b12e7f2ef737e245-oauth-sign/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/oauth-sign';
var crypto = require('__SYSTEM__/crypto')
  , qs = require('__SYSTEM__/querystring')
  ;

function sha1 (key, body) {
  return crypto.createHmac('sha1', key).update(body).digest('base64')
}

function rfc3986 (str) {
  return encodeURIComponent(str)
    .replace(/!/g,'%21')
    .replace(/\*/g,'%2A')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29')
    .replace(/'/g,'%27')
    ;
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  var querystring = Object.keys(params).sort().map(function(key){
    // big WTF here with the escape + encoding but it's what twitter wants
    return escape(rfc3986(key)) + "%3D" + escape(rfc3986(params[key]))
  }).join('%26')

  var base = [
    httpMethod ? httpMethod.toUpperCase() : 'GET',
    rfc3986(base_uri),
    querystring
  ].join('&')

  var key = [
    consumer_secret,
    token_secret || ''
  ].map(rfc3986).join('&')

  return sha1(key, base)
}

exports.hmacsign = hmacsign
exports.rfc3986 = rfc3986

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/oauth-sign/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/index.js"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/index.js"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib';
// Export sub-modules

exports.error = exports.Error = require('boom');
exports.sntp = require('sntp');
exports.server = require('./server');
exports.client = require('./client');
exports.crypto = require('./crypto');
exports.utils = require('./utils');

exports.uri = {
    authenticate: exports.server.authenticateBewit,
    getBewit: exports.client.getBewit
};



}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/index.js"}
require.memoize("bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/lib/index.js"}
require.memoize("bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/lib';
// Load modules

var Http = require('__SYSTEM__/http');
var NodeUtil = require('__SYSTEM__/util');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports = module.exports = internals.Boom = function (/* (new Error) or (code, message) */) {

    var self = this;

    Hoek.assert(this.constructor === internals.Boom, 'Error must be instantiated using new');

    Error.call(this);
    this.isBoom = true;

    this.response = {
        code: 0,
        payload: {},
        headers: {}
        // type: 'content-type'
    };

    if (arguments[0] instanceof Error) {

        // Error

        var error = arguments[0];

        this.data = error;
        this.response.code = error.code || 500;
        if (error.message) {
            this.message = error.message;
        }
    }
    else {

        // code, message

        var code = arguments[0];
        var message = arguments[1];

        Hoek.assert(!isNaN(parseFloat(code)) && isFinite(code) && code >= 400, 'First argument must be a number (400+)');

        this.response.code = code;
        if (message) {
            this.message = message;
        }
    }

    // Response format

    this.reformat();

    return this;
};

NodeUtil.inherits(internals.Boom, Error);


internals.Boom.prototype.reformat = function () {

    this.response.payload.code = this.response.code;
    this.response.payload.error = Http.STATUS_CODES[this.response.code] || 'Unknown';
    if (this.message) {
        this.response.payload.message = Hoek.escapeHtml(this.message);         // Prevent XSS from error message
    }
};


// Utilities

internals.Boom.badRequest = function (message) {

    return new internals.Boom(400, message);
};


internals.Boom.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])

    var err = new internals.Boom(401, message);

    if (!scheme) {
        return err;
    }

    var wwwAuthenticate = '';

    if (typeof scheme === 'string') {

        // function (message, scheme, attributes)

        wwwAuthenticate = scheme;
        if (attributes) {
            var names = Object.keys(attributes);
            for (var i = 0, il = names.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ',';
                }

                var value = attributes[names[i]];
                if (value === null ||
                    value === undefined) {              // Value can be zero

                    value = '';
                }
                wwwAuthenticate += ' ' + names[i] + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
            }
        }

        if (message) {
            if (attributes) {
                wwwAuthenticate += ',';
            }
            wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
        }
        else {
            err.isMissing = true;
        }
    }
    else {

        // function (message, wwwAuthenticate[])

        var wwwArray = scheme;
        for (var i = 0, il = wwwArray.length; i < il; ++i) {
            if (i) {
                wwwAuthenticate += ', ';
            }

            wwwAuthenticate += wwwArray[i];
        }
    }

    err.response.headers['WWW-Authenticate'] = wwwAuthenticate;

    return err;
};


internals.Boom.clientTimeout = function (message) {

    return new internals.Boom(408, message);
};


internals.Boom.serverTimeout = function (message) {

    return new internals.Boom(503, message);
};


internals.Boom.forbidden = function (message) {

    return new internals.Boom(403, message);
};


internals.Boom.notFound = function (message) {

    return new internals.Boom(404, message);
};


internals.Boom.internal = function (message, data) {

    var err = new internals.Boom(500, message);

    if (data && data.stack) {
        err.trace = data.stack.split('\n');
        err.outterTrace = Hoek.displayStack(1);
    }
    else {
        err.trace = Hoek.displayStack(1);
    }

    err.data = data;
    err.response.payload.message = 'An internal server error occurred';                     // Hide actual error from user

    return err;
};


internals.Boom.passThrough = function (code, payload, contentType, headers) {

    var err = new internals.Boom(500, 'Pass-through');                                      // 500 code is only used to initialize

    err.data = {
        code: code,
        payload: payload,
        type: contentType
    };

    err.response.code = code;
    err.response.type = contentType;
    err.response.headers = headers;
    err.response.payload = payload;

    return err;
};



}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"9579db8ec37f1c7107434638cd83ebcdde128669-hoek/index.js"}
require.memoize("9579db8ec37f1c7107434638cd83ebcdde128669-hoek/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"9579db8ec37f1c7107434638cd83ebcdde128669-hoek/lib/index.js"}
require.memoize("9579db8ec37f1c7107434638cd83ebcdde128669-hoek/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/lib';
// Load modules

var Fs = require('__SYSTEM__/fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/lib/escape.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"9579db8ec37f1c7107434638cd83ebcdde128669-hoek/lib/escape.js"}
require.memoize("9579db8ec37f1c7107434638cd83ebcdde128669-hoek/lib/escape.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/lib';
// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/lib/escape.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/index.js"}
require.memoize("87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/lib/index.js"}
require.memoize("87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/lib';
// Load modules

var Dgram = require('__SYSTEM__/dgram');
var Dns = require('__SYSTEM__/dns');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports.time = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var settings = Hoek.clone(options);
    settings.host = settings.host || 'pool.ntp.org';
    settings.port = settings.port || 123;
    settings.resolveReference = settings.resolveReference || false;

    // Declare variables used by callback

    var timeoutId = 0;
    var sent = 0;

    // Ensure callback is only called once

    var isFinished = false;
    var finish = function (err, result) {

        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = 0;
        }

        if (!isFinished) {
            isFinished = true;
            socket.removeAllListeners();
            socket.close();
            return callback(err, result);
        }
    };

    // Create UDP socket

    var socket = Dgram.createSocket('udp4');

    socket.once('error', function (err) {

        return finish(err);
    });

    // Listen to incoming messages

    socket.on('message', function (buffer, rinfo) {

        var received = Date.now();

        var message = new internals.NtpMessage(buffer);
        if (!message.isValid) {
            return finish(new Error('Invalid server response'), message);
        }

        if (message.originateTimestamp !== sent) {
            return finish(new Error('Wrong originate timestamp'), message);
        }

        // Timestamp Name          ID   When Generated
        // ------------------------------------------------------------
        // Originate Timestamp     T1   time request sent by client
        // Receive Timestamp       T2   time request received by server
        // Transmit Timestamp      T3   time reply sent by server
        // Destination Timestamp   T4   time reply received by client
        //
        // The roundtrip delay d and system clock offset t are defined as:
        //
        // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2

        var T1 = message.originateTimestamp;
        var T2 = message.receiveTimestamp;
        var T3 = message.transmitTimestamp;
        var T4 = received;

        message.d = (T4 - T1) - (T3 - T2);
        message.t = ((T2 - T1) + (T3 - T4)) / 2;
        message.receivedLocally = received;

        if (!settings.resolveReference ||
            message.stratum !== 'secondary') {

            return finish(null, message);
        }

        // Resolve reference IP address

        Dns.reverse(message.referenceId, function (err, domains) {

            if (!err) {
                message.referenceHost = domains[0];
            }

            return finish(null, message);
        });
    });

    // Set timeout

    if (settings.timeout) {
        timeoutId = setTimeout(function () {

            timeoutId = 0;
            return finish(new Error('Timeout'));
        }, settings.timeout);
    }

    // Construct NTP message

    var message = new Buffer(48);
    for (var i = 0; i < 48; i++) {                      // Zero message
        message[i] = 0;
    }

    message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
    sent = Date.now();
    internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)

    // Send NTP request

    socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {

        if (err ||
            bytes !== 48) {

            return finish(err || new Error('Could not send entire message'));
        }
    });
};


internals.NtpMessage = function (buffer) {

    this.isValid = false;

    // Validate

    if (buffer.length !== 48) {
        return;
    }

    // Leap indicator

    var li = (buffer[0] >> 6);
    switch (li) {
        case 0: this.leapIndicator = 'no-warning'; break;
        case 1: this.leapIndicator = 'last-minute-61'; break;
        case 2: this.leapIndicator = 'last-minute-59'; break;
        case 3: this.leapIndicator = 'alarm'; break;
    }

    // Version

    var vn = ((buffer[0] & 0x38) >> 3);
    this.version = vn;

    // Mode

    var mode = (buffer[0] & 0x7);
    switch (mode) {
        case 1: this.mode = 'symmetric-active'; break;
        case 2: this.mode = 'symmetric-passive'; break;
        case 3: this.mode = 'client'; break;
        case 4: this.mode = 'server'; break;
        case 5: this.mode = 'broadcast'; break;
        case 0:
        case 6:
        case 7: this.mode = 'reserved'; break;
    }

    // Stratum

    var stratum = buffer[1];
    if (stratum === 0) {
        this.stratum = 'death';
    }
    else if (stratum === 1) {
        this.stratum = 'primary';
    }
    else if (stratum <= 15) {
        this.stratum = 'secondary';
    }
    else {
        this.stratum = 'reserved';
    }

    // Poll interval (msec)

    this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;

    // Precision (msecs)

    this.precision = Math.pow(2, buffer[3]) * 1000;

    // Root delay (msecs)

    var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
    this.rootDelay = 1000 * (rootDelay / 0x10000);

    // Root dispersion (msecs)

    this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;

    // Reference identifier

    this.referenceId = '';
    switch (this.stratum) {
        case 'death':
        case 'primary':
            this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
            break;
        case 'secondary':
            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
            break;
    }

    // Reference timestamp

    this.referenceTimestamp = internals.toMsecs(buffer, 16);

    // Originate timestamp

    this.originateTimestamp = internals.toMsecs(buffer, 24);

    // Receive timestamp

    this.receiveTimestamp = internals.toMsecs(buffer, 32);

    // Transmit timestamp

    this.transmitTimestamp = internals.toMsecs(buffer, 40);

    // Validate

    if (this.version === 4 &&
        this.stratum !== 'reserved' &&
        this.mode === 'server' &&
        this.originateTimestamp &&
        this.receiveTimestamp &&
        this.transmitTimestamp) {

        this.isValid = true;
    }

    return this;
};


internals.toMsecs = function (buffer, offset) {

    var seconds = 0;
    var fraction = 0;

    for (var i = 0; i < 4; ++i) {
        seconds = (seconds * 256) + buffer[offset + i];
    }

    for (i = 4; i < 8; ++i) {
        fraction = (fraction * 256) + buffer[offset + i];
    }

    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
};


internals.fromMsecs = function (ts, buffer, offset) {

    var seconds = Math.floor(ts / 1000) + 2208988800;
    var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));

    buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
    buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
    buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
    buffer[offset + 3] = (seconds & 0x000000FF);

    buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
    buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
    buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
    buffer[offset + 7] = (fraction & 0x000000FF);
};


// Offset singleton

internals.last = {
    offset: 0,
    expires: 0,
    host: '',
    port: 0
};


exports.offset = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var now = Date.now();
    var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily

    if (internals.last.offset &&
        internals.last.host === options.host &&
        internals.last.port === options.port &&
        now < internals.last.expires) {

        process.nextTick(function () {
                
            callback(null, internals.last.offset);
        });

        return;
    }

    exports.time(options, function (err, time) {

        if (err) {
            return callback(err, 0);
        }

        internals.last = {
            offset: Math.round(time.t),
            expires: now + clockSyncRefresh,
            host: options.host,
            port: options.port
        };

        return callback(null, internals.last.offset);
    });
};


// Now singleton

internals.now = {
    intervalId: 0
};


exports.start = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    if (internals.now.intervalId) {
        process.nextTick(function () {
            
            callback();
        });
        
        return;
    }

    exports.offset(options, function (err, offset) {

        internals.now.intervalId = setInterval(function () {

            exports.offset(options, function () { });
        }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily

        return callback();
    });
};


exports.stop = function () {

    if (!internals.now.intervalId) {
        return;
    }

    clearInterval(internals.now.intervalId);
    internals.now.intervalId = 0;
};


exports.isLive = function () {

    return !!internals.now.intervalId;
};


exports.now = function () {

    var now = Date.now();
    if (!exports.isLive() ||
        now >= internals.last.expires) {

        return now;
    }

    return now + internals.last.offset;
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"733132ef85628339b6e1a78283093c2a9208ca8a-hoek/index.js"}
require.memoize("733132ef85628339b6e1a78283093c2a9208ca8a-hoek/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"733132ef85628339b6e1a78283093c2a9208ca8a-hoek/lib/index.js"}
require.memoize("733132ef85628339b6e1a78283093c2a9208ca8a-hoek/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/lib';
// Load modules

var Fs = require('__SYSTEM__/fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/lib/escape.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"733132ef85628339b6e1a78283093c2a9208ca8a-hoek/lib/escape.js"}
require.memoize("733132ef85628339b6e1a78283093c2a9208ca8a-hoek/lib/escape.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/lib';
// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/lib/escape.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/server.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/server.js"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/server.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib';
// Load modules

var Boom = require('boom');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Hawk authentication

/*
   req:                 node's HTTP request object or an object as follows:
  
                        var request = {
                            method: 'GET',
                            url: '/resource/4?a=1&b=2',
                            host: 'example.com',
                            port: 8080,
                            authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
                        };
  
   credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
                        The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
                        needed by the application. This function is the equivalent of verifying the username and
                        password in Basic authentication.
  
                        var credentialsFunc = function (id, callback) {
    
                            // Lookup credentials in database
                            db.lookup(id, function (err, item) {
    
                                if (err || !item) {
                                    return callback(err);
                                }
    
                                var credentials = {
                                    // Required
                                    key: item.key,
                                    algorithm: item.algorithm,
                                    // Application specific
                                    user: item.user
                                };
    
                                return callback(null, credentials);
                            });
                        };
  
   options: {

        hostHeaderName:        optional header field name, used to override the default 'Host' header when used
                               behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
                               the original (which is what the module must verify) in the 'x-forwarded-host' header field.
                               Only used when passed a node Http.ServerRequest object.
  
        nonceFunc:             optional nonce validation function. The function signature is function(nonce, ts, callback)
                               where 'callback' must be called using the signature function(err).
  
        timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
                               Provides a +/- skew which means actual allowed window is double the number of seconds.
  
        localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
                               Defaults to 0.
  
        payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
                               header attribute. The server always ensures the value provided has been included in the request
                               MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
                               a hash value over the entire payload (assuming it has already be normalized to the same format and
                               encoding used by the client to calculate the hash on request). If the payload is not available at the time
                               of authentication, the authenticatePayload() method can be used by passing it the credentials and
                               attributes.hash returned in the authenticate callback.
    }

    callback: function (err, credentials, artifacts) { }
 */

exports.authenticate = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);
    
    // Default options

    options.nonceFunc = options.nonceFunc || function (nonce, ts, nonceCallback) { return nonceCallback(); };   // No validation
    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Parse HTTP Authorization header

    var attributes = Utils.parseAuthorizationHeader(request.authorization);
    if (attributes instanceof Error) {
        return callback(attributes);
    }

    // Construct artifacts container

    var artifacts = {
        method: request.method,
        host: request.host,
        port: request.port,
        resource: request.url,
        ts: attributes.ts,
        nonce: attributes.nonce,
        hash: attributes.hash,
        ext: attributes.ext,
        app: attributes.app,
        dlg: attributes.dlg,
        mac: attributes.mac,
        id: attributes.id
    };

    // Verify required header attributes

    if (!attributes.id ||
        !attributes.ts ||
        !attributes.nonce ||
        !attributes.mac) {

        return callback(Boom.badRequest('Missing attributes'), null, artifacts);
    }

    // Fetch Hawk credentials

    credentialsFunc(attributes.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, artifacts);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('header', credentials, artifacts);
        if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
        }

        // Check payload hash

        if (options.payload !== null &&
            options.payload !== undefined) {       // '' is valid

            if (!attributes.hash) {
                return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
            }

            var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
            if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
                return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
            }
        }

        // Check nonce

        options.nonceFunc(attributes.nonce, attributes.ts, function (err) {

            if (err) {
                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
            }

            // Check timestamp staleness

            if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                var fresh = Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);            // Get fresh now
                var tsm = Crypto.calculateTsMac(fresh, credentials);
                return callback(Boom.unauthorized('Stale timestamp', 'Hawk', { ts: fresh, tsm: tsm }), credentials, artifacts);
            }

            // Successful authentication

            return callback(null, credentials, artifacts);
        });
    });
};


// Authenticate payload hash - used when payload cannot be provided during authenticate()

/*
    payload:        raw request payload
    credentials:    from authenticate callback
    artifacts:      from authenticate callback
    contentType:    req.headers['content-type']
*/

exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {

    var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
    return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
};


// Generate a Server-Authorization header for a given response

/*
    credentials: {},                                        // Object received from authenticate()
    artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
    options: {
        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
    }
*/

exports.header = function (credentials, artifacts, options) {

    // Prepare inputs

    options = options || {};

    if (!artifacts ||
        typeof artifacts !== 'object' ||
        typeof options !== 'object') {

        return '';
    }

    artifacts = Hoek.clone(artifacts);
    delete artifacts.mac;
    artifacts.hash = options.hash;
    artifacts.ext = options.ext;

    // Validate credentials

    if (!credentials ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('response', credentials, artifacts);

    // Construct header

    var header = 'Hawk mac="' + mac + '"' +
                 (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');

    if (artifacts.ext !== null &&
        artifacts.ext !== undefined &&
        artifacts.ext !== '') {                       // Other falsey values allowed

        header += ', ext="' + Utils.escapeHeaderAttribute(artifacts.ext) + '"';
    }

    return header;
};


/*
 * Arguments and options are the same as index.js with the exception that the only supported options are:
 * 'hostHeaderName', 'localtimeOffsetMsec'
 */

exports.authenticateBewit = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Extract bewit

    //                                 1     2             3           4     
    var resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/);
    if (!resource) {
        return callback(Boom.unauthorized(null, 'Hawk'));
    }

    // Bewit not empty

    if (!resource[3]) {
        return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
    }

    // Verify method is GET

    if (request.method !== 'GET' &&
        request.method !== 'HEAD') {

        return callback(Boom.unauthorized('Invalid method', 'Hawk'));
    }

    // No other authentication

    if (request.authorization) {
        return callback(Boom.badRequest('Multiple authentications', 'Hawk'));
    }

    // Parse bewit

    var bewitString = Utils.base64urlDecode(resource[3]);
    if (bewitString instanceof Error) {
        return callback(Boom.badRequest('Invalid bewit encoding'));
    }

    // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)

    var bewitParts = bewitString.split('\\');
    if (!bewitParts ||
        bewitParts.length !== 4) {

        return callback(Boom.badRequest('Invalid bewit structure'));
    }

    var bewit = {
        id: bewitParts[0],
        exp: parseInt(bewitParts[1], 10),
        mac: bewitParts[2],
        ext: bewitParts[3] || ''
    };

    if (!bewit.id ||
        !bewit.exp ||
        !bewit.mac) {

        return callback(Boom.badRequest('Missing bewit attributes'));
    }

    // Construct URL without bewit

    var url = resource[1];
    if (resource[4]) {
        url += resource[2] + resource[4];
    }

    // Check expiration

    if (bewit.exp * 1000 <= now) {
        return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
    }

    // Fetch Hawk credentials

    credentialsFunc(bewit.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, bewit.ext);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, bewit);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('bewit', credentials, {
            ts: bewit.exp,
            nonce: '',
            method: 'GET',
            resource: url,
            host: request.host,
            port: request.port,
            ext: bewit.ext
        });

        if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
        }

        // Successful authentication

        return callback(null, credentials, bewit);
    });
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/server.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/index.js"}
require.memoize("5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/lib/index.js"}
require.memoize("5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/lib';
// Load modules

var Fs = require('__SYSTEM__/fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        source.forEach(function (item) {

            target.push(item);
        });

        return target;
    }

    Object.keys(source).forEach(function (key) {

        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    });

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return common;
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    path.forEach(function (level) {

        if (ref) {
            ref = ref[level];
        }
    });

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    stack.forEach(function (item) {

        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    });

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];
    trace.forEach(function (row) {

        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    });

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    Fs.readdirSync(path).forEach(function (filename) {

        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    });
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/lib/escape.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/lib/escape.js"}
require.memoize("5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/lib/escape.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/lib';
// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/lib/escape.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/index.js"}
require.memoize("8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/lib/index.js"}
require.memoize("8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles/lib';
// Load modules

var Crypto = require('__SYSTEM__/crypto');
var Boom = require('boom');


// Declare internals

var internals = {};


// Generate a cryptographically strong pseudo-random data

exports.randomString = function (size) {

    var buffer = exports.randomBits((size + 1) * 6);
    if (buffer instanceof Error) {
        return buffer;
    }

    var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
};


exports.randomBits = function (bits) {

    if (!bits ||
        bits < 0) {

        return Boom.internal('Invalid random bits count');
    }

    var bytes = Math.ceil(bits / 8);
    try {
        return Crypto.randomBytes(bytes);
    }
    catch (err) {
        return Boom.internal('Failed generating random bits: ' + err.message);
    }
};


// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)

exports.fixedTimeComparison = function (a, b) {

    if (typeof a !== 'string' ||
        typeof b !== 'string') {

        return false;
    }

    var mismatch = (a.length === b.length ? 0 : 1);
    if (mismatch) {
        b = a;
    }

    for (var i = 0, il = a.length; i < il; ++i) {
        var ac = a.charCodeAt(i);
        var bc = b.charCodeAt(i);
        mismatch += (ac === bc ? 0 : 1);
    }

    return (mismatch === 0);
};



}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/crypto.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/crypto.js"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/crypto.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib';
// Load modules

var Crypto = require('__SYSTEM__/crypto');
var Url = require('__SYSTEM__/url');
var Utils = require('./utils');


// Declare internals

var internals = {};


// MAC normalization format version

exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats


// Supported HMAC algorithms

exports.algorithms = ['sha1', 'sha256'];


// Calculate the request MAC

/*
    type: 'header',                                 // 'header', 'bewit', 'response'
    credentials: {
        key: 'aoijedoaijsdlaksjdl',
        algorithm: 'sha256'                         // 'sha1', 'sha256'
    },
    options: {
        method: 'GET',
        resource: '/resource?a=1&b=2',
        host: 'example.com',
        port: 8080,
        ts: 1357718381034,
        nonce: 'd3d345f',
        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
        ext: 'app-specific-data',
        app: 'hf48hd83qwkj',                        // Application id (Oz)
        dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
    }
*/

exports.calculateMac = function (type, credentials, options) {

    var normalized = exports.generateNormalizedString(type, options);

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest('base64');
    return digest;
};


exports.generateNormalizedString = function (type, options) {

    var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
                     options.ts + '\n' +
                     options.nonce + '\n' +
                     options.method.toUpperCase() + '\n' +
                     options.resource + '\n' +
                     options.host.toLowerCase() + '\n' +
                     options.port + '\n' +
                     (options.hash || '') + '\n';

    if (options.ext) {
        normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
    }

    normalized += '\n';

    if (options.app) {
        normalized += options.app + '\n' +
                      (options.dlg || '') + '\n';
    }

    return normalized;
};


exports.calculatePayloadHash = function (payload, algorithm, contentType) {

    var hash = exports.initializePayloadHash(algorithm, contentType);
    hash.update(payload || '');
    return exports.finalizePayloadHash(hash);
};


exports.initializePayloadHash = function (algorithm, contentType) {

    var hash = Crypto.createHash(algorithm);
    hash.update('hawk.' + exports.headerVersion + '.payload\n');
    hash.update(Utils.parseContentType(contentType) + '\n');
    return hash;
};


exports.finalizePayloadHash = function (hash) {

    hash.update('\n');
    return hash.digest('base64');
};


exports.calculateTsMac = function (ts, credentials) {

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
    hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
    return hmac.digest('base64');
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/crypto.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/utils.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/utils.js"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/utils.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib';
// Load modules

var Hoek = require('hoek');
var Sntp = require('sntp');
var Boom = require('boom');


// Declare internals

var internals = {};


// Import Hoek Utilities

internals.import = function () {

    for (var i in Hoek) {
        if (Hoek.hasOwnProperty(i)) {
            exports[i] = Hoek[i];
        }
    }
};

internals.import();


// Hawk version

exports.version = function () {

    return exports.loadPackage(__dirname + '/..').version;
};


// Extract host and port from request

exports.parseHost = function (req, hostHeaderName) {

    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
    var hostHeader = req.headers[hostHeaderName];
    if (!hostHeader) {
        return null;
    }

    var hostHeaderRegex = /^(?:(?:\r\n)?[\t ])*([^:]+)(?::(\d+))?(?:(?:\r\n)?[\t ])*$/;     // Does not support IPv6
    var hostParts = hostHeader.match(hostHeaderRegex);

    if (!hostParts ||
        hostParts.length !== 3 ||
        !hostParts[1]) {

        return null;
    }

    return {
        name: hostParts[1],
        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
    };
};


// Parse Content-Type header content

exports.parseContentType = function (header) {

    if (!header) {
        return '';
    }

    return header.split(';')[0].trim().toLowerCase();
};


// Convert node's  to request configuration object

exports.parseRequest = function (req, options) {

    if (!req.headers) {
        return req;
    }

    // Obtain host and port information

    var host = exports.parseHost(req, options.hostHeaderName);
    if (!host) {
        return new Error('Invalid Host header');
    }

    var request = {
        method: req.method,
        url: req.url,
        host: host.name,
        port: host.port,
        authorization: req.headers.authorization,
        contentType: req.headers['content-type'] || ''
    };

    return request;
};


exports.now = function () {

    return Sntp.now();
};


// Parse Hawk HTTP Authorization header

exports.parseAuthorizationHeader = function (header, keys) {

    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];

    if (!header) {
        return Boom.unauthorized(null, 'Hawk');
    }

    var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
    if (!headerParts) {
        return Boom.badRequest('Invalid header syntax');
    }

    var scheme = headerParts[1];
    if (scheme.toLowerCase() !== 'hawk') {
        return Boom.unauthorized(null, 'Hawk');
    }

    var attributesString = headerParts[2];
    if (!attributesString) {
        return Boom.badRequest('Invalid header syntax');
    }

    var attributes = {};
    var errorMessage = '';
    var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {

        // Check valid attribute names

        if (keys.indexOf($1) === -1) {
            errorMessage = 'Unknown attribute: ' + $1;
            return;
        }

        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9

        if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
            errorMessage = 'Bad attribute value: ' + $1;
            return;
        }

        // Check for duplicates

        if (attributes.hasOwnProperty($1)) {
            errorMessage = 'Duplicate attribute: ' + $1;
            return;
        }

        attributes[$1] = $2;
        return '';
    });

    if (verify !== '') {
        return Boom.badRequest(errorMessage || 'Bad header format');
    }

    return attributes;
};


exports.unauthorized = function (message) {

    return Boom.unauthorized(message, 'Hawk');
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/utils.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/client.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/client.js"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/lib/client.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib';
// Load modules

var Url = require('__SYSTEM__/url');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Generate an Authorization header for a given request

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    method: HTTP verb (e.g. 'GET', 'POST')
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                                 // 'sha1', 'sha256'
        },

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        timestamp: Date.now(),                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
        app: '24s23423f34dx',                               // Oz application id
        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
    }
*/

exports.header = function (uri, method, options) {

    var result = {
        field: '',
        artifacts: {}
    };

    // Validate inputs

    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
        !method || typeof method !== 'string' ||
        !options || typeof options !== 'object') {

        return result;
    }

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000)

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return result;
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return result;
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        method: method,
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        hash: options.hash,
        ext: options.ext,
        app: options.app,
        dlg: options.dlg
    };

    result.artifacts = artifacts;

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('header', credentials, artifacts);

    // Construct header

    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
    var header = 'Hawk id="' + credentials.id +
                 '", ts="' + artifacts.ts +
                 '", nonce="' + artifacts.nonce +
                 (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                 (hasExt ? '", ext="' + Utils.escapeHeaderAttribute(artifacts.ext) : '') +
                 '", mac="' + mac + '"';

    if (artifacts.app) {
        header += ', app="' + artifacts.app +
                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
    }

    result.field = header;

    return result;
};


// Validate server response

/*
    res:        node's response object
    artifacts:  object recieved from header().artifacts
    options: {
        payload:    optional payload received
        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
    }
*/

exports.authenticate = function (res, credentials, artifacts, options) {

    artifacts = Hoek.clone(artifacts);
    options = options || {};

    if (res.headers['www-authenticate']) {

        // Parse HTTP WWW-Authenticate header

        var attributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
        if (attributes instanceof Error) {
            return false;
        }

        if (attributes.ts) {
            var tsm = Crypto.calculateTsMac(attributes.ts, credentials);
            if (tsm !== attributes.tsm) {
                return false;
            }
        }
    }

    // Parse HTTP Server-Authorization header

    if (!res.headers['server-authorization'] &&
        !options.required) {

        return true;
    }

    var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
    if (attributes instanceof Error) {
        return false;
    }

    artifacts.ext = attributes.ext;
    artifacts.hash = attributes.hash;

    var mac = Crypto.calculateMac('response', credentials, artifacts);
    if (mac !== attributes.mac) {
        return false;
    }

    if (!options.hasOwnProperty('payload')) {
        return true;
    }

    if (!attributes.hash) {
        return false;
    }

    var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
    return (calculatedHash === attributes.hash);
};


// Generate a bewit value for a given URI

/*
 * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
 * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'
 */
/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        },
        ttlSec: 60 * 60,                                    // TTL in seconds

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        localtimeOffsetMsec: 400                            // Time offset to sync with server time
    };
*/

exports.getBewit = function (uri, options) {

    // Validate inputs

    if (!uri ||
        (typeof uri !== 'string' && typeof uri !== 'object') ||
        !options ||
        typeof options !== 'object' ||
        !options.ttlSec) {

        return '';
    }

    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var exp = Math.floor(now / 1000) + options.ttlSec;
    var mac = Crypto.calculateMac('bewit', credentials, {
        ts: exp,
        nonce: '',
        method: 'GET',
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        ext: options.ext
    });

    // Construct bewit: id\exp\mac\ext

    var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
    return Utils.base64urlEncode(bewit);
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/lib/client.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/aws-sign/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"8d0d8b76fc7fb074fae1f24236fc2c5c9db07428-aws-sign/index.js"}
require.memoize("8d0d8b76fc7fb074fae1f24236fc2c5c9db07428-aws-sign/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/aws-sign';

/*!
 * knox - auth
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var crypto = require('__SYSTEM__/crypto')
  , parse = require('__SYSTEM__/url').parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ]

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options) {
  return 'AWS ' + options.key + ':' + sign(options)
}

module.exports = authorization
module.exports.authorization = authorization

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options) {
  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

module.exports.hmacSha1 = hmacSha1

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign (options) {
  options.message = stringToSign(options)
  return hmacSha1(options)
}
module.exports.sign = sign

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options) {
  options.message = queryStringToSign(options)
  return hmacSha1(options)
}
module.exports.signQuery= signQuery

/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options) {
  var headers = options.amazonHeaders || ''
  if (headers) headers += '\n'
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date.toUTCString()
    , headers + options.resource
    ]
  return r.join('\n')
}
module.exports.queryStringToSign = stringToSign

/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options){
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers) {
  var buf = []
    , fields = Object.keys(headers)
    ;
  for (var i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase()
      ;
    if (0 !== field.indexOf('x-amz')) continue
    buf.push(field + ':' + val)
  }
  return buf.sort().join('\n')
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource) {
  var url = parse(resource, true)
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query).forEach(function(key){
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
    buf.push(key + val)
  })

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
module.exports.canonicalizeResource = canonicalizeResource

return {
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    require: (typeof require !== "undefined") ? require : null,
    parse: (typeof parse !== "undefined") ? parse : null,
    keys: (typeof keys !== "undefined") ? keys : null,
    authorization: (typeof authorization !== "undefined") ? authorization : null,
    sign: (typeof sign !== "undefined") ? sign : null,
    module: (typeof module !== "undefined") ? module : null,
    hmacSha1: (typeof hmacSha1 !== "undefined") ? hmacSha1 : null,
    stringToSign: (typeof stringToSign !== "undefined") ? stringToSign : null,
    signQuery: (typeof signQuery !== "undefined") ? signQuery : null,
    queryStringToSign: (typeof queryStringToSign !== "undefined") ? queryStringToSign : null,
    canonicalizeHeaders: (typeof canonicalizeHeaders !== "undefined") ? canonicalizeHeaders : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    canonicalizeResource: (typeof canonicalizeResource !== "undefined") ? canonicalizeResource : null,
    encodeURIComponent: (typeof encodeURIComponent !== "undefined") ? encodeURIComponent : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/aws-sign/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/index.js"}
require.memoize("504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib';
// Copyright 2011 Joyent, Inc.  All rights reserved.

var parser = require('./parser');
var signer = require('./signer');
var verify = require('./verify');
var util = require('./util');



///--- API

module.exports = {

  parse: parser.parseRequest,
  parseRequest: parser.parseRequest,

  sign: signer.signRequest,
  signRequest: signer.signRequest,

  sshKeyToPEM: util.sshKeyToPEM,
  sshKeyFingerprint: util.fingerprint,

  verify: verify.verifySignature,
  verifySignature: verify.verifySignature
};

return {
    parser: (typeof parser !== "undefined") ? parser : null,
    require: (typeof require !== "undefined") ? require : null,
    signer: (typeof signer !== "undefined") ? signer : null,
    verify: (typeof verify !== "undefined") ? verify : null,
    util: (typeof util !== "undefined") ? util : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/parser.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/parser.js"}
require.memoize("504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/parser.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib';
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var util = require('__SYSTEM__/util');



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var State = {
  New: 0,
  Params: 1,
  Signature: 2
};

var ParamsState = {
  Name: 0,
  Value: 1
};



///--- Specific Errors

function HttpSignatureError(message, caller) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, caller || HttpSignatureError);

  this.message = message;
  this.name = caller.name;
}
util.inherits(HttpSignatureError, Error);

function ExpiredRequestError(message) {
  HttpSignatureError.call(this, message, ExpiredRequestError);
}
util.inherits(ExpiredRequestError, HttpSignatureError);


function InvalidHeaderError(message) {
  HttpSignatureError.call(this, message, InvalidHeaderError);
}
util.inherits(InvalidHeaderError, HttpSignatureError);


function InvalidParamsError(message) {
  HttpSignatureError.call(this, message, InvalidParamsError);
}
util.inherits(InvalidParamsError, HttpSignatureError);


function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);



///--- Exported API

module.exports = {

  /**
   * Parses the 'Authorization' header out of an http.ServerRequest object.
   *
   * Note that this API will fully validate the Authorization header, and throw
   * on any error.  It will not however check the signature, or the keyId format
   * as those are specific to your environment.  You can use the options object
   * to pass in extra constraints.
   *
   * As a response object you can expect this:
   *
   *     {
   *       "scheme": "Signature",
   *       "params": {
   *         "keyId": "foo",
   *         "algorithm": "rsa-sha256",
   *         "headers": [
   *           "date" or "x-date",
   *           "content-md5"
   *         ]
   *       },
   *       "signature": "base64",
   *       "signingString": "ready to be passed to crypto.verify()"
   *     }
   *
   * @param {Object} request an http.ServerRequest.
   * @param {Object} options an optional options object with:
   *                   - clockSkew: allowed clock skew in seconds (default 300).
   *                   - headers: required header names (def: date or x-date)
   *                   - algorithms: algorithms to support (default: all).
   * @return {Object} parsed out object (see above).
   * @throws {TypeError} on invalid input.
   * @throws {InvalidHeaderError} on an invalid Authorization header error.
   * @throws {InvalidParamsError} if the params in the scheme are invalid.
   * @throws {MissingHeaderError} if the params indicate a header not present,
   *                              either in the request headers from the params,
   *                              or not in the params from a required header
   *                              in options.
   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
   */
  parseRequest: function parseRequest(request, options) {
    assert.object(request, 'request');
    assert.object(request.headers, 'request.headers');
    if (options === undefined) {
      options = {};
    }
    if (options.headers === undefined) {
      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
    }
    assert.object(options, 'options');
    assert.arrayOfString(options.headers, 'options.headers');
    assert.optionalNumber(options.clockSkew, 'options.clockSkew');

    if (!request.headers.authorization)
      throw new MissingHeaderError('no authorization header present in ' +
                                   'the request');

    options.clockSkew = options.clockSkew || 300;


    var i = 0;
    var state = State.New;
    var substate = ParamsState.Name;
    var tmpName = '';
    var tmpValue = '';

    var parsed = {
      scheme: '',
      params: {},
      signature: '',
      signingString: '',

      get algorithm() {
        return this.params.algorithm.toUpperCase();
      },

      get keyId() {
        return this.params.keyId;
      }

    };

    var authz = request.headers.authorization;
    for (i = 0; i < authz.length; i++) {
      var c = authz.charAt(i);

      switch (Number(state)) {

      case State.New:
        if (c !== ' ') parsed.scheme += c;
        else state = State.Params;
        break;

      case State.Params:
        switch (Number(substate)) {

        case ParamsState.Name:
          if (c === '"') {
            parsed.params[tmpName] = '';
            tmpValue = '';
            substate = ParamsState.Value;
          } else if (c === ' ') {
            state = State.Signature;
          } else if (c !== '=' && c !== ',') {
            tmpName += c;
          }
          break;

        case ParamsState.Value:
          if (c === '"') {
            parsed.params[tmpName] = tmpValue;
            tmpName = '';
            substate = ParamsState.Name;
          } else {
            tmpValue += c;
          }
          break;

        default:
          throw new Error('Invalid substate');
        }
        break;


      case State.Signature:
        parsed.signature += c;
        break;

      default:
        throw new Error('Invalid substate');
      }

    }

    if (!parsed.params.headers || parsed.params.headers === '') {
      if (request.headers['x-date']) {
        parsed.params.headers = ['x-date'];
      } else {
        parsed.params.headers = ['date'];
      }
    } else {
      parsed.params.headers = parsed.params.headers.split(' ');
    }

    // Minimally validate the parsed object
    if (!parsed.scheme || parsed.scheme !== 'Signature')
      throw new InvalidHeaderError('scheme was not "Signature"');

    if (!parsed.params.keyId)
      throw new InvalidHeaderError('keyId was not specified');

    if (!parsed.params.algorithm)
      throw new InvalidHeaderError('algorithm was not specified');

    if (!parsed.signature)
      throw new InvalidHeaderError('signature was empty');

    // Check the algorithm against the official list
    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
    if (!Algorithms[parsed.params.algorithm])
      throw new InvalidParamsError(parsed.params.algorithm +
                                   ' is not supported');

    // Build the signingString
    for (i = 0; i < parsed.params.headers.length; i++) {
      var h = parsed.params.headers[i].toLowerCase();
      parsed.params.headers[i] = h;

      var value;
      if (h !== 'request-line') {
        value = request.headers[h];
        if (!value)
          throw new MissingHeaderError(h + ' was not in the request');
      } else {
        value =
          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
      }

      parsed.signingString += value;
      if ((i + 1) < parsed.params.headers.length)
        parsed.signingString += '\n';
    }

    // Check against the constraints
    var date;
    if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
      var now = new Date();
      var skew = Math.abs(now.getTime() - date.getTime());

      if (skew > options.clockSkew * 1000) {
        throw new ExpiredRequestError('clock skew of ' +
                                      (skew / 1000) +
                                      's was greater than ' +
                                      options.clockSkew + 's');
      }
    }

    options.headers.forEach(function (hdr) {
      // Remember that we already checked any headers in the params
      // were in the request, so if this passes we're good.
      if (parsed.params.headers.indexOf(hdr) < 0)
        throw new MissingHeaderError(hdr + ' was not a signed header');
    });

    if (options.algorithms) {
      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
        throw new InvalidParamsError(parsed.params.algorithm +
                                     ' is not a supported algorithm');
    }

    return parsed;
  }

};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    util: (typeof util !== "undefined") ? util : null,
    Algorithms: (typeof Algorithms !== "undefined") ? Algorithms : null,
    State: (typeof State !== "undefined") ? State : null,
    ParamsState: (typeof ParamsState !== "undefined") ? ParamsState : null,
    HttpSignatureError: (typeof HttpSignatureError !== "undefined") ? HttpSignatureError : null,
    Error: (typeof Error !== "undefined") ? Error : null,
    ExpiredRequestError: (typeof ExpiredRequestError !== "undefined") ? ExpiredRequestError : null,
    InvalidHeaderError: (typeof InvalidHeaderError !== "undefined") ? InvalidHeaderError : null,
    InvalidParamsError: (typeof InvalidParamsError !== "undefined") ? InvalidParamsError : null,
    MissingHeaderError: (typeof MissingHeaderError !== "undefined") ? MissingHeaderError : null,
    module: (typeof module !== "undefined") ? module : null,
    Number: (typeof Number !== "undefined") ? Number : null,
    Math: (typeof Math !== "undefined") ? Math : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/parser.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/assert-plus/assert.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"4577e8ae6126946aeedc02c249aefacb641b25de-assert-plus/assert.js"}
require.memoize("4577e8ae6126946aeedc02c249aefacb641b25de-assert-plus/assert.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/assert-plus';
// Copyright (c) 2012, Mark Cavage. All rights reserved.

var assert = require('__SYSTEM__/assert');
var Stream = require('__SYSTEM__/stream').Stream;
var util = require('__SYSTEM__/util');



///--- Globals

var NDEBUG = process.env.NODE_NDEBUG || false;



///--- Messages

var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
var TYPE_REQUIRED = '%s (%s) is required';



///--- Internal

function capitalize(str) {
        return (str.charAt(0).toUpperCase() + str.slice(1));
}

function uncapitalize(str) {
        return (str.charAt(0).toLowerCase() + str.slice(1));
}

function _() {
        return (util.format.apply(util, arguments));
}


function _assert(arg, type, name, stackFunc) {
        if (!NDEBUG) {
                name = name || type;
                stackFunc = stackFunc || _assert.caller;
                var t = typeof (arg);

                if (t !== type) {
                        throw new assert.AssertionError({
                                message: _(TYPE_REQUIRED, name, type),
                                actual: t,
                                expected: type,
                                operator: '===',
                                stackStartFunction: stackFunc
                        });
                }
        }
}



///--- API

function array(arr, type, name) {
        if (!NDEBUG) {
                name = name || type;

                if (!Array.isArray(arr)) {
                        throw new assert.AssertionError({
                                message: _(ARRAY_TYPE_REQUIRED, name, type),
                                actual: typeof (arr),
                                expected: 'array',
                                operator: 'Array.isArray',
                                stackStartFunction: array.caller
                        });
                }

                for (var i = 0; i < arr.length; i++) {
                        _assert(arr[i], type, name, array);
                }
        }
}


function bool(arg, name) {
        _assert(arg, 'boolean', name, bool);
}


function buffer(arg, name) {
        if (!Buffer.isBuffer(arg)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'buffer',
                        operator: 'Buffer.isBuffer',
                        stackStartFunction: buffer
                });
        }
}


function func(arg, name) {
        _assert(arg, 'function', name);
}


function number(arg, name) {
        _assert(arg, 'number', name);
}


function object(arg, name) {
        _assert(arg, 'object', name);
}


function stream(arg, name) {
        if (!(arg instanceof Stream)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'Stream',
                        operator: 'instanceof',
                        stackStartFunction: buffer
                });
        }
}


function string(arg, name) {
        _assert(arg, 'string', name);
}



///--- Exports

module.exports = {
        bool: bool,
        buffer: buffer,
        func: func,
        number: number,
        object: object,
        stream: stream,
        string: string
};


Object.keys(module.exports).forEach(function (k) {
        if (k === 'buffer')
                return;

        var name = 'arrayOf' + capitalize(k);

        if (k === 'bool')
                k = 'boolean';
        if (k === 'func')
                k = 'function';
        module.exports[name] = function (arg, name) {
                array(arg, k, name);
        };
});

Object.keys(module.exports).forEach(function (k) {
        var _name = 'optional' + capitalize(k);
        var s = uncapitalize(k.replace('arrayOf', ''));
        if (s === 'bool')
                s = 'boolean';
        if (s === 'func')
                s = 'function';

        if (k.indexOf('arrayOf') !== -1) {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          array(arg, s, name);
                  }
          };
        } else {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          _assert(arg, s, name);
                  }
          };
        }
});


// Reexport built-in assertions
Object.keys(assert).forEach(function (k) {
        if (k === 'AssertionError') {
                module.exports[k] = assert[k];
                return;
        }

        module.exports[k] = function () {
                if (!NDEBUG) {
                        assert[k].apply(assert[k], arguments);
                }
        };
});

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    Stream: (typeof Stream !== "undefined") ? Stream : null,
    util: (typeof util !== "undefined") ? util : null,
    NDEBUG: (typeof NDEBUG !== "undefined") ? NDEBUG : null,
    process: (typeof process !== "undefined") ? process : null,
    ARRAY_TYPE_REQUIRED: (typeof ARRAY_TYPE_REQUIRED !== "undefined") ? ARRAY_TYPE_REQUIRED : null,
    TYPE_REQUIRED: (typeof TYPE_REQUIRED !== "undefined") ? TYPE_REQUIRED : null,
    capitalize: (typeof capitalize !== "undefined") ? capitalize : null,
    uncapitalize: (typeof uncapitalize !== "undefined") ? uncapitalize : null,
    _: (typeof _ !== "undefined") ? _ : null,
    _assert: (typeof _assert !== "undefined") ? _assert : null,
    array: (typeof array !== "undefined") ? array : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    bool: (typeof bool !== "undefined") ? bool : null,
    buffer: (typeof buffer !== "undefined") ? buffer : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    func: (typeof func !== "undefined") ? func : null,
    number: (typeof number !== "undefined") ? number : null,
    object: (typeof object !== "undefined") ? object : null,
    stream: (typeof stream !== "undefined") ? stream : null,
    string: (typeof string !== "undefined") ? string : null,
    module: (typeof module !== "undefined") ? module : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/assert-plus/assert.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/signer.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/signer.js"}
require.memoize("504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/signer.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib';
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('__SYSTEM__/crypto');
var http = require('__SYSTEM__/http');

var sprintf = require('__SYSTEM__/util').format;



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var Authorization = 'Signature keyId="%s",algorithm="%s",headers="%s" %s';



///--- Specific Errors

function MissingHeaderError(message) {
    this.name = 'MissingHeaderError';
    this.message = message;
    this.stack = (new Error()).stack;
}
MissingHeaderError.prototype = new Error();


function InvalidAlgorithmError(message) {
    this.name = 'InvalidAlgorithmError';
    this.message = message;
    this.stack = (new Error()).stack;
}
InvalidAlgorithmError.prototype = new Error();



///--- Internal Functions

function _pad(val) {
  if (parseInt(val, 10) < 10) {
    val = '0' + val;
  }
  return val;
}


function _rfc1123() {
  var date = new Date();

  var months = ['Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'];
  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  return days[date.getUTCDay()] + ', ' +
    _pad(date.getUTCDate()) + ' ' +
    months[date.getUTCMonth()] + ' ' +
    date.getUTCFullYear() + ' ' +
    _pad(date.getUTCHours()) + ':' +
    _pad(date.getUTCMinutes()) + ':' +
    _pad(date.getUTCSeconds()) +
    ' GMT';
}



///--- Exported API

module.exports = {

  /**
   * Adds an 'Authorization' header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it's not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn't need to check the return type; it's just there if you want
   * to be pedantic.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to ['date'].
   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert.object(request, 'request');
    assert.object(options, 'options');
    assert.optionalString(options.algorithm, 'options.algorithm');
    assert.string(options.keyId, 'options.keyId');
    assert.optionalArrayOfString(options.headers, 'options.headers');

    if (!request.getHeader('Date'))
      request.setHeader('Date', _rfc1123());
    if (!options.headers)
      options.headers = ['date'];
    if (!options.algorithm)
      options.algorithm = 'rsa-sha256';

    options.algorithm = options.algorithm.toLowerCase();

    if (!Algorithms[options.algorithm])
      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');

    var i;
    var stringToSign = '';
    for (i = 0; i < options.headers.length; i++) {
      if (typeof (options.headers[i]) !== 'string')
        throw new TypeError('options.headers must be an array of Strings');

      var h = options.headers[i].toLowerCase();
      request.getHeader(h);

      var value = request.getHeader(h);
      if (!value) {
        if (h === 'request-line') {
          value = request.method + ' ' + request.path + ' HTTP/1.1';
        } else {
          throw new MissingHeaderError(h + ' was not in the request');
        }
      }

      stringToSign += value;
      if ((i + 1) < options.headers.length)
        stringToSign += '\n';
    }

    var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
    var signature;
    if (alg[1] === 'hmac') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest('base64');
    } else {
      var signer = crypto.createSign(options.algorithm.toUpperCase());
      signer.update(stringToSign);
      signature = signer.sign(options.key, 'base64');
    }

    request.setHeader('Authorization', sprintf(Authorization,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(' '),
                                               signature));

    return true;
  }

};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    http: (typeof http !== "undefined") ? http : null,
    sprintf: (typeof sprintf !== "undefined") ? sprintf : null,
    Algorithms: (typeof Algorithms !== "undefined") ? Algorithms : null,
    Authorization: (typeof Authorization !== "undefined") ? Authorization : null,
    MissingHeaderError: (typeof MissingHeaderError !== "undefined") ? MissingHeaderError : null,
    InvalidAlgorithmError: (typeof InvalidAlgorithmError !== "undefined") ? InvalidAlgorithmError : null,
    _pad: (typeof _pad !== "undefined") ? _pad : null,
    parseInt: (typeof parseInt !== "undefined") ? parseInt : null,
    _rfc1123: (typeof _rfc1123 !== "undefined") ? _rfc1123 : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/signer.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/verify.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/verify.js"}
require.memoize("504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/verify.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib';
// Copyright 2011 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('__SYSTEM__/crypto');



///--- Exported API

module.exports = {

  /**
   * Simply wraps up the node crypto operations for you, and returns
   * true or false.  You are expected to pass in an object that was
   * returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} key either an RSA private key PEM or HMAC secret.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   */
  verifySignature: function verifySignature(parsedSignature, key) {
    assert.object(parsedSignature, 'parsedSignature');
    assert.string(key, 'key');

    var alg = parsedSignature.algorithm.match(/(HMAC|RSA|DSA)-(\w+)/);
    if (!alg || alg.length !== 3)
      throw new TypeError('parsedSignature: unsupported algorithm ' +
                          parsedSignature.algorithm);

    if (alg[1] === 'HMAC') {
      var hmac = crypto.createHmac(alg[2].toLowerCase(), key);
      hmac.update(parsedSignature.signingString);
      return (hmac.digest('base64') === parsedSignature.signature);
    } else {
      var verify = crypto.createVerify(alg[0]);
      verify.update(parsedSignature.signingString);
      return verify.verify(key, parsedSignature.signature, 'base64');
    }
  }

};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/verify.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/util.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/util.js"}
require.memoize("504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/util.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib';
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('__SYSTEM__/crypto');

var asn1 = require('asn1');
var ctype = require('ctype');



///--- Helpers

function readNext(buffer, offset) {
  var len = ctype.ruint32(buffer, 'big', offset);
  offset += 4;

  var newOffset = offset + len;

  return {
    data: buffer.slice(offset, newOffset),
    offset: newOffset
  };
}


function writeInt(writer, buffer) {
  writer.writeByte(0x02); // ASN1.Integer
  writer.writeLength(buffer.length);

  for (var i = 0; i < buffer.length; i++)
    writer.writeByte(buffer[i]);

  return writer;
}


function rsaToPEM(key) {
  var buffer;
  var der;
  var exponent;
  var i;
  var modulus;
  var newKey = '';
  var offset = 0;
  var type;
  var tmp;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    if (type !== 'ssh-rsa')
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    exponent = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    modulus = tmp.data;
  } catch (e) {
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.113549.1.1.1');
  der.writeNull();
  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);

  // Actual key
  der.startSequence();
  writeInt(der, modulus);
  writeInt(der, exponent);
  der.endSequence();

  // bit string
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


function dsaToPEM(key) {
  var buffer;
  var offset = 0;
  var tmp;
  var der;
  var newKey = '';

  var type;
  var p;
  var q;
  var g;
  var y;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    /* JSSTYLED */
    if (!/^ssh-ds[as].*/.test(type))
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    p = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    q = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    g = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    y = tmp.data;
  } catch (e) {
    console.log(e.stack);
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.10040.4.1');

  der.startSequence();
  writeInt(der, p);
  writeInt(der, q);
  writeInt(der, g);
  der.endSequence();

  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);
  writeInt(der, y);
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (var i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


///--- API

module.exports = {

  /**
   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key) {
    assert.string(key, 'ssh_key');

    /* JSSTYLED */
    if (/^ssh-rsa.*/.test(key))
      return rsaToPEM(key);

    /* JSSTYLED */
    if (/^ssh-ds[as].*/.test(key))
      return dsaToPEM(key);

    throw new Error('Only RSA and DSA public keys are allowed');
  },


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key) {
    assert.string(key, 'ssh_key');

    var pieces = key.split(' ');
    if (!pieces || !pieces.length || pieces.length < 2)
      throw new Error('invalid ssh key');

    var data = new Buffer(pieces[1], 'base64');

    var hash = crypto.createHash('md5');
    hash.update(data);
    var digest = hash.digest('hex');

    var fp = '';
    for (var i = 0; i < digest.length; i++) {
      if (i && i % 2 === 0)
        fp += ':';

      fp += digest[i];
    }

    return fp;
  }


};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    asn1: (typeof asn1 !== "undefined") ? asn1 : null,
    ctype: (typeof ctype !== "undefined") ? ctype : null,
    readNext: (typeof readNext !== "undefined") ? readNext : null,
    writeInt: (typeof writeInt !== "undefined") ? writeInt : null,
    rsaToPEM: (typeof rsaToPEM !== "undefined") ? rsaToPEM : null,
    dsaToPEM: (typeof dsaToPEM !== "undefined") ? dsaToPEM : null,
    console: (typeof console !== "undefined") ? console : null,
    i: (typeof i !== "undefined") ? i : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/lib/util.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/index.js"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

var Ber = require('./ber/index');



///--- Exported API

module.exports = {

  Ber: Ber,

  BerReader: Ber.Reader,

  BerWriter: Ber.Writer

};

return {
    Ber: (typeof Ber !== "undefined") ? Ber : null,
    require: (typeof require !== "undefined") ? require : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/index.js"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var errors = require('./errors');
var types = require('./types');

var Reader = require('./reader');
var Writer = require('./writer');


///--- Exports

module.exports = {

  Reader: Reader,

  Writer: Writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}

return {
    errors: (typeof errors !== "undefined") ? errors : null,
    require: (typeof require !== "undefined") ? require : null,
    types: (typeof types !== "undefined") ? types : null,
    Reader: (typeof Reader !== "undefined") ? Reader : null,
    Writer: (typeof Writer !== "undefined") ? Writer : null,
    module: (typeof module !== "undefined") ? module : null,
    t: (typeof t !== "undefined") ? t : null,
    e: (typeof e !== "undefined") ? e : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/errors.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/errors.js"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/errors.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {

  newInvalidAsn1Error: function(msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};

return {
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/errors.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/types.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/types.js"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/types.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};

return {
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/types.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/reader.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/reader.js"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/reader.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('__SYSTEM__/assert');

var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



///--- API

function Reader(data) {
  if (!data || !Buffer.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;

  var self = this;
  this.__defineGetter__('length', function() { return self._len; });
  this.__defineGetter__('offset', function() { return self._offset; });
  this.__defineGetter__('remain', function() {
    return self._size - self._offset;
  });
  this.__defineGetter__('buffer', function() {
    return self._buf.slice(self._offset);
  });
}


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function(peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function() {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function(offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) == 0x80) {
    lenB &= 0x7f;

    if (lenB == 0)
      throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function(tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function() {
  return this._readTag(ASN1.Integer);
};


Reader.prototype.readBoolean = function() {
  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function() {
  return this._readTag(ASN1.Enumeration);
};


Reader.prototype.readString = function(tag, retbuf) {
  if (!tag)
    tag = ASN1.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function(tag) {
  if (!tag)
    tag = ASN1.OID;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  var values = [];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    var byte = this._buf[this._offset++] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) == 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function(tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset++];
  var value = 0;

  value = fb & 0x7F;
  for (var i = 1; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) == 0x80)
    value = -value;

  return value;
};



///--- Exported API

module.exports = Reader;

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    ASN1: (typeof ASN1 !== "undefined") ? ASN1 : null,
    errors: (typeof errors !== "undefined") ? errors : null,
    newInvalidAsn1Error: (typeof newInvalidAsn1Error !== "undefined") ? newInvalidAsn1Error : null,
    Reader: (typeof Reader !== "undefined") ? Reader : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/reader.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/writer.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/writer.js"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/ber/writer.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('__SYSTEM__/assert');
var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


///--- Helpers

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof(from), 'object');
  assert.ok(to);
  assert.equal(typeof(to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function(key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



///--- API

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = new Buffer(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];

  var self = this;
  this.__defineGetter__('buffer', function() {
    if (self._seq.length)
      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');

    return self._buf.slice(0, self._offset);
  });
}


Writer.prototype.writeByte = function(b) {
  if (typeof(b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&
         (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function() {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function(b, tag) {
  if (typeof(b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof(tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
  if (typeof(tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function(buf, tag) {
  if (typeof(tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function(strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function(s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof(tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function(len) {
  if (typeof(len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function(tag) {
  if (typeof(tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function() {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw new InvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function(start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function(len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = new Buffer(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



///--- Exported API

module.exports = Writer;

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    ASN1: (typeof ASN1 !== "undefined") ? ASN1 : null,
    errors: (typeof errors !== "undefined") ? errors : null,
    newInvalidAsn1Error: (typeof newInvalidAsn1Error !== "undefined") ? newInvalidAsn1Error : null,
    DEFAULT_OPTS: (typeof DEFAULT_OPTS !== "undefined") ? DEFAULT_OPTS : null,
    merge: (typeof merge !== "undefined") ? merge : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    Writer: (typeof Writer !== "undefined") ? Writer : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    parseInt: (typeof parseInt !== "undefined") ? parseInt : null,
    start: (typeof start !== "undefined") ? start : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/writer.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/ctype.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctype.js"}
require.memoize("59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctype.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype';
/*
 * rm - Feb 2011
 * ctype.js
 *
 * This module provides a simple abstraction towards reading and writing
 * different types of binary data. It is designed to use ctio.js and provide a
 * richer and more expressive API on top of it.
 *
 * By default we support the following as built in basic types:
 *	int8_t
 *	int16_t
 *	int32_t
 *	uint8_t
 *	uint16_t
 *	uint32_t
 *	uint64_t
 *	float
 *	double
 *	char
 *	char[]
 *
 * Each type is returned as a Number, with the exception of char and char[]
 * which are returned as Node Buffers. A char is considered a uint8_t.
 *
 * Requests to read and write data are specified as an array of JSON objects.
 * This is also the same way that one declares structs. Even if just a single
 * value is requested, it must be done as a struct. The array order determines
 * the order that we try and read values. Each entry has the following format
 * with values marked with a * being optional.
 *
 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
 *
 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
 * value. Value is defined when we're writing out data, otherwise it's ignored.
 *
 */

var mod_ctf = require('./ctf.js');
var mod_ctio = require('./ctio.js');
var mod_assert = require('__SYSTEM__/assert');

/*
 * This is the set of basic types that we support.
 *
 *	read		The function to call to read in a value from a buffer
 *
 *	write		The function to call to write a value to a buffer
 *
 */
var deftypes = {
    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
    'float': { read: ctReadFloat, write: ctWriteFloat },
    'double': { read: ctReadDouble, write: ctWriteDouble },
    'char': { read: ctReadChar, write: ctWriteChar },
    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
};

/*
 * The following are wrappers around the CType IO low level API. They encode
 * knowledge about the size and return something in the expected format.
 */
function ctReadUint8(endian, buffer, offset)
{
	var val = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadUint16(endian, buffer, offset)
{
	var val = mod_ctio.ruint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadUint32(endian, buffer, offset)
{
	var val = mod_ctio.ruint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadUint64(endian, buffer, offset)
{
	var val = mod_ctio.ruint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadSint8(endian, buffer, offset)
{
	var val = mod_ctio.rsint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadSint16(endian, buffer, offset)
{
	var val = mod_ctio.rsint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadSint32(endian, buffer, offset)
{
	var val = mod_ctio.rsint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadSint64(endian, buffer, offset)
{
	var val = mod_ctio.rsint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadFloat(endian, buffer, offset)
{
	var val = mod_ctio.rfloat(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadDouble(endian, buffer, offset)
{
	var val = mod_ctio.rdouble(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

/*
 * Reads a single character into a node buffer
 */
function ctReadChar(endian, buffer, offset)
{
	var res = new Buffer(1);
	res[0] = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: res, size: 1 });
}

function ctReadCharArray(length, endian, buffer, offset)
{
	var ii;
	var res = new Buffer(length);

	for (ii = 0; ii < length; ii++)
		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

	return ({ value: res, size: length });
}

function ctWriteUint8(value, endian, buffer, offset)
{
	mod_ctio.wuint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteUint16(value, endian, buffer, offset)
{
	mod_ctio.wuint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteUint32(value, endian, buffer, offset)
{
	mod_ctio.wuint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteUint64(value, endian, buffer, offset)
{
	mod_ctio.wuint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteSint8(value, endian, buffer, offset)
{
	mod_ctio.wsint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteSint16(value, endian, buffer, offset)
{
	mod_ctio.wsint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteSint32(value, endian, buffer, offset)
{
	mod_ctio.wsint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteSint64(value, endian, buffer, offset)
{
	mod_ctio.wsint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteFloat(value, endian, buffer, offset)
{
	mod_ctio.wfloat(value, endian, buffer, offset);
	return (4);
}

function ctWriteDouble(value, endian, buffer, offset)
{
	mod_ctio.wdouble(value, endian, buffer, offset);
	return (8);
}

/*
 * Writes a single character into a node buffer
 */
function ctWriteChar(value, endian, buffer, offset)
{
	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	mod_ctio.ruint8(value[0], endian, buffer, offset);
	return (1);
}

/*
 * We're going to write 0s into the buffer if the string is shorter than the
 * length of the array.
 */
function ctWriteCharArray(value, length, endian, buffer, offset)
{
	var ii;

	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	if (value.length > length)
		throw (new Error('value length greater than array length'));

	for (ii = 0; ii < value.length && ii < length; ii++)
		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

	for (; ii < length; ii++)
		mod_ctio.wuint8(0, endian, offset + ii);


	return (length);
}

/*
 * Each parser has their own set of types. We want to make sure that they each
 * get their own copy as they may need to modify it.
 */
function ctGetBasicTypes()
{
	var ret = {};
	var key;
	for (key in deftypes)
		ret[key] = deftypes[key];

	return (ret);
}

/*
 * Given a string in the form of type[length] we want to split this into an
 * object that extracts that information. We want to note that we could possibly
 * have nested arrays so this should only check the furthest one. It may also be
 * the case that we have no [] pieces, in which case we just return the current
 * type.
 */
function ctParseType(str)
{
	var begInd, endInd;
	var type, len;
	if (typeof (str) != 'string')
		throw (new Error('type must be a Javascript string'));

	endInd = str.lastIndexOf(']');
	if (endInd == -1) {
		if (str.lastIndexOf('[') != -1)
			throw (new Error('found invalid type with \'[\' but ' +
			    'no corresponding \']\''));

		return ({ type: str });
	}

	begInd = str.lastIndexOf('[');
	if (begInd == -1)
		throw (new Error('found invalid type with \']\' but ' +
		    'no corresponding \'[\''));

	if (begInd >= endInd)
		throw (new Error('malformed type, \']\' appears before \'[\''));

	type = str.substring(0, begInd);
	len = str.substring(begInd + 1, endInd);

	return ({ type: type, len: len });
}

/*
 * Given a request validate that all of the fields for it are valid and make
 * sense. This includes verifying the following notions:
 *  - Each type requested is present in types
 *  - Only allow a name for a field to be specified once
 *  - If an array is specified, validate that the requested field exists and
 *    comes before it.
 *  - If fields is defined, check that each entry has the occurrence of field
 */
function ctCheckReq(def, types, fields)
{
	var ii, jj;
	var req, keys, key;
	var found = {};

	if (!(def instanceof Array))
		throw (new Error('definition is not an array'));

	if (def.length === 0)
		throw (new Error('definition must have at least one element'));

	for (ii = 0; ii < def.length; ii++) {
		req = def[ii];
		if (!(req instanceof Object))
			throw (new Error('definition must be an array of' +
			    'objects'));

		keys = Object.keys(req);
		if (keys.length != 1)
			throw (new Error('definition entry must only have ' +
			    'one key'));

		if (keys[0] in found)
			throw (new Error('Specified name already ' +
			    'specified: ' + keys[0]));

		if (!('type' in req[keys[0]]))
			throw (new Error('missing required type definition'));

		key = ctParseType(req[keys[0]]['type']);

		/*
		 * We may have nested arrays, we need to check the validity of
		 * the types until the len field is undefined in key. However,
		 * each time len is defined we need to verify it is either an
		 * integer or corresponds to an already seen key.
		 */
		while (key['len'] !== undefined) {
			if (isNaN(parseInt(key['len'], 10))) {
				if (!(key['len'] in found))
					throw (new Error('Given an array ' +
					    'length without a matching type'));

			}

			key = ctParseType(key['type']);
		}

		/* Now we can validate if the type is valid */
		if (!(key['type'] in types))
			throw (new Error('type not found or typdefed: ' +
			    key['type']));

		/* Check for any required fields */
		if (fields !== undefined) {
			for (jj = 0; jj < fields.length; jj++) {
				if (!(fields[jj] in req[keys[0]]))
					throw (new Error('Missing required ' +
					    'field: ' + fields[jj]));
			}
		}

		found[keys[0]] = true;
	}
}


/*
 * Create a new instance of the parser. Each parser has its own store of
 * typedefs and endianness. Conf is an object with the following required
 * values:
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 * And the following optional values:
 *
 * 	char-type	Valid options here are uint8 and int8. If uint8 is
 * 			specified this changes the default behavior of a single
 * 			char from being a buffer of a single character to being
 * 			a uint8_t. If int8, it becomes an int8_t instead.
 */
function CTypeParser(conf)
{
	if (!conf) throw (new Error('missing required argument'));

	if (!('endian' in conf))
		throw (new Error('missing required endian value'));

	if (conf['endian'] != 'big' && conf['endian'] != 'little')
		throw (new Error('Invalid endian type'));

	if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
	    conf['char-type'] != 'int8'))
		throw (new Error('invalid option for char-type: ' +
		    conf['char-type']));

	this.endian = conf['endian'];
	this.types = ctGetBasicTypes();

	/*
	 * There may be a more graceful way to do this, but this will have to
	 * serve.
	 */
	if ('char-type' in conf && conf['char-type'] == 'uint8')
		this.types['char'] = this.types['uint8_t'];

	if ('char-type' in conf && conf['char-type'] == 'int8')
		this.types['char'] = this.types['int8_t'];
}

/*
 * Sets the current endian value for the Parser. If the value is not valid,
 * throws an Error.
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 */
CTypeParser.prototype.setEndian = function (endian)
{
	if (endian != 'big' && endian != 'little')
		throw (new Error('invalid endian type, must be big or ' +
		    'little'));

	this.endian = endian;
};

/*
 * Returns the current value of the endian value for the parser.
 */
CTypeParser.prototype.getEndian = function ()
{
	return (this.endian);
};

/*
 * A user has requested to add a type, let us honor their request. Yet, if their
 * request doth spurn us, send them unto the Hells which Dante describes.
 *
 * 	name		The string for the type definition we're adding
 *
 *	value		Either a string that is a type/array name or an object
 *			that describes a struct.
 */
CTypeParser.prototype.typedef = function (name, value)
{
	var type;

	if (name === undefined)
		throw (new (Error('missing required typedef argument: name')));

	if (value === undefined)
		throw (new (Error('missing required typedef argument: value')));

	if (typeof (name) != 'string')
		throw (new (Error('the name of a type must be a string')));

	type = ctParseType(name);

	if (type['len'] !== undefined)
		throw (new Error('Cannot have an array in the typedef name'));

	if (name in this.types)
		throw (new Error('typedef name already present: ' + name));

	if (typeof (value) != 'string' && !(value instanceof Array))
		throw (new Error('typedef value must either be a string or ' +
		    'struct'));

	if (typeof (value) == 'string') {
		type = ctParseType(value);
		if (type['len'] !== undefined) {
			if (isNaN(parseInt(type['len'], 10)))
				throw (new (Error('typedef value must use ' +
				    'fixed size array when outside of a ' +
				    'struct')));
		}

		this.types[name] = value;
	} else {
		/* We have a struct, validate it */
		ctCheckReq(value, this.types);
		this.types[name] = value;
	}
};

/*
 * Include all of the typedefs, but none of the built in types. This should be
 * treated as read-only.
 */
CTypeParser.prototype.lstypes = function ()
{
	var key;
	var ret = {};

	for (key in this.types) {
		if (key in deftypes)
			continue;
		ret[key] = this.types[key];
	}

	return (ret);
};

/*
 * Given a type string that may have array types that aren't numbers, try and
 * fill them in from the values object. The object should be of the format where
 * indexing into it should return a number for that type.
 *
 *	str		The type string
 *
 *	values		An object that can be used to fulfill type information
 */
function ctResolveArray(str, values)
{
	var ret = '';
	var type = ctParseType(str);

	while (type['len'] !== undefined) {
		if (isNaN(parseInt(type['len'], 10))) {
			if (typeof (values[type['len']]) != 'number')
				throw (new Error('cannot sawp in non-number ' +
				    'for array value'));
			ret = '[' + values[type['len']] + ']' + ret;
		} else {
			ret = '[' + type['len'] + ']' + ret;
		}
		type = ctParseType(type['type']);
	}

	ret = type['type'] + ret;

	return (ret);
}

/*
 * [private] Either the typedef resolves to another type string or to a struct.
 * If it resolves to a struct, we just pass it off to read struct. If not, we
 * can just pass it off to read entry.
 */
CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
    offset, value)
{
	var pt;

	mod_assert.ok(type in this.types);
	if (typeof (this.types[type]) == 'string') {
		pt = ctParseType(this.types[type]);
		if (dispatch == 'read')
			return (this.readEntry(pt, buffer, offset));
		else if (dispatch == 'write')
			return (this.writeEntry(value, pt, buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	} else {
		if (dispatch == 'read')
			return (this.readStruct(this.types[type], buffer,
			    offset));
		else if (dispatch == 'write')
			return (this.writeStruct(value, this.types[type],
			    buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	}

};

/*
 * [private] Try and read in the specific entry.
 */
CTypeParser.prototype.readEntry = function (type, buffer, offset)
{
	var parse, len;

	/*
	 * Because we want to special case char[]s this is unfortunately
	 * a bit uglier than it really should be. We want to special
	 * case char[]s so that we return a node buffer, thus they are a
	 * first class type where as all other arrays just call into a
	 * generic array routine which calls their data-specific routine
	 * the specified number of times.
	 *
	 * The valid dispatch options we have are:
	 *  - Array and char => char[] handler
	 *  - Generic array handler
	 *  - Generic typedef handler
	 *  - Basic type handler
	 */
	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			parse = this.types['char[]']['read'](len,
			    this.endian, buffer, offset);
		else
			parse = this.readArray(type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			parse = this.types[type['type']]['read'](this.endian,
			    buffer, offset);
		else
			parse = this.resolveTypedef(type['type'], 'read',
			    buffer, offset);
	}

	return (parse);
};

/*
 * [private] Read an array of data
 */
CTypeParser.prototype.readArray = function (type, length, buffer, offset)
{
	var ii, ent, pt;
	var baseOffset = offset;
	var ret = new Array(length);
	pt = ctParseType(type);

	for (ii = 0; ii < length; ii++) {
		ent = this.readEntry(pt, buffer, offset);
		offset += ent['size'];
		ret[ii] = ent['value'];
	}

	return ({ value: ret, size: offset - baseOffset });
};

/*
 * [private] Read a single struct in.
 */
CTypeParser.prototype.readStruct = function (def, buffer, offset)
{
	var parse, ii, type, entry, key;
	var baseOffset = offset;
	var ret = {};

	/* Walk it and handle doing what's necessary */
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		/* Resolve all array values */
		type = ctParseType(ctResolveArray(entry['type'], ret));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		parse = this.readEntry(type, buffer, offset);

		offset += parse['size'];
		ret[key] = parse['value'];
	}

	return ({ value: ret, size: (offset-baseOffset)});
};

/*
 * This is what we were born to do. We read the data from a buffer and return it
 * in an object whose keys match the values from the object.
 *
 *	def		The array definition of the data to read in
 *
 *	buffer		The buffer to read data from
 *
 *	offset		The offset to start writing to
 *
 * Returns an object where each key corresponds to an entry in def and the value
 * is the read value.
 */
CTypeParser.prototype.readData = function (def, buffer, offset)
{
	/* Sanity check for arguments */
	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	/* Sanity check the object definition */
	ctCheckReq(def, this.types);

	return (this.readStruct(def, buffer, offset)['value']);
};

/*
 * [private] Write out an array of data
 */
CTypeParser.prototype.writeArray = function (value, type, length, buffer,
    offset)
{
	var ii, pt;
	var baseOffset = offset;
	if (!(value instanceof Array))
		throw (new Error('asked to write an array, but value is not ' +
		    'an array'));

	if (value.length != length)
		throw (new Error('asked to write array of length ' + length +
		    ' but that does not match value length: ' + value.length));

	pt = ctParseType(type);
	for (ii = 0; ii < length; ii++)
		offset += this.writeEntry(value[ii], pt, buffer, offset);

	return (offset - baseOffset);
};

/*
 * [private] Write the specific entry
 */
CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
{
	var len, ret;

	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			ret = this.types['char[]']['write'](value, len,
			    this.endian, buffer, offset);
		else
			ret = this.writeArray(value, type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			ret = this.types[type['type']]['write'](value,
			    this.endian, buffer, offset);
		else
			ret = this.resolveTypedef(type['type'], 'write',
			    buffer, offset, value);
	}

	return (ret);
};

/*
 * [private] Write a single struct out.
 */
CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
{
	var ii, entry, type, key;
	var baseOffset = offset;
	var vals = {};

	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		type = ctParseType(ctResolveArray(entry['type'], vals));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		offset += this.writeEntry(value[ii], type, buffer, offset);
		/* Now that we've written it out, we can use it for arrays */
		vals[key] = value[ii];
	}

	return (offset);
};

/*
 * Unfortunately, we're stuck with the sins of an initial poor design. Because
 * of that, we are going to have to support the old way of writing data via
 * writeData. There we insert the values that you want to write into the
 * definition. A little baroque. Internally, we use the new model. So we need to
 * just get those values out of there. But to maintain the principle of least
 * surprise, we're not going to modify the input data.
 */
function getValues(def)
{
	var ii, out, key;
	out = [];
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		mod_assert.ok('value' in def[ii][key]);
		out.push(def[ii][key]['value']);
	}

	return (out);
}

/*
 * This is the second half of what we were born to do, write out the data
 * itself. Historically this function required you to put your values in the
 * definition section. This was not the smartest thing to do and a bit of an
 * oversight to be honest. As such, this function now takes a values argument.
 * If values is non-null and non-undefined, it will be used to determine the
 * values. This means that the old method is still supported, but is no longer
 * acceptable.
 *
 *	def		The array definition of the data to write out with
 *			values
 *
 *	buffer		The buffer to write to
 *
 *	offset		The offset in the buffer to write to
 *
 *	values		An array of values to write.
 */
CTypeParser.prototype.writeData = function (def, buffer, offset, values)
{
	var hv;

	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	hv = (values != null && values != undefined);
	if (hv) {
		if (!Array.isArray(values))
			throw (new Error('missing values for writing'));
		ctCheckReq(def, this.types);
	} else {
		ctCheckReq(def, this.types, [ 'value' ]);
	}

	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
};

/*
 * Functions to go to and from 64 bit numbers in a way that is compatible with
 * Javascript limitations. There are two sets. One where the user is okay with
 * an approximation and one where they are definitely not okay with an
 * approximation.
 */

/*
 * Attempts to convert an array of two integers returned from rsint64 / ruint64
 * into an absolute 64 bit number. If however the value would exceed 2^52 this
 * will instead throw an error. The mantissa in a double is a 52 bit number and
 * rather than potentially give you a value that is an approximation this will
 * error. If you would rather an approximation, please see toApprox64.
 *
 *	val		An array of two 32-bit integers
 */
function toAbs64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	/* We have 20 bits worth of precision in this range */
	if (val[0] >= 0x100000)
		throw (new Error('value would become approximated'));

	return (val[0] * Math.pow(2, 32) + val[1]);
}

/*
 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
 * to a value as close as it can. Note that Javascript stores all numbers as a
 * double and the mantissa only has 52 bits. Thus this version may approximate
 * the value.
 *
 *	val		An array of two 32-bit integers
 */
function toApprox64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	return (Math.pow(2, 32) * val[0] + val[1]);
}

function parseCTF(json, conf)
{
	var ctype = new CTypeParser(conf);
	mod_ctf.ctfParseJson(json, ctype);

	return (ctype);
}

/*
 * Export the few things we actually want to. Currently this is just the CType
 * Parser and ctio.
 */
exports.Parser = CTypeParser;
exports.toAbs64 = toAbs64;
exports.toApprox64 = toApprox64;

exports.parseCTF = parseCTF;

exports.ruint8 = mod_ctio.ruint8;
exports.ruint16 = mod_ctio.ruint16;
exports.ruint32 = mod_ctio.ruint32;
exports.ruint64 = mod_ctio.ruint64;
exports.wuint8 = mod_ctio.wuint8;
exports.wuint16 = mod_ctio.wuint16;
exports.wuint32 = mod_ctio.wuint32;
exports.wuint64 = mod_ctio.wuint64;

exports.rsint8 = mod_ctio.rsint8;
exports.rsint16 = mod_ctio.rsint16;
exports.rsint32 = mod_ctio.rsint32;
exports.rsint64 = mod_ctio.rsint64;
exports.wsint8 = mod_ctio.wsint8;
exports.wsint16 = mod_ctio.wsint16;
exports.wsint32 = mod_ctio.wsint32;
exports.wsint64 = mod_ctio.wsint64;

exports.rfloat = mod_ctio.rfloat;
exports.rdouble = mod_ctio.rdouble;
exports.wfloat = mod_ctio.wfloat;
exports.wdouble = mod_ctio.wdouble;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/ctype.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/ctf.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctf.js"}
require.memoize("59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctf.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype';
/*
 * ctf.js
 *
 * Understand and parse all of the different JSON formats of CTF data and
 * translate that into a series of node-ctype friendly pieces. The reason for
 * the abstraction is to handle different changes in the file format.
 *
 * We have to be careful here that we don't end up using a name that is already
 * a built in type.
 */
var mod_assert = require('__SYSTEM__/assert');
var ASSERT = mod_assert.ok;

var ctf_versions = [ '1.0' ];
var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
    'uint32_t', 'float', 'double' ];

function ctfParseInteger(entry, ctype)
{
	var name, sign, len, type;

	name = entry['name'];
	if (!('signed' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'signed value'));


	if (!('length' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'length value'));

	sign = entry['integer']['signed'];
	len = entry['integer']['length'];
	type = null;

	if (sign && len == 1)
		type = 'int8_t';
	else if (len == 1)
		type = 'uint8_t';
	else if (sign && len == 2)
		type = 'int16_t';
	else if (len == 2)
		type = 'uint16_t';
	else if (sign && len == 4)
		type = 'int32_t';
	else if (len == 4)
		type = 'uint32_t';
	else if (sign && len == 8)
		type = 'int64_t';
	else if (len == 8)
		type = 'uint64_t';

	if (type === null)
		throw (new Error('Malformed CTF JSON: integer has ' +
		    'unsupported length and sign - ' + len + '/' + sign));

	/*
	 * This means that this is the same as one of our built in types. If
	 * that's the case defining it would be an error. So instead of trying
	 * to typedef it, we'll return here.
	 */
	if (name == type)
		return;

	if (name == 'char') {
		ASSERT(type == 'int8_t');
		return;
	}

	ctype.typedef(name, type);
}

function ctfParseFloat(entry, ctype)
{
	var name, len;

	name = entry['name'];
	if (!('length' in entry['float']))
		throw (new Error('Malformed CTF JSON: float missing ' +
		    'length value'));

	len = entry['float']['length'];
	if (len != 4 && len != 8)
		throw (new Error('Malformed CTF JSON: float has invalid ' +
		    'length value'));

	if (len == 4) {
		if (name == 'float')
			return;
		ctype.typedef(name, 'float');
	} else if (len == 8) {
		if (name == 'double')
			return;
		ctype.typedef(name, 'double');
	}
}

function ctfParseTypedef(entry, ctype)
{
	var name, type, ii;

	name = entry['name'];
	if (typeof (entry['typedef']) != 'string')
		throw (new Error('Malformed CTF JSON: typedef value in not ' +
		    'a string'));

	type = entry['typedef'];

	/*
	 * We need to ensure that we're not looking at type that's one of our
	 * built in types. Traditionally in C a uint32_t would be a typedef to
	 * some kind of integer. However, those size types are built ins.
	 */
	for (ii = 0; ii < ctf_deftypes.length; ii++) {
		if (name == ctf_deftypes[ii])
			return;
	}

	ctype.typedef(name, type);
}

function ctfParseStruct(entry, ctype)
{
	var name, type, ii, val, index, member, push;

	member = [];
	if (!Array.isArray(entry['struct']))
		throw (new Error('Malformed CTF JSON: struct value is not ' +
		    'an array'));

	for (ii = 0; ii < entry['struct'].length; ii++) {
		val = entry['struct'][ii];
		if (!('name' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing name'));

		if (!('type' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing type'));

		if (typeof (val['name']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'name isn\'t a string'));

		if (typeof (val['type']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'type isn\'t a string'));

		/*
		 * CTF version 2 specifies array names as <type> [<num>] where
		 * as node-ctype does this as <type>[<num>].
		 */
		name = val['name'];
		type = val['type'];
		index = type.indexOf(' [');
		if (index != -1) {
			type = type.substring(0, index) +
			    type.substring(index + 1, type.length);
		}
		push = {};
		push[name] = { 'type': type };
		member.push(push);
	}

	name = entry['name'];
	ctype.typedef(name, member);
}

function ctfParseEntry(entry, ctype)
{
	var ii, found;

	if (!('name' in entry))
		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
		    'section'));

	for (ii = 0; ii < ctf_entries.length; ii++) {
		if (ctf_entries[ii] in entry)
			found++;
	}

	if (found === 0)
		throw (new Error('Malformed CTF JSON: found no entries'));

	if (found >= 2)
		throw (new Error('Malformed CTF JSON: found more than one ' +
		    'entry'));

	if ('integer' in entry) {
		ctfParseInteger(entry, ctype);
		return;
	}

	if ('float' in entry) {
		ctfParseFloat(entry, ctype);
		return;
	}

	if ('typedef' in entry) {
		ctfParseTypedef(entry, ctype);
		return;
	}

	if ('struct' in entry) {
		ctfParseStruct(entry, ctype);
		return;
	}

	ASSERT(false, 'shouldn\'t reach here');
}

function ctfParseJson(json, ctype)
{
	var version, ii;

	ASSERT(json);
	ASSERT(ctype);
	if (!('metadata' in json))
		throw (new Error('Invalid CTF JSON: missing metadata section'));

	if (!('ctf2json_version' in json['metadata']))
		throw (new Error('Invalid CTF JSON: missing ctf2json_version'));

	version = json['metadata']['ctf2json_version'];
	for (ii = 0; ii < ctf_versions.length; ii++) {
		if (ctf_versions[ii] == version)
			break;
	}

	if (ii == ctf_versions.length)
		throw (new Error('Unsuported ctf2json_version: ' + version));

	if (!('data' in json))
		throw (new Error('Invalid CTF JSON: missing data section'));

	if (!Array.isArray(json['data']))
		throw (new Error('Malformed CTF JSON: data section is not ' +
		    'an array'));

	for (ii = 0; ii < json['data'].length; ii++)
		ctfParseEntry(json['data'][ii], ctype);
}

exports.ctfParseJson = ctfParseJson;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/ctf.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/ctio.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctio.js"}
require.memoize("59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctio.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype';
/*
 * rm - Feb 2011
 * ctio.js:
 *
 * A simple way to read and write simple ctypes. Of course, as you'll find the
 * code isn't as simple as it might appear. The following types are currently
 * supported in big and little endian formats:
 *
 * 	uint8_t			int8_t
 * 	uint16_t		int16_t
 * 	uint32_t		int32_t
 *	float (single precision IEEE 754)
 *	double (double precision IEEE 754)
 *
 * This is designed to work in Node and v8. It may in fact work in other
 * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
 * If you find that it does in fact work, that's pretty cool. Try and pass word
 * back to the original author.
 *
 * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
 * weird.
 */

/*
 * Numbers in Javascript have a secret: all numbers must be represented with an
 * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
 * implicit one. Thus the range of integers that can be represented is limited
 * to the size of the mantissa, this makes reading and writing 64-bit integers
 * difficult, but far from impossible.
 *
 * Another side effect of this representation is what happens when you use the
 * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
 * each operand and the result is cast to a signed 32-bit number. However, in
 * the case of >>> the values are cast to an unsigned number.
 */

/*
 * A reminder on endian related issues:
 *
 * Big Endian: MSB -> First byte
 * Little Endian: MSB->Last byte
 */
var mod_assert = require('__SYSTEM__/assert');

/*
 * An 8 bit unsigned integer involves doing no significant work.
 */
function ruint8(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (buffer[offset]);
}

/*
 * For 16 bit unsigned numbers we can do all the casting that we want to do.
 */
function rgint16(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset] << 8;
		val |=  buffer[offset+1];
	} else {
		val = buffer[offset];
		val |= buffer[offset+1] << 8;
	}

	return (val);

}

function ruint16(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint16(buffer, endian, offset));
}

/*
 * Because most bitshifting is done using signed numbers, if we would go into
 * the realm where we use that 32nd bit, we'll end up going into the negative
 * range. i.e.:
 * > 200 << 24
 * -939524096
 *
 * Not the value you'd expect. To work around this, we end up having to do some
 * abuse of the JavaScript standard. in this case, we know that a >>> shift is
 * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
 * use that instead to save us some additional math, though it does feel a
 * little weird and it isn't obvious as to why you woul dwant to do this at
 * first.
 */
function rgint32(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset+1] << 16;
		val |= buffer[offset+2] << 8;
		val |= buffer[offset+3];
		val = val + (buffer[offset] << 24 >>> 0);
	} else {
		val = buffer[offset+2] << 16;
		val |= buffer[offset+1] << 8;
		val |= buffer[offset];
		val = val + (buffer[offset + 3] << 24 >>> 0);
	}

	return (val);
}

function ruint32(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint32(buffer, endian, offset));
}

/*
 * Reads a 64-bit unsigned number. The astue observer will note that this
 * doesn't quite work. Javascript has chosen to only have numbers that can be
 * represented by a double. A double only has 52 bits of mantissa with an
 * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
 * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
 * could you have possibly wanted to represent that was larger than that? Oh,
 * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
 * that happen?
 *
 * To get around this egregious language issue, we're going to instead construct
 * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
 * give the actual number. However, note that the above code probably won't
 * produce the desired results because of the way Javascript numbers are
 * doubles.
 */
function rgint64(buffer, endian, offset)
{
	var val = new Array(2);

	if (endian == 'big') {
		val[0] = ruint32(buffer, endian, offset);
		val[1] = ruint32(buffer, endian, offset+4);
	} else {
		val[0] = ruint32(buffer, endian, offset+4);
		val[1] = ruint32(buffer, endian, offset);
	}

	return (val);
}

function ruint64(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint64(buffer, endian, offset));
}


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 *
 * Doing it this way ends up allowing us to treat it appropriately in
 * Javascript. Sigh, that's really quite ugly for what should just be a few bit
 * shifts, ~ and &.
 */

/*
 * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
 * this case because the more traditional methods work, but for consistency,
 * we'll keep doing this the same way.
 */
function rsint8(buffer, endian, offset)
{
	var neg;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	neg = buffer[offset] & 0x80;
	if (!neg)
		return (buffer[offset]);

	return ((0xff - buffer[offset] + 1) * -1);
}

/*
 * The 16-bit version requires a bit more effort. In this case, we can leverage
 * our unsigned code to generate the value we want to return.
 */
function rsint16(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint16(buffer, endian, offset);
	neg = val & 0x8000;
	if (!neg)
		return (val);

	return ((0xffff - val + 1) * -1);
}

/*
 * We really shouldn't leverage our 32-bit code here and instead utilize the
 * fact that we know that since these are signed numbers, we can do all the
 * shifting and binary anding to generate the 32-bit number. But, for
 * consistency we'll do the same. If we want to do otherwise, we should instead
 * make the 32 bit unsigned code do the optimization. But as long as there
 * aren't floats secretly under the hood for that, we /should/ be okay.
 */
function rsint32(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint32(buffer, endian, offset);
	neg = val & 0x80000000;
	if (!neg)
		return (val);

	return ((0xffffffff - val + 1) * -1);
}

/*
 * The signed version of this code suffers from all of the same problems of the
 * other 64 bit version.
 */
function rsint64(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint64(buffer, endian, offset);
	neg = val[0] & 0x80000000;

	if (!neg)
		return (val);

	val[0] = (0xffffffff - val[0]) * -1;
	val[1] = (0xffffffff - val[1] + 1) * -1;

	/*
	 * If we had the key 0x8000000000000000, that would leave the lower 32
	 * bits as 0xffffffff, however, since we're goint to add one, that would
	 * actually leave the lower 32-bits as 0x100000000, which would break
	 * our ability to write back a value that we received. To work around
	 * this, if we actually get that value, we're going to bump the upper
	 * portion by 1 and set this to zero.
	 */
	mod_assert.ok(val[1] <= 0x100000000);
	if (val[1] == -0x100000000) {
		val[1] = 0;
		val[0]--;
	}

	return (val);
}

/*
 * We now move onto IEEE 754: The traditional form for floating point numbers
 * and what is secretly hiding at the heart of everything in this. I really hope
 * that someone is actually using this, as otherwise, this effort is probably
 * going to be more wasted.
 *
 * One might be tempted to use parseFloat here, but that wouldn't work at all
 * for several reasons. Mostly due to the way floats actually work, and
 * parseFloat only actually works in base 10. I don't see base 10 anywhere near
 * this file.
 *
 * In this case we'll implement the single and double precision versions. The
 * quadruple precision, while probably useful, wouldn't really be accepted by
 * Javascript, so let's not even waste our time.
 *
 * So let's review how this format looks like. A single precision value is 32
 * bits and has three parts:
 *   -  Sign bit
 *   -  Exponent (Using bias notation)
 *   -  Mantissa
 *
 * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
 * 31| 30-23  |  22    	-       0       |
 *
 * The exponent is stored in a biased input. The bias in this case 127.
 * Therefore, our exponent is equal to the 8-bit value - 127.
 *
 * By default, a number is normalized in IEEE, that means that the mantissa has
 * an implicit one that we don't see. So really the value stored is 1.m.
 * However, if the exponent is all zeros, then instead we have to shift
 * everything to the right one and there is no more implicit one.
 *
 * Special values:
 *  - Positive Infinity:
 *	Sign:		0
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - Negative Infinity:
 *	Sign:		1
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - NaN:
 *	Sign:		*
 *	Exponent: 	All 1s
 *	Mantissa:	non-zero
 *  - Zero:
 *	Sign:		*
 *	Exponent:	All 0s
 *	Mantissa:	0
 *
 * In the case of zero, the sign bit determines whether we get a positive or
 * negative zero. However, since Javascript cannot determine the difference
 * between the two: i.e. -0 == 0, we just always return 0.
 *
 */
function rfloat(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val;
	var bias = 127;
	var maxexp = 0xff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
	} else {
		bytes[3] = buffer[offset];
		bytes[2] = buffer[offset+1];
		bytes[1] = buffer[offset+2];
		bytes[0] = buffer[offset+3];
	}

	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 1;
	exponent |= (bytes[1] & 0x80) >>> 7;
	mantissa = (bytes[1] & 0x7f) << 16;
	mantissa |= bytes[2] << 8;
	mantissa |= bytes[3];

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Doubles in IEEE 754 are like their brothers except for a few changes and
 * increases in size:
 *   - The exponent is now 11 bits
 *   - The mantissa is now 52 bits
 *   - The bias is now 1023
 *
 * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
 * 63| 62 - 52   | 	51		-			0     |
 * 63| 62 - 52   |      51              -                       0     |
 *
 * While the size has increased a fair amount, we're going to end up keeping the
 * same general formula for calculating the final value. As a reminder, this
 * formula is:
 *
 * (-1)^s * (n + m) * 2^(e-b)
 *
 * Where:
 *	s	is the sign bit
 *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
 *					     or not
 *	m	is the mantissa
 *	e	is the exponent specified
 *	b	is the bias for the exponent
 *
 */
function rdouble(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val, lowmant;
	var bias = 1023;
	var maxexp = 0x7ff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
		bytes[4] = buffer[offset+4];
		bytes[5] = buffer[offset+5];
		bytes[6] = buffer[offset+6];
		bytes[7] = buffer[offset+7];
	} else {
		bytes[7] = buffer[offset];
		bytes[6] = buffer[offset+1];
		bytes[5] = buffer[offset+2];
		bytes[4] = buffer[offset+3];
		bytes[3] = buffer[offset+4];
		bytes[2] = buffer[offset+5];
		bytes[1] = buffer[offset+6];
		bytes[0] = buffer[offset+7];
	}

	/*
	 * We can construct the exponent and mantissa the same way as we did in
	 * the case of a float, just increase the range of the exponent.
	 */
	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 4;
	exponent |= (bytes[1] & 0xf0) >>> 4;

	/*
	 * This is going to be ugly but then again, we're dealing with IEEE 754.
	 * This could probably be done as a node add on in a few lines of C++,
	 * but oh we'll, we've made it this far so let's be native the rest of
	 * the way...
	 *
	 * What we're going to do is break the mantissa into two parts, the
	 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
	 * by the appropriate power and then add in the lower 24-bits. Not
	 * really that great. It's pretty much a giant kludge to deal with
	 * Javascript eccentricities around numbers.
	 */
	lowmant = bytes[7];
	lowmant |= bytes[6] << 8;
	lowmant |= bytes[5] << 16;
	mantissa = bytes[4];
	mantissa |= bytes[3] << 8;
	mantissa |= bytes[2] << 16;
	mantissa |= (bytes[1] & 0x0f) << 24;
	mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
	mantissa += lowmant;

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Now that we have gone through the pain of reading the individual types, we're
 * probably going to want some way to write these back. None of this is going to
 * be good. But since we have Javascript numbers this should certainly be more
 * interesting. Though we can constrain this end a little bit more in what is
 * valid. For now, let's go back to our friends the unsigned value.
 */

/*
 * Unsigned numbers seem deceptively easy. Here are the general steps and rules
 * that we are going to take:
 *   -  If the number is negative, throw an Error
 *   -  Truncate any floating point portion
 *   -  Take the modulus of the number in our base
 *   -  Write it out to the buffer in the endian format requested at the offset
 */

/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *	value		The number to check for validity
 *
 *	max		The maximum value
 */
function prepuint(value, max)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value < 0)
		throw (new Error('specified a negative value for writing an ' +
		    'unsigned value'));

	if (value > max)
		throw (new Error('value is larger than maximum value for ' +
		    'type'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * 8-bit version, classy. We can ignore endianness which is good.
 */
function wuint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xff);
	buffer[offset] = val;
}

/*
 * Pretty much the same as the 8-bit version, just this time we need to worry
 * about endian related issues.
 */
function wgint16(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val & 0xff00) >>> 8;
		buffer[offset+1] = val & 0x00ff;
	} else {
		buffer[offset+1] = (val & 0xff00) >>> 8;
		buffer[offset] = val & 0x00ff;
	}
}

function wuint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffff);
	wgint16(val, endian, buffer, offset);
}

/*
 * The 32-bit version is going to have to be a little different unfortunately.
 * We can't quite bitshift to get the largest byte, because that would end up
 * getting us caught by the signed values.
 *
 * And yes, we do want to subtract out the lower part by default. This means
 * that when we do the division, it will be treated as a bit shift and we won't
 * end up generating a floating point value. If we did generate a floating point
 * value we'd have to truncate it intelligently, this saves us that problem and
 * may even be somewhat faster under the hood.
 */
function wgint32(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
		buffer[offset+1] = (val >>> 16) & 0xff;
		buffer[offset+2] = (val >>> 8) & 0xff;
		buffer[offset+3] = val & 0xff;
	} else {
		buffer[offset+3] = (val - (val & 0x00ffffff)) /
		    Math.pow(2, 24);
		buffer[offset+2] = (val >>> 16) & 0xff;
		buffer[offset+1] = (val >>> 8) & 0xff;
		buffer[offset] = val & 0xff;
	}
}

function wuint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffffffff);
	wgint32(val, endian, buffer, offset);
}

/*
 * Unlike the other versions, we expect the value to be in the form of two
 * arrays where value[0] << 32 + value[1] would result in the value that we
 * want.
 */
function wgint64(value, endian, buffer, offset)
{
	if (endian == 'big') {
		wgint32(value[0], endian, buffer, offset);
		wgint32(value[1], endian, buffer, offset+4);
	} else {
		wgint32(value[0], endian, buffer, offset+4);
		wgint32(value[1], endian, buffer, offset);
	}
}

function wuint64(value, endian, buffer, offset)
{
	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	prepuint(value[0], 0xffffffff);
	prepuint(value[1], 0xffffffff);
	wgint64(value, endian, buffer, offset);
}

/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *	we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *	we do the following computation:
 *	mb + val + 1, where
 *	mb	is the maximum unsigned value in that byte size
 *	val	is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 *
 * Thus the overall flow is:
 *   -  Truncate the floating point part of the number
 *   -  We don't have to take the modulus, because the unsigned versions will
 *   	take care of that for us. And we don't have to worry about that
 *   	potentially causing bad things to happen because of sign extension
 *   -  Pass it off to the appropriate unsigned version, potentially modifying
 *	the negative portions as necessary.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function prepsint(value, max, min)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value > max)
		throw (new Error('value larger than maximum allowed value'));

	if (value < min)
		throw (new Error('value smaller than minimum allowed value'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * The 8-bit version of the signed value. Overall, fairly straightforward.
 */
function wsint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7f, -0x80);
	if (val >= 0)
		wuint8(val, endian, buffer, offset);
	else
		wuint8(0xff + val + 1, endian, buffer, offset);
}

/*
 * The 16-bit version of the signed value. Also, fairly straightforward.
 */
function wsint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fff, -0x8000);
	if (val >= 0)
		wgint16(val, endian, buffer, offset);
	else
		wgint16(0xffff + val + 1, endian, buffer, offset);

}

/*
 * We can do this relatively easily by leveraging the code used for 32-bit
 * unsigned code.
 */
function wsint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fffffff, -0x80000000);
	if (val >= 0)
		wgint32(val, endian, buffer, offset);
	else
		wgint32(0xffffffff + val + 1, endian, buffer, offset);
}

/*
 * The signed 64 bit integer should by in the same format as when received.
 * Mainly it should ensure that the value is an array of two integers where
 * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
 * need to be equal.
 */
function wsint64(value, endian, buffer, offset)
{
	var vzpos, vopos;
	var vals = new Array(2);

	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/*
	 * We need to make sure that we have the same sign on both values. The
	 * hokiest way to to do this is to multiply the number by +inf. If we do
	 * this, we'll get either +/-inf depending on the sign of the value.
	 * Once we have this, we can compare it to +inf to see if the number is
	 * positive or not.
	 */
	vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;
	vopos = (value[1] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;

	/*
	 * If either of these is zero, then we don't actually need this check.
	 */
	if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
		throw (new Error('Both entries in the array must have ' +
		    'the same sign'));

	/*
	 * Doing verification for a signed 64-bit integer is actually a big
	 * trickier than it appears. We can't quite use our standard techniques
	 * because we need to compare both sets of values. The first value is
	 * pretty straightforward. If the first value is beond the extremes than
	 * we error out. However, the valid range of the second value varies
	 * based on the first one. If the first value is negative, and *not* the
	 * largest negative value, than it can be any integer within the range [
	 * 0, 0xffffffff ]. If it is the largest negative number, it must be
	 * zero.
	 *
	 * If the first number is positive, than it doesn't matter what the
	 * value is. We just simply have to make sure we have a valid positive
	 * integer.
	 */
	if (vzpos) {
		prepuint(value[0], 0x7fffffff);
		prepuint(value[1], 0xffffffff);
	} else {
		prepsint(value[0], 0, -0x80000000);
		prepsint(value[1], 0, -0xffffffff);
		if (value[0] == -0x80000000 && value[1] != 0)
			throw (new Error('value smaller than minimum ' +
			    'allowed value'));
	}

	/* Fix negative numbers */
	if (value[0] < 0 || value[1] < 0) {
		vals[0] = 0xffffffff - Math.abs(value[0]);
		vals[1] = 0x100000000 - Math.abs(value[1]);
		if (vals[1] == 0x100000000) {
			vals[1] = 0;
			vals[0]++;
		}
	} else {
		vals[0] = value[0];
		vals[1] = value[1];
	}
	wgint64(vals, endian, buffer, offset);
}

/*
 * Now we are moving onto the weirder of these, the float and double. For this
 * we're going to just have to do something that's pretty weird. First off, we
 * have no way to get at the underlying float representation, at least not
 * easily. But that doesn't mean we can't figure it out, we just have to use our
 * heads.
 *
 * One might propose to use Number.toString(2). Of course, this is not really
 * that good, because the ECMAScript 262 v3 Standard says the following Section
 * 15.7.4.2-Number.prototype.toString (radix):
 *
 * If radix is an integer from 2 to 36, but not 10, the result is a string, the
 * choice of which is implementation-dependent.
 *
 * Well that doesn't really help us one bit now does it? We could use the
 * standard base 10 version of the string, but that's just going to create more
 * errors as we end up trying to convert it back to a binary value. So, really
 * this just means we have to be non-lazy and parse the structure intelligently.
 *
 * First off, we can do the basic checks: NaN, positive and negative infinity.
 *
 * Now that those are done we can work backwards to generate the mantissa and
 * exponent.
 *
 * The first thing we need to do is determine the sign bit, easy to do, check
 * whether the value is less than 0. And convert the number to its absolute
 * value representation. Next, we need to determine if the value is less than
 * one or greater than or equal to one and from there determine what power was
 * used to get there. What follows is now specific to floats, though the general
 * ideas behind this will hold for doubles as well, but the exact numbers
 * involved will change.
 *
 * Once we have that power we can determine the exponent and the mantissa. Call
 * the value that has the number of bits to reach the power ebits. In the
 * general case they have the following values:
 *
 *	exponent	127 + ebits
 *	mantissa	value * 2^(23 - ebits) & 0x7fffff
 *
 * In the case where the value of ebits is <= -127 we are now in the case where
 * we no longer have normalized numbers. In this case the values take on the
 * following values:
 *
 * 	exponent	0
 *	mantissa	value * 2^149 & 0x7fffff
 *
 * Once we have the values for the sign, mantissa, and exponent. We reconstruct
 * the four bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits from the exp
 *			sign << 7 | (exponent & 0xfe) >>> 1
 *
 *	byte1		lsb from the exponent and 7 top bits from the mantissa
 *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
 *
 *	byte2		bits 8-15 (zero indexing) from mantissa
 *			mantissa & 0xff00 >> 8
 *
 *	byte3		bits 0-7 from mantissa
 *			mantissa & 0xff
 *
 * Once we have this we have to assign them into the buffer in proper endian
 * order.
 */

/*
 * Compute the log base 2 of the value. Now, someone who remembers basic
 * properties of logarithms will point out that we could use the change of base
 * formula for logs, and in fact that would be astute, because that's what we'll
 * do for now. It feels cleaner, albeit it may be less efficient than just
 * iterating and dividing by 2. We may want to come back and revisit that some
 * day.
 */
function log2(value)
{
	return (Math.log(value) / Math.log(2));
}

/*
 * Helper to determine the exponent of the number we're looking at.
 */
function intexp(value)
{
	return (Math.floor(log2(value)));
}

/*
 * Helper to determine the exponent of the fractional part of the value.
 */
function fracexp(value)
{
	return (Math.floor(log2(value)));
}

function wfloat(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0xff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0xff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0xff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/* Time to deal with the issues surrounding normalization */
		if (ebits <= -127) {
			exponent = 0;
			mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
		} else {
			exponent = 127 + ebits;
			mantissa = value * Math.pow(2, 23 - ebits);
			mantissa &= 0x7fffff;
		}
	}

	bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
	bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
	bytes[2] = (mantissa & 0x00ff00) >>> 8;
	bytes[3] = mantissa & 0x0000ff;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
	} else {
		buffer[offset] = bytes[3];
		buffer[offset+1] = bytes[2];
		buffer[offset+2] = bytes[1];
		buffer[offset+3] = bytes[0];
	}
}

/*
 * Now we move onto doubles. Doubles are similar to floats in pretty much all
 * ways except that the processing isn't quite as straightforward because we
 * can't always use shifting, i.e. we have > 32 bit values.
 *
 * We're going to proceed in an identical fashion to floats and utilize the same
 * helper functions. All that really is changing are the specific values that we
 * use to do the calculations. Thus, to review we have to do the following.
 *
 * First get the sign bit and convert the value to its absolute value
 * representation. Next, we determine the number of bits that we used to get to
 * the value, branching whether the value is greater than or less than 1. Once
 * we have that value which we will again call ebits, we have to do the
 * following in the general case:
 *
 *	exponent	1023 + ebits
 *	mantissa	[value * 2^(52 - ebits)] % 2^52
 *
 * In the case where the value of ebits <= -1023 we no longer use normalized
 * numbers, thus like with floats we have to do slightly different processing:
 *
 *	exponent	0
 *	mantissa	[value * 2^1074] % 2^52
 *
 * Once we have determined the sign, exponent and mantissa we can construct the
 * bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits form the exp
 *			sign << 7 | (exponent & 0x7f0) >>> 4
 *
 *	byte1		Remaining 4 bits from the exponent and the four most
 *			significant bits from the mantissa 48-51
 *			(exponent & 0x00f) << 4 | mantissa >>> 48
 *
 *	byte2		Bits 40-47 from the mantissa
 *			(mantissa >>> 40) & 0xff
 *
 *	byte3		Bits 32-39 from the mantissa
 *			(mantissa >>> 32) & 0xff
 *
 *	byte4		Bits 24-31 from the mantissa
 *			(mantissa >>> 24) & 0xff
 *
 *	byte5		Bits 16-23 from the Mantissa
 *			(mantissa >>> 16) & 0xff
 *
 *	byte6		Bits 8-15 from the mantissa
 *			(mantissa >>> 8) & 0xff
 *
 *	byte7		Bits 0-7 from the mantissa
 *			mantissa & 0xff
 *
 * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
 * we'll have extended too far and we'll lose those values when we try and do
 * the shift. Instead we have to use an alternate approach. To try and stay out
 * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
 * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
 * that's ugly, but it seems to avoid using floating point (just based on how v8
 * seems to be optimizing for base 2 arithmetic).
 */
function wdouble(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0x7ff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/*
		 * This is a total hack to determine a denormalized value.
		 * Unfortunately, we sometimes do not get a proper value for
		 * ebits, i.e. we lose the values that would get rounded off.
		 *
		 *
		 * The astute observer may wonder why we would be
		 * multiplying by two Math.pows rather than just summing
		 * them. Well, that's to get around a small bug in the
		 * way v8 seems to implement the function. On occasion
		 * doing:
		 *
		 * foo * Math.pow(2, 1023 + 51)
		 *
		 * Causes us to overflow to infinity, where as doing:
		 *
		 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
		 *
		 * Does not cause us to overflow. Go figure.
		 *
		 */
		if (value <= 2.225073858507201e-308 || ebits <= -1023) {
			exponent = 0;
			mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
			mantissa %= Math.pow(2, 52);
		} else {
			/*
			 * We might have gotten fucked by our floating point
			 * logarithm magic. This is rather crappy, but that's
			 * our luck. If we just had a log base 2 or access to
			 * the stupid underlying representation this would have
			 * been much easier and we wouldn't have such stupid
			 * kludges or hacks.
			 */
			if (ebits > 1023)
				ebits = 1023;
			exponent = 1023 + ebits;
			mantissa = value * Math.pow(2, -ebits);
			mantissa *= Math.pow(2, 52);
			mantissa %= Math.pow(2, 52);
		}
	}

	/* Fill the bytes in backwards to deal with the size issues */
	bytes[7] = mantissa & 0xff;
	bytes[6] = (mantissa >>> 8) & 0xff;
	bytes[5] = (mantissa >>> 16) & 0xff;
	mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
	bytes[4] = mantissa & 0xff;
	bytes[3] = (mantissa >>> 8) & 0xff;
	bytes[2] = (mantissa >>> 16) & 0xff;
	bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
	bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
		buffer[offset+4] = bytes[4];
		buffer[offset+5] = bytes[5];
		buffer[offset+6] = bytes[6];
		buffer[offset+7] = bytes[7];
	} else {
		buffer[offset+7] = bytes[0];
		buffer[offset+6] = bytes[1];
		buffer[offset+5] = bytes[2];
		buffer[offset+4] = bytes[3];
		buffer[offset+3] = bytes[4];
		buffer[offset+2] = bytes[5];
		buffer[offset+1] = bytes[6];
		buffer[offset] = bytes[7];
	}
}

/*
 * Actually export our work above. One might argue that we shouldn't expose
 * these interfaces and just force people to use the higher level abstractions
 * around this work. However, unlike say other libraries we've come across, this
 * interface has several properties: it makes sense, it's simple, and it's
 * useful.
 */
exports.ruint8 = ruint8;
exports.ruint16 = ruint16;
exports.ruint32 = ruint32;
exports.ruint64 = ruint64;
exports.wuint8 = wuint8;
exports.wuint16 = wuint16;
exports.wuint32 = wuint32;
exports.wuint64 = wuint64;

exports.rsint8 = rsint8;
exports.rsint16 = rsint16;
exports.rsint32 = rsint32;
exports.rsint64 = rsint64;
exports.wsint8 = wsint8;
exports.wsint16 = wsint16;
exports.wsint32 = wsint32;
exports.wsint64 = wsint64;

exports.rfloat = rfloat;
exports.rdouble = rdouble;
exports.wfloat = wfloat;
exports.wdouble = wdouble;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/ctio.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/node-uuid/uuid.js","mtime":0,"wrapper":"amd-ish","format":"amd-ish","id":"b360de4cfbd0215d27510c4fd03393d88d8c8ae8-node-uuid/uuid.js"}
require.memoize("b360de4cfbd0215d27510c4fd03393d88d8c8ae8-node-uuid/uuid.js", 
wrapAMD(function(require, define) {
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('__SYSTEM__/crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

})
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/node-uuid/uuid.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/mime/mime.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime/mime.js"}
require.memoize("3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime/mime.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/mime';
var path = require('__SYSTEM__/path');
var fs = require('__SYSTEM__/fs');

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];

    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts]) {
        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {

  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Load local copy of
// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
mime.load(path.join(__dirname, 'types/mime.types'));

// Load additional types from node.js community
mime.load(path.join(__dirname, 'types/node.types'));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;

return {
    path: (typeof path !== "undefined") ? path : null,
    require: (typeof require !== "undefined") ? require : null,
    fs: (typeof fs !== "undefined") ? fs : null,
    Mime: (typeof Mime !== "undefined") ? Mime : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    process: (typeof process !== "undefined") ? process : null,
    console: (typeof console !== "undefined") ? console : null,
    mime: (typeof mime !== "undefined") ? mime : null,
    __dirname: (typeof __dirname !== "undefined") ? __dirname : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/mime/mime.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/tunnel-agent/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"108b28d120f242b00befd693696b25134ac10bef-tunnel-agent/index.js"}
require.memoize("108b28d120f242b00befd693696b25134ac10bef-tunnel-agent/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/tunnel-agent';
'use strict'

var net = require('__SYSTEM__/net')
  , tls = require('__SYSTEM__/tls')
  , http = require('__SYSTEM__/http')
  , https = require('__SYSTEM__/https')
  , events = require('__SYSTEM__/events')
  , assert = require('__SYSTEM__/assert')
  , util = require('__SYSTEM__/util')
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  return agent
}


function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {
  var self = this

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: host, port: port, request: req})
    return
  }

  // If we are under maxSockets create a new one.
  self.createSocket({host: host, port: port, request: req}, function(socket) {
    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    req.onSocket(socket)

    function onFree() {
      self.emit('free', socket, host, port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket()
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions, 
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  )
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse) // for v0.6
  connectReq.once('upgrade', onUpgrade)   // for v0.6
  connectReq.once('connect', onConnect)   // for v0.7 or later
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      assert.equal(head.length, 0)
      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      options.request.emit('error', error)
      self.removeSocket(placeholder)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) return
  
  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket)
    })
  }
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
      { servername: options.host
      , socket: socket
      }
    ))
    cb(secureSocket)
  })
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides)
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== undefined) {
          target[k] = overrides[k]
        }
      }
    }
  }
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments)
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0]
    } else {
      args.unshift('TUNNEL:')
    }
    console.error.apply(console, args)
  }
} else {
  debug = function() {}
}
exports.debug = debug // for test

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/tunnel-agent/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/json-stringify-safe/stringify.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"b3eb0c4e174b4fd3de6278f94c1c93bfce68bd6c-json-stringify-safe/stringify.js"}
require.memoize("b3eb0c4e174b4fd3de6278f94c1c93bfce68bd6c-json-stringify-safe/stringify.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/json-stringify-safe';
module.exports = stringify;

function getSerialize (fn, decycle) {
  var seen = [];
  decycle = decycle || function(key, value) {
    return '[Circular]';
  };
  return function(key, value) {
    var ret = value;
    if (typeof value === 'object' && value) {
      if (seen.indexOf(value) !== -1)
        ret = decycle(key, value);
      else
        seen.push(value);
    }
    if (fn) ret = fn(key, ret);
    return ret;
  }
}

function stringify(obj, fn, spaces, decycle) {
  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);
}

stringify.getSerialize = getSerialize;

return {
    module: (typeof module !== "undefined") ? module : null,
    getSerialize: (typeof getSerialize !== "undefined") ? getSerialize : null,
    stringify: (typeof stringify !== "undefined") ? stringify : null,
    JSON: (typeof JSON !== "undefined") ? JSON : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/json-stringify-safe/stringify.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/forever-agent/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"ac485b684341e74d2d223646d5b98969d287efa9-forever-agent/index.js"}
require.memoize("ac485b684341e74d2d223646d5b98969d287efa9-forever-agent/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/forever-agent';
module.exports = ForeverAgent
ForeverAgent.SSL = ForeverAgentSSL

var util = require('__SYSTEM__/util')
  , Agent = require('__SYSTEM__/http').Agent
  , net = require('__SYSTEM__/net')
  , tls = require('__SYSTEM__/tls')
  , AgentSSL = require('__SYSTEM__/https').Agent

function ForeverAgent(options) {
  var self = this
  self.options = options || {}
  self.requests = {}
  self.sockets = {}
  self.freeSockets = {}
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
  self.on('free', function(socket, host, port) {
    var name = host + ':' + port
    if (self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket)
    } else if (self.sockets[name].length < self.minSockets) {
      if (!self.freeSockets[name]) self.freeSockets[name] = []
      self.freeSockets[name].push(socket)
      
      // if an error happens while we don't use the socket anyway, meh, throw the socket away
      var onIdleError = function() {
        socket.destroy()
      }
      socket._onIdleError = onIdleError
      socket.on('error', onIdleError)
    } else {
      // If there are no pending requests just destroy the
      // socket and it will get removed from the pool. This
      // gets us out of timeout issues and allows us to
      // default to Connection:keep-alive.
      socket.destroy()
    }
  })

}
util.inherits(ForeverAgent, Agent)

ForeverAgent.defaultMinSockets = 5


ForeverAgent.prototype.createConnection = net.createConnection
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = host + ':' + port
  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop()
    idleSocket.removeListener('error', idleSocket._onIdleError)
    delete idleSocket._onIdleError
    req._reusedSocket = true
    req.onSocket(idleSocket)
  } else {
    this.addRequestNoreuse(req, host, port)
  }
}

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  if (this.sockets[name]) {
    var index = this.sockets[name].indexOf(s)
    if (index !== -1) {
      this.sockets[name].splice(index, 1)
    }
  } else if (this.sockets[name] && this.sockets[name].length === 0) {
    // don't leak
    delete this.sockets[name]
    delete this.requests[name]
  }
  
  if (this.freeSockets[name]) {
    var index = this.freeSockets[name].indexOf(s)
    if (index !== -1) {
      this.freeSockets[name].splice(index, 1)
      if (this.freeSockets[name].length === 0) {
        delete this.freeSockets[name]
      }
    }
  }

  if (this.requests[name] && this.requests[name].length) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(name, host, port).emit('free')
  }
}

function ForeverAgentSSL (options) {
  ForeverAgent.call(this, options)
}
util.inherits(ForeverAgentSSL, ForeverAgent)

ForeverAgentSSL.prototype.createConnection = createConnectionSSL
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

function createConnectionSSL (port, host, options) {
  if (typeof port === 'object') {
    options = port;
  } else if (typeof host === 'object') {
    options = host;
  } else if (typeof options === 'object') {
    options = options;
  } else {
    options = {};
  }

  if (typeof port === 'number') {
    options.port = port;
  }

  if (typeof host === 'string') {
    options.host = host;
  }

  return tls.connect(options);
}

return {
    module: (typeof module !== "undefined") ? module : null,
    ForeverAgent: (typeof ForeverAgent !== "undefined") ? ForeverAgent : null,
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    Agent: (typeof Agent !== "undefined") ? Agent : null,
    net: (typeof net !== "undefined") ? net : null,
    tls: (typeof tls !== "undefined") ? tls : null,
    AgentSSL: (typeof AgentSSL !== "undefined") ? AgentSSL : null,
    ForeverAgentSSL: (typeof ForeverAgentSSL !== "undefined") ? ForeverAgentSSL : null,
    createConnectionSSL: (typeof createConnectionSSL !== "undefined") ? createConnectionSSL : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/forever-agent/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/lib/form_data.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"b31d9d8844fd9f42ca88afa16a6316e74e8a6409-form-data/lib/form_data.js"}
require.memoize("b31d9d8844fd9f42ca88afa16a6316e74e8a6409-form-data/lib/form_data.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/lib';
var CombinedStream = require('combined-stream');
var util = require('__SYSTEM__/util');
var path = require('__SYSTEM__/path');
var http = require('__SYSTEM__/http');
var https = require('__SYSTEM__/https');
var parseUrl = require('__SYSTEM__/url').parse;
var fs = require('__SYSTEM__/fs');
var mime = require('mime');
var async = require('async');

module.exports = FormData;
function FormData() {
  this._overheadLength = 0;
  this._valueLength = 0;
  this._lengthRetrievers = [];

  CombinedStream.call(this);
}
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';

FormData.prototype.append = function(field, value, options) {
  options = options || {};

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') value = ''+value;

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter(field, value, options);

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ trackLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  this._lengthRetrievers.push(function(next) {

    // do we already know the size?
    // 0 additional leaves value from getSyncLength()
    if (options.knownLength != null) {
      next(null, 0);

    // check if it's local file
    } else if (value.hasOwnProperty('fd')) {
      fs.stat(value.path, function(err, stat) {
        if (err) {
          next(err);
          return;
        }

        next(null, stat.size);
      });

    // or http response
    } else if (value.hasOwnProperty('httpVersion')) {
      next(null, +value.headers['content-length']);

    // or request stream http://github.com/mikeal/request
    } else if (value.hasOwnProperty('httpModule')) {
      // wait till response come back
      value.on('response', function(response) {
        value.pause();
        next(null, +response.headers['content-length']);
      });
      value.resume();

    // something else
    } else {
      next('Unknown stream');
    }
  });
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  var boundary = this.getBoundary();
  var header = '';

  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (options.header != null) {
    header = options.header;
  } else {
    header += '--' + boundary + FormData.LINE_BREAK +
      'Content-Disposition: form-data; name="' + field + '"';

    // fs- and request- streams have path property
    // or use custom filename and/or contentType
    // TODO: Use request's response mime-type
    if (options.filename || value.path) {
      header +=
        '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));

    // http response has not
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
      header +=
        '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' + value.headers['content-type'];
    }

    header += FormData.LINE_BREAK + FormData.LINE_BREAK;
  }

  return header;
};

FormData.prototype._multiPartFooter = function(field, value, options) {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--';
};

FormData.prototype.getHeaders = function(userHeaders) {
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (var header in userHeaders) {
    formHeaders[header.toLowerCase()] = userHeaders[header];
  }

  return formHeaders;
}

FormData.prototype.getCustomHeaders = function(contentType) {
    contentType = contentType ? contentType : 'multipart/form-data';

    var formHeaders = {
        'content-type': contentType + '; boundary=' + this.getBoundary(),
        'content-length': this.getLengthSync()
    };

    return formHeaders;
}

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;

    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }

    return knownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._lengthRetrievers.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  async.parallel(this._lengthRetrievers, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  this.getLength(function(err, length) {

    var request
      , options
      , defaults = {
          method : 'post',
          port   : 80,
          headers: this.getHeaders({'Content-Length': length})
      };

    // parse provided url if it's string
    // or treat it as options object
    if (typeof params == 'string') {
      params = parseUrl(params);

      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname
      }, defaults);
    }
    else // use custom params
    {
      options = populate(params, defaults);
    }

    // https if specified, fallback to http in any other case
    if (params.protocol == 'https:') {
      // override default port
      if (!params.port) options.port = 443;
      request = https.request(options);
    } else {
      request = http.request(options);
    }

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }

    return request;
  }.bind(this));
};

/*
 * Santa's little helpers
 */

// populates missing values
function populate(dst, src) {
  for (var prop in src) {
    if (!dst[prop]) dst[prop] = src[prop];
  }
  return dst;
}

return {
    CombinedStream: (typeof CombinedStream !== "undefined") ? CombinedStream : null,
    require: (typeof require !== "undefined") ? require : null,
    util: (typeof util !== "undefined") ? util : null,
    path: (typeof path !== "undefined") ? path : null,
    http: (typeof http !== "undefined") ? http : null,
    https: (typeof https !== "undefined") ? https : null,
    parseUrl: (typeof parseUrl !== "undefined") ? parseUrl : null,
    fs: (typeof fs !== "undefined") ? fs : null,
    mime: (typeof mime !== "undefined") ? mime : null,
    async: (typeof async !== "undefined") ? async : null,
    module: (typeof module !== "undefined") ? module : null,
    FormData: (typeof FormData !== "undefined") ? FormData : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    Math: (typeof Math !== "undefined") ? Math : null,
    process: (typeof process !== "undefined") ? process : null,
    populate: (typeof populate !== "undefined") ? populate : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/lib/form_data.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/lib/combined_stream.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"060655d1be854e806dc31729ef59e2992f3626c0-combined-stream/lib/combined_stream.js"}
require.memoize("060655d1be854e806dc31729ef59e2992f3626c0-combined-stream/lib/combined_stream.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/lib';
var util = require('__SYSTEM__/util');
var Stream = require('__SYSTEM__/stream').Stream;
var DelayedStream = require('delayed-stream');

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')    
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      stream.on('data', this._checkDataSize.bind(this));

      stream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this))
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

return {
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    Stream: (typeof Stream !== "undefined") ? Stream : null,
    DelayedStream: (typeof DelayedStream !== "undefined") ? DelayedStream : null,
    module: (typeof module !== "undefined") ? module : null,
    CombinedStream: (typeof CombinedStream !== "undefined") ? CombinedStream : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/lib/combined_stream.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/lib/delayed_stream.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"1bec134004038e4c00058fd84d773149d7b2e1c9-delayed-stream/lib/delayed_stream.js"}
require.memoize("1bec134004038e4c00058fd84d773149d7b2e1c9-delayed-stream/lib/delayed_stream.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/lib';
var Stream = require('__SYSTEM__/stream').Stream;
var util = require('__SYSTEM__/util');

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

DelayedStream.prototype.__defineGetter__('readable', function() {
  return this.source.readable;
});

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};

return {
    Stream: (typeof Stream !== "undefined") ? Stream : null,
    require: (typeof require !== "undefined") ? require : null,
    util: (typeof util !== "undefined") ? util : null,
    module: (typeof module !== "undefined") ? module : null,
    DelayedStream: (typeof DelayedStream !== "undefined") ? DelayedStream : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/lib/delayed_stream.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/async/lib/async.js","mtime":0,"wrapper":"amd-ish","format":"amd-ish","id":"2e7a010e5b40e11bb94eb021d6eca99d00679e86-async/lib/async.js"}
require.memoize("2e7a010e5b40e11bb94eb021d6eca99d00679e86-async/lib/async.js", 
wrapAMD(function(require, define) {
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

})
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/async/lib/async.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/index.js"}
require.memoize("e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar';
/*!
 * Tobi - Cookie
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var url = require('__SYSTEM__/url');

/**
 * Initialize a new `Cookie` with the given cookie `str` and `req`.
 *
 * @param {String} str
 * @param {IncomingRequest} req
 * @api private
 */

var Cookie = exports = module.exports = function Cookie(str, req) {
  this.str = str;

  // Map the key/val pairs
  str.split(/ *; */).reduce(function(obj, pair){
   var p = pair.indexOf('=');
   var key = p > 0 ? pair.substring(0, p).trim() : pair.trim();
   var lowerCasedKey = key.toLowerCase();
   var value = p > 0 ? pair.substring(p + 1).trim() : true;

   if (!obj.name) {
    // First key is the name
    obj.name = key;
    obj.value = value;
   }
   else if (lowerCasedKey === 'httponly') {
    obj.httpOnly = value;
   }
   else {
    obj[lowerCasedKey] = value;
   }
   return obj;
  }, this);

  // Expires
  this.expires = this.expires
    ? new Date(this.expires)
    : Infinity;

  // Default or trim path
  this.path = this.path
    ? this.path.trim(): req 
    ? url.parse(req.url).pathname: '/';
};

/**
 * Return the original cookie string.
 *
 * @return {String}
 * @api public
 */

Cookie.prototype.toString = function(){
  return this.str;
};

module.exports.Jar = require('./jar')
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar/jar.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/jar.js"}
require.memoize("e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/jar.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar';
/*!
* Tobi - CookieJar
* Copyright(c) 2010 LearnBoost <dev@learnboost.com>
* MIT Licensed
*/

/**
* Module dependencies.
*/

var url = require('__SYSTEM__/url');

/**
* Initialize a new `CookieJar`.
*
* @api private
*/

var CookieJar = exports = module.exports = function CookieJar() {
  this.cookies = [];
};

/**
* Add the given `cookie` to the jar.
*
* @param {Cookie} cookie
* @api private
*/

CookieJar.prototype.add = function(cookie){
  this.cookies = this.cookies.filter(function(c){
    // Avoid duplication (same path, same name)
    return !(c.name == cookie.name && c.path == cookie.path);
  });
  this.cookies.push(cookie);
};

/**
* Get cookies for the given `req`.
*
* @param {IncomingRequest} req
* @return {Array}
* @api private
*/

CookieJar.prototype.get = function(req){
  var path = url.parse(req.url).pathname
    , now = new Date
    , specificity = {};
  return this.cookies.filter(function(cookie){
    if (0 == path.indexOf(cookie.path) && now < cookie.expires
      && cookie.path.length > (specificity[cookie.name] || 0))
      return specificity[cookie.name] = cookie.path.length;
  });
};

/**
* Return Cookie string for the given `req`.
*
* @param {IncomingRequest} req
* @return {String}
* @api private
*/

CookieJar.prototype.cookieString = function(req){
  var cookies = this.get(req);
  if (cookies.length) {
    return cookies.map(function(cookie){
      return cookie.name + '=' + cookie.value;
    }).join('; ');
  }
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar/jar.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/vfs.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/vfs.js"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/vfs.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib';

const VFS = require("pinf-vfs");

for (var name in VFS) {
	exports[name] = VFS[name];
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/lib/vfs.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/lib/vfs.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"ab49b00e842187d508f091e478b4238c6fe2d0a3-pinf-vfs/lib/vfs.js"}
require.memoize("ab49b00e842187d508f091e478b4238c6fe2d0a3-pinf-vfs/lib/vfs.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/lib';

const PATH = require("__SYSTEM__/path");
const UTIL = require("__SYSTEM__/util");
const URL = require("__SYSTEM__/url");
const FS = require("fs-extra");
const EVENTS = require("__SYSTEM__/events");
const PROXY = require("pinf-proxy");


exports.open = function(uri, options, callback) {

	if (typeof options === "function" && typeof callback === "undefined") {
		callback = options;
		options = null;
	}
	options = options || {};

	try {

		var parsedUri = URL.parse(uri);

		if (parsedUri.protocol === "file:") {

			return callback(null, new FileFS(options));

		} else {

			return callback(null, new ProxyFS(uri, options));

		}
	} catch(err) {
		return callback(err);
	}
}

exports.READ_METHODS = {
	"exists": true,
	"existsSync": true,
	"readFile": true,
	"readFileSync": true,
	"openSync": true,
	"readdir": true,
	"readdirSync": true,
	"lstat": true,
	"stat": true,
	"lstatSync": true,
	"statSync": true,
	"readlink": true,
	"readlinkSync": true,
	"createReadStream": true,
	"createWriteStream": true,
	"readJsonFile": true,
	"readJSONFile": true,
	"readJsonFileSync": true,
	"readJSONFileSync": true,
	"readJson": true,
	"readJSON": true,
	"readJsonSync": true,
	"readJSONSync": true,
	"open-read": true,
	"fstat": true,
	"read": true
};

exports.WRITE_METHODS = {
	"truncate": true,
	"truncateSync": true,
	"rmdir": true,
	"rmdirSync": true,
	"mkdir": true,
	"mkdirSync": true,
	"symlink": true,
	"symlinkSync": true,
	"unlink": true,
	"unlinkSync": true,
	"lchmod": true,
	"lchmodSync": true,
	"chmod": true,
	"chmodSync": true,
	"lchown": true,
	"lchownSync": true,
	"chown": true,
	"chownSync": true,
	"utimes": true,
	"utimesSync": true,
	"writeFile": true,
	"writeFileSync": true,
	"appendFile": true,
	"appendFileSync": true,
	"remove": true,
	"removeSync": true,
	"delete": true,
	"deleteSync": true,
	"createFile": true,
	"createFileSync": true,
	"outputFile": true,
	"outputFileSync": true,
	"outputJsonSync": true,
	"outputJSONSync": true,
	"outputJson": true,
	"outputJSON": true,
	"writeJsonFile": true,
	"writeJSONFile": true,
	"writeJsonFileSync": true,
	"writeJSONFileSync": true,
	"writeJson": true,
	"writeJSON": true,
	"writeJsonSync": true,
	"writeJSONSync": true,
	"open-write": true,
	"ftruncate": true,
	"write": true,
	"outputFileAtomic": true
};

var FileFS = function(options) {
	var self = this;
	self._options = options;
	self.READ_METHODS = exports.READ_METHODS;
	self.WRITE_METHODS = exports.WRITE_METHODS;
}

UTIL.inherits(FileFS, EVENTS.EventEmitter);


FileFS.prototype.notifyUsedPath = function(path, method) {
	this.emit("used-path", path, method);
/*
	if (exports.READ_METHODS[method]) {
		console.log(("[pinf-for-nodejs][vfs] use READ method '" + method + "' for: " + path).magenta);
	} else
	if (exports.WRITE_METHODS[method]) {
		console.log(("[pinf-for-nodejs][vfs] use WRITE method '" + method + "' for: " + path).magenta);
	} else {
		console.log(("[pinf-for-nodejs][vfs] use method '" + method + "' for: " + path).magenta);
	}
*/
}

FS.outputFileAtomic = function(path, data, callback) {
	var tmpPath = path + "~" + Date.now();
    return FS.outputFile(tmpPath, data, function(err) {
    	if (err) return callback(err);
    	// Assume file exists.
    	return FS.unlink(path, function() {
    		// We ignore error.
    		return FS.rename(tmpPath, path, callback);
    	});
    });
}

// Intercept all FS methods that have a path like argument.
Object.keys(FS).forEach(function(name) {
	var source = null;
	var args = null;
	var index = -1;
	if (name === "open") {
		FileFS.prototype[name] = function() {
			var mode = "write";
			if (arguments[1] === "r" || arguments[1] === "rs") {
				mode = "read";
			}
			this.notifyUsedPath(arguments[0], name + "-" + mode);
			return FS[name].apply(null, arguments);
		};
	} else
	if (
		typeof FS[name] === "function" &&
		/^[a-z]/.test(name) &&
		(source = FS[name].toString()) &&
		(args = source.match(/function[^\(]+\(([^\)]*)\)/)[1].split(", ")) &&
		(
			(index = args.indexOf("path")) >= 0 ||
			(index = args.indexOf("dir")) >= 0 ||
			(index = args.indexOf("file")) >= 0 ||
			(index = args.indexOf("filename")) >= 0
		)
	) {
		FileFS.prototype[name] = function() {
			this.notifyUsedPath(arguments[index], name);
			var cb = arguments[arguments.length-1];
			if (typeof cb === "function" && name !== "exists") {
				arguments[arguments.length-1] = function(err) {
					if (err) {
						console.error("[pinf-vfs-js] ERROR: While calling '" + name + "' for '" + arguments[index] + "'", err);
					}
					return cb.apply(null, arguments);
				}
			}
			try {
				return FS[name].apply(null, arguments);
			} catch(err) {
				console.error("[pinf-vfs-js] ERROR: While calling '" + name + "' for '" + arguments[index] + "'", err);
				throw err;
			}
		};
	} else {
		FileFS.prototype[name] = FS[name];
	}
});




var ProxyFS = exports.ProxyFS = function(uri, options) {
	var self = this;
	self._rootUri = URL.parse(uri);
	self._options = options;
	self._proxy = null;
	self.READ_METHODS = exports.READ_METHODS;
	self.WRITE_METHODS = exports.WRITE_METHODS;
}

UTIL.inherits(ProxyFS, EVENTS.EventEmitter);

ProxyFS.prototype.open = function(callback) {
	var self = this;
	return PROXY.proxyPortTo(0, self._rootUri.hostname, self._rootUri.port, function(err, proxy) {
		if (err) return callback(err);
		self._proxy = proxy;
		return callback(null, self);
	});
}

ProxyFS.prototype.close = function(callback) {
	return this._proxy.close(callback);
}

ProxyFS.prototype._urlForPath = function(path) {
	return this._rootUri.href.replace(/\/$/, "") + "/" + path.replace(/^\//, "");
}

ProxyFS.prototype.readFile = function(path, callback) {
	var url = this._urlForPath(path);
	return this._proxy.request(url, function(err, res, body) {
		if (err) return callback(err);

// TODO: Deal with different `res.statusCode`.

		return callback(null, body);
	});
}


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/lib/vfs.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/lib/proxy.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"48ac305cf012aab581c31105053b4890047c5b6d-pinf-proxy/lib/proxy.js"}
require.memoize("48ac305cf012aab581c31105053b4890047c5b6d-pinf-proxy/lib/proxy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/lib';

const PATH = require("__SYSTEM__/path");
const FS = require("__SYSTEM__/fs");
const URL = require("__SYSTEM__/url");
const HTTP = require("__SYSTEM__/http");
const HTTPS = require("__SYSTEM__/https");
const HTTP_PROXY = require("http-proxy");
const EMPTY_PORT = require("empty-port");
const REQUEST = require("request");
const TLS = require("__SYSTEM__/tls");
const NET = require("__SYSTEM__/net");


exports.proxyPortTo = function(listenPort, targetHostname, targetPort, options, callback) {
	if (typeof options === "function" && typeof callback === "undefined") {
		callback = options;
		options = null;
	}
	var proxy = new ProxyServer();
	proxy.setTarget(targetHostname, targetPort);
	return proxy.listen(listenPort, options, callback);
}

exports.newProxy = function(options, callback) {
	var proxy = new DualProtocolProxyServer();
	return proxy.listen(options, callback);
}

exports.proxyVia = function(proxyHostname, proxyPort) {
	var agent = new ProxyAgent();
	agent.setProxy(proxyHostname, proxyPort);
	return agent;
}


var DualProtocolProxyServer = exports.DualProtocolProxyServer = function() {
	this._httpProxy = new ProxyServer();
	this._httpsProxy = new ProxyServer(true);
}
DualProtocolProxyServer.prototype.listen = function(options, callback) {
	var self = this;
	return self._httpProxy.listen(0, options, function(err) {
		if (err) return callback(err);
		var opts = {};
		for (var name in options) {
			opts[name] = options[name];
		}
		opts.https = {
			key: FS.readFileSync(PATH.join(__dirname, "../config/proxy-ssl-private-key"), "utf8"),
			cert: FS.readFileSync(PATH.join(__dirname, "../config/proxy-ssl.crt"), "utf8")
		};
		return self._httpsProxy.listen(0, opts, function(err) {
			if (err) return callback(err);
			return callback(null, self);
		});
	});
}
DualProtocolProxyServer.prototype.close = function(callback) {
	var self = this;
	return self._httpProxy.close(function() {
		return self._httpsProxy.close(callback);
	});
}
DualProtocolProxyServer.prototype.useForRequest = function(req) {
	if (typeof req === "string") {
		req = {
			uri: URL.parse(req)
		};
	}
	if (req.uri.protocol === "https:") {
		return this._httpsProxy.useForRequest(req);
	} else {
		return this._httpProxy.useForRequest(req);
	}
}
DualProtocolProxyServer.prototype.useForEnv = function(env) {
	return this._httpsProxy.useForEnv(this._httpProxy.useForEnv(env));
}





var ProxyServer = exports.ProxyServer = function(secure) {
	this._secure = secure || false;
	this._targetHostname = null;
	this._targetPort = null;
	this._listenPort = null;
	this._server = null;
	this._agent = null;
}
ProxyServer.prototype.setTarget = function(hostname, port) {
	this._targetHostname = hostname;
	this._targetPort = port;
}
ProxyServer.prototype.listen = function(port, options, callback) {
	var self = this;
	if (typeof options === "function" && typeof callback === "undefined") {
		callback = options;
		options = null;
	}
	options = options || {};
	self._listenPort = port;
	function ensurePort(callback) {
		if (self._listenPort > 0) {
			return callback(null);
		}
		return EMPTY_PORT({
			startPort: 3000,
			maxPort: 4000
		}, function(err, port) {
			if (err) return callback(err);
			self._listenPort = port;
			return callback(null);
		});
	}
	return ensurePort(function(err) {
		if (err) return callback(err);
		if (self._targetHostname) {
			self._server = HTTP_PROXY.createServer(self._targetPort, self._targetHostname, {
				enable: {
					// enables `X-Forwarded-For` header
					xforward: (options.enableForwardHeaders === true) ? true : false
				},
				https: options.https || null
			}, function (req, res, proxy) {

// TODO: Tie into cache.

				return proxy.proxyRequest(req, res);
			});
		} else {

			if (options.https) {

				// NOTE: A SSL proxy cannot inspect traffic passing through it!
				// @see http://tools.ietf.org/html/draft-luotonen-ssl-tunneling-03

				// TODO: Get this working when making HTTPS requests using `request` and `curl`.
				//		 `request` wants to connect via TLS while `curl` want to connect via NET.

				self._server = NET.createServer({
					key: options.https.key,
					cert: options.https.cert,
					rejectUnauthorized: false
				}, function(requestingStream) {

					requestingStream.end();
/*
					var targetStream = null;

					requestingStream.on("data", function(chunk) {
//console.log(" >> CHUNK >> ", chunk.toString());

						if (targetStream) {

							targetStream.write(chunk);

						} else {
							// Expecting:
							//   CONNECT www.test.com:443 HTTP/1.1
							//   Host: www.test.com:443
							//   Connection: close
							var headers = {};
							chunk.toString().replace(/\r/g, "").split("\n").forEach(function(line) {
								var m = line.match(/^([^:]+):\s*(.*)$/);
								if (m) {
									headers[m[1]] = m[2];
								}
							});

							if (!headers["Host"]) {
								return requestingStream.end();
							}
							var hostnamePort = headers["Host"].split(":");
							if (hostnamePort[1] != 443) {
								return requestingStream.end();
							}

							targetStream = require("__SYSTEM__/net").connect({
								host: hostnamePort[0],
								port: 443
							}, function() {
								requestingStream.write("HTTP/1.0 200 Connection established\n\n");
							});

							targetStream.on("error", function(err) {
								console.error(err.stack);
								requestingStream.close();
							});
							targetStream.on("close", function() {
								requestingStream.close();
							});
							targetStream.on("data", function(chunk) {
//console.log(" << CHUNK << ", chunk.toString());								
								requestingStream.write(chunk);
							});
							requestingStream.once("close", function() {
								targetStream.close();							
							});
						}
					});
*/
				});

			} else {

				self._server = HTTP_PROXY.createServer({
					enable: {
						// enables `X-Forwarded-For` header
						xforward: (options.enableForwardHeaders === true) ? true : false
					},
					https: options.https || null
				}, function (req, res, proxy) {
					var parsedUrl = URL.parse(req.url);
					if (!parsedUrl.hostname) {
						res.writeHead(404);
						return res.end();
					}

// TODO: Tie into cache.

					return proxy.proxyRequest(req, res, {
						host: parsedUrl.hostname,
						port: parsedUrl.port || 80
					});
				});
			}
		}
		self._server.listen(self._listenPort, "127.0.0.1");
		self._agent = new ProxyAgent(options.https);
		self._agent.setProxy("127.0.0.1", self._listenPort);
		return callback(null, self);
	});
}
ProxyServer.prototype.getPort = function() {
	return this._listenPort;
}
ProxyServer.prototype.close = function(callback) {
	return this._server.close(callback);
}
ProxyServer.prototype.useForRequest = function(req) {
	return this._agent.addToRequest(req);
}
ProxyServer.prototype.useForEnv = function(env) {
	return this._agent.addToEnv(env);
}
ProxyServer.prototype.request = function(req, callback) {
	return REQUEST(this.useForRequest(req), callback);
}


var ProxyAgent = exports.ProxyAgent = function(secure) {
	this._proxyHostname = null;
	this._proxyPort = null;
	this._secure = secure || false;
}
ProxyAgent.prototype.setProxy = function(hostname, port) {
	this._proxyHostname = hostname;
	this._proxyPort = port;
}
// `req` must conform to first argument of `request` (https://github.com/mikeal/request).
ProxyAgent.prototype.addToRequest = function(req, options) {
	options = options || {};
	options.maxSockets = options.maxSockets || 10;
	if (typeof req === "string") {
		req = {
			uri: URL.parse(req)
		};
	}
	if (typeof req.proxy !== "undefined") {
		console.log("WARNING: `req.proxy` already set!", req, new Error().stack);
	}
	var secure = (req.uri.protocol === "https:");
	req.proxy = {
		protocol: secure ? "https:" : "http:",
		hostname: this._proxyHostname,
		port: this._proxyPort
	};
	if (secure) {
		req.key = this._secure.key;
		req.cert = this._secure.cert;
		req.rejectUnhauthorized = false;
		// HACK: https://github.com/mikeal/request/issues/418
		process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"
	}
	return req;
}
// `env` are standard UNIX ENV variables.
ProxyAgent.prototype.addToEnv = function(env, options) {
	options = options || {};
	if (this._secure) {
//		env.HTTPS_PROXY = "https://" + this._proxyHostname + (this._proxyPort ? ":" + this._proxyPort : 443);
		// @see http://curl.haxx.se/mail/archive-2001-12/0034.html
//		env.https_proxy = env.HTTPS_PROXY;
	} else {
		env.HTTP_PROXY = "http://" + this._proxyHostname + (this._proxyPort ? ":" + this._proxyPort : "");
		// @see http://curl.haxx.se/mail/archive-2001-12/0034.html
		env.http_proxy = env.HTTP_PROXY;
	}
	return env;
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/lib/proxy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy.js"}
require.memoize("b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib';
/*
  node-http-proxy.js: http proxy for node.js

  Copyright (c) 2010 Charlie Robbins, Mikeal Rogers, Marak Squires, Fedor Indutny

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

var util = require('__SYSTEM__/util'),
    http = require('__SYSTEM__/http'),
    https = require('__SYSTEM__/https'),
    events = require('__SYSTEM__/events'),
    maxSockets = 100;

//
// Expose version information through `pkginfo`.
//
require('pkginfo')(module, 'version');

//
// ### Export the relevant objects exposed by `node-http-proxy`
//
var HttpProxy    = exports.HttpProxy    = require('./node-http-proxy/http-proxy').HttpProxy,
    ProxyTable   = exports.ProxyTable   = require('./node-http-proxy/proxy-table').ProxyTable,
    RoutingProxy = exports.RoutingProxy = require('./node-http-proxy/routing-proxy').RoutingProxy;

//
// ### function createServer ([port, host, options, handler])
// #### @port {number} **Optional** Port to use on the proxy target host.
// #### @host {string} **Optional** Host of the proxy target.
// #### @options {Object} **Optional** Options for the HttpProxy instance used
// #### @handler {function} **Optional** Request handler for the server
// Returns a server that manages an instance of HttpProxy. Flexible arguments allow for:
//
// * `httpProxy.createServer(9000, 'localhost')`
// * `httpProxy.createServer(9000, 'localhost', options)
// * `httpPRoxy.createServer(function (req, res, proxy) { ... })`
//
exports.createServer = function () {
  var args = Array.prototype.slice.call(arguments),
      handlers = [],
      callback,
      options = {},
      message,
      handler,
      server,
      proxy,
      host,
      port;

  //
  // Liberally parse arguments of the form:
  //
  //    httpProxy.createServer('localhost', 9000, callback);
  //    httpProxy.createServer({ host: 'localhost', port: 9000 }, callback);
  //    **NEED MORE HERE!!!**
  //
  args.forEach(function (arg) {
    arg = Number(arg) || arg;
    switch (typeof arg) {
      case 'string':   host = arg; break;
      case 'number':   port = arg; break;
      case 'object':   options = arg || {}; break;
      case 'function': callback = arg; handlers.push(callback); break;
    };
  });

  //
  // Helper function to create intelligent error message(s)
  // for the very liberal arguments parsing performed by
  // `require('http-proxy').createServer()`.
  //
  function validArguments() {
    var conditions = {
      'port and host': function () {
        return port && host;
      },
      'options.target or options.router': function () {
        return options && (options.router ||
          (options.target && options.target.host && options.target.port));
      },
      'or proxy handlers': function () {
        return handlers && handlers.length;
      }
    }

    var missing = Object.keys(conditions).filter(function (name) {
      return !conditions[name]();
    });

    if (missing.length === 3) {
      message = 'Cannot proxy without ' + missing.join(', ');
      return false;
    }

    return true;
  }

  if (!validArguments()) {
    //
    // If `host`, `port` and `options` are all not passed (with valid
    // options) then this server is improperly configured.
    //
    throw new Error(message);
    return;
  }

  //
  // Hoist up any explicit `host` or `port` arguments
  // that have been passed in to the options we will
  // pass to the `httpProxy.HttpProxy` constructor.
  //
  options.target      = options.target      || {};
  options.target.port = options.target.port || port;
  options.target.host = options.target.host || host;

  if (options.target && options.target.host && options.target.port) {
    //
    // If an explicit `host` and `port` combination has been passed
    // to `.createServer()` then instantiate a hot-path optimized
    // `HttpProxy` object and add the "proxy" middleware layer.
    //
    proxy = new HttpProxy(options);
    handlers.push(function (req, res) {
      proxy.proxyRequest(req, res);
    });
  }
  else {
    //
    // If no explicit `host` or `port` combination has been passed then
    // we have to assume that this is a "go-anywhere" Proxy (i.e. a `RoutingProxy`).
    //
    proxy = new RoutingProxy(options);

    if (options.router) {
      //
      // If a routing table has been supplied than we assume
      // the user intends us to add the "proxy" middleware layer
      // for them
      //
      handlers.push(function (req, res) {
        proxy.proxyRequest(req, res);
      });

      proxy.on('routes', function (routes) {
        server.emit('routes', routes);
      });
    }
  }

  //
  // Create the `http[s].Server` instance which will use
  // an instance of `httpProxy.HttpProxy`.
  //
  handler = handlers.length > 1
    ? exports.stack(handlers, proxy)
    : function (req, res) { handlers[0](req, res, proxy) };

  server  = options.https
    ? https.createServer(options.https, handler)
    : http.createServer(handler);

  server.on('close', function () {
    proxy.close();
  });

  if (!callback) {
    //
    // If an explicit callback has not been supplied then
    // automagically proxy the request using the `HttpProxy`
    // instance we have created.
    //
    server.on('upgrade', function (req, socket, head) {
      proxy.proxyWebSocketRequest(req, socket, head);
    });
  }

  //
  // Set the proxy on the server so it is available
  // to the consumer of the server
  //
  server.proxy = proxy;
  return server;
};

//
// ### function buffer (obj)
// #### @obj {Object} Object to pause events from
// Buffer `data` and `end` events from the given `obj`.
// Consumers of HttpProxy performing async tasks
// __must__ utilize this utility, to re-emit data once
// the async operation has completed, otherwise these
// __events will be lost.__
//
//      var buffer = httpProxy.buffer(req);
//      fs.readFile(path, function () {
//         httpProxy.proxyRequest(req, res, host, port, buffer);
//      });
//
// __Attribution:__ This approach is based heavily on
// [Connect](https://github.com/senchalabs/connect/blob/master/lib/utils.js#L157).
// However, this is not a big leap from the implementation in node-http-proxy < 0.4.0.
// This simply chooses to manage the scope of the events on a new Object literal as opposed to
// [on the HttpProxy instance](https://github.com/nodejitsu/node-http-proxy/blob/v0.3.1/lib/node-http-proxy.js#L154).
//
exports.buffer = function (obj) {
  var events = [],
      onData,
      onEnd;

  obj.on('data', onData = function (data, encoding) {
    events.push(['data', data, encoding]);
  });

  obj.on('end', onEnd = function (data, encoding) {
    events.push(['end', data, encoding]);
  });

  return {
    end: function () {
      obj.removeListener('data', onData);
      obj.removeListener('end', onEnd);
    },
    destroy: function () {
      this.end();
     	this.resume = function () {
     	  console.error("Cannot resume buffer after destroying it.");
     	};

     	onData = onEnd = events = obj = null;
    },
    resume: function () {
      this.end();
      for (var i = 0, len = events.length; i < len; ++i) {
        obj.emit.apply(obj, events[i]);
      }
    }
  };
};

//
// ### function getMaxSockets ()
// Returns the maximum number of sockets
// allowed on __every__ outgoing request
// made by __all__ instances of `HttpProxy`
//
exports.getMaxSockets = function () {
  return maxSockets;
};

//
// ### function setMaxSockets ()
// Sets the maximum number of sockets
// allowed on __every__ outgoing request
// made by __all__ instances of `HttpProxy`
//
exports.setMaxSockets = function (value) {
  maxSockets = value;
};

//
// ### function stack (middlewares, proxy)
// #### @middlewares {Array} Array of functions to stack.
// #### @proxy {HttpProxy|RoutingProxy} Proxy instance to
// Iteratively build up a single handler to the `http.Server`
// `request` event (i.e. `function (req, res)`) by wrapping
// each middleware `layer` into a `child` middleware which
// is in invoked by the parent (i.e. predecessor in the Array).
//
// adapted from https://github.com/creationix/stack
//
exports.stack = function stack (middlewares, proxy) {
  var handle;
  middlewares.reverse().forEach(function (layer) {
    var child = handle;
    handle = function (req, res) {
      var next = function (err) {
        if (err) {
          if (! proxy.emit('middlewareError', err, req, res)) {
            console.error('Error in middleware(s): %s', err.stack);
          }

          if (res._headerSent) {
            res.destroy();
          }
          else {
            res.statusCode = 500;
            res.setHeader('Content-Type', 'text/plain');
            res.end('Internal Server Error');
          }

          return;
        }

        if (child) {
          child(req, res);
        }
      };

      //
      // Set the prototype of the `next` function to the instance
      // of the `proxy` so that in can be used interchangably from
      // a `connect` style callback and a true `HttpProxy` object.
      //
      // e.g. `function (req, res, next)` vs. `function (req, res, proxy)`
      //
      next.__proto__ = proxy;
      layer(req, res, next);
    };
  });

  return handle;
};

//
// ### function _getAgent (host, port, secure)
// #### @options {Object} Options to use when creating the agent.
//
//    {
//      host: 'localhost',
//      port: 9000,
//      https: true,
//      maxSockets: 100
//    }
//
// Createsan agent from the `http` or `https` module
// and sets the `maxSockets` property appropriately.
//
exports._getAgent = function _getAgent (options) {
  if (!options || !options.host) {
    throw new Error('`options.host` is required to create an Agent.');
  }

  if (!options.port) {
    options.port = options.https ? 443 : 80;
  }

  var Agent = options.https ? https.Agent : http.Agent,
      agent;

  // require('http-proxy').setMaxSockets() should override http's default
  // configuration value (which is pretty low).
  options.maxSockets = options.maxSockets || maxSockets;
  agent = new Agent(options);

  return agent;
}

//
// ### function _getProtocol (options)
// #### @options {Object} Options for the proxy target.
// Returns the appropriate node.js core protocol module (i.e. `http` or `https`)
// based on the `options` supplied.
//
exports._getProtocol = function _getProtocol (options) {
  return options.https ? https : http;
};


//
// ### function _getBase (options)
// #### @options {Object} Options for the proxy target.
// Returns the relevate base object to create on outgoing proxy request.
// If `options.https` are supplied, this function respond with an object
// containing the relevant `ca`, `key`, and `cert` properties.
//
exports._getBase = function _getBase (options) {
  var result = function () {};

  if (options.https && typeof options.https === 'object') {
    ['ca', 'cert', 'key'].forEach(function (key) {
      if (options.https[key]) {
        result.prototype[key] = options.https[key];
      }
    });
  }

  return result;
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/pkginfo/lib/pkginfo.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"b8a541404830c1d27cc31b32993830e7093c74ee-pkginfo/lib/pkginfo.js"}
require.memoize("b8a541404830c1d27cc31b32993830e7093c74ee-pkginfo/lib/pkginfo.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/pkginfo/lib';
/*
 * pkginfo.js: Top-level include for the pkginfo module
 *
 * (C) 2011, Charlie Robbins
 *
 */
 
var fs = require('__SYSTEM__/fs'),
    path = require('__SYSTEM__/path');

//
// ### function pkginfo ([options, 'property', 'property' ..])
// #### @pmodule {Module} Parent module to read from.
// #### @options {Object|Array|string} **Optional** Options used when exposing properties.
// #### @arguments {string...} **Optional** Specified properties to expose.
// Exposes properties from the package.json file for the parent module on 
// it's exports. Valid usage:
//
// `require('pkginfo')()`
//
// `require('pkginfo')('version', 'author');`
//
// `require('pkginfo')(['version', 'author']);`
//
// `require('pkginfo')({ include: ['version', 'author'] });`
//
var pkginfo = module.exports = function (pmodule, options) {
  var args = [].slice.call(arguments, 2).filter(function (arg) {
    return typeof arg === 'string';
  });
  
  //
  // **Parse variable arguments**
  //
  if (Array.isArray(options)) {
    //
    // If the options passed in is an Array assume that
    // it is the Array of properties to expose from the
    // on the package.json file on the parent module.
    //
    options = { include: options };
  }
  else if (typeof options === 'string') {
    //
    // Otherwise if the first argument is a string, then
    // assume that it is the first property to expose from
    // the package.json file on the parent module.
    //
    options = { include: [options] };
  }
  
  //
  // **Setup default options**
  //
  options = options || {};
  
  // ensure that includes have been defined
  options.include = options.include || [];
  
  if (args.length > 0) {
    //
    // If additional string arguments have been passed in
    // then add them to the properties to expose on the 
    // parent module. 
    //
    options.include = options.include.concat(args);
  }
  
  var pkg = pkginfo.read(pmodule, options.dir).package;
  Object.keys(pkg).forEach(function (key) {
    if (options.include.length > 0 && !~options.include.indexOf(key)) {
      return;
    }
    
    if (!pmodule.exports[key]) {
      pmodule.exports[key] = pkg[key];
    }
  });
  
  return pkginfo;
};

//
// ### function find (dir)
// #### @pmodule {Module} Parent module to read from.
// #### @dir {string} **Optional** Directory to start search from.
// Searches up the directory tree from `dir` until it finds a directory
// which contains a `package.json` file. 
//
pkginfo.find = function (pmodule, dir) {
  if (! dir) {
    dir = path.dirname(pmodule.filename);
  }
  
  var files = fs.readdirSync(dir);
  
  if (~files.indexOf('package.json')) {
    return path.join(dir, 'package.json');
  }
  
  if (dir === '/') {
    throw new Error('Could not find package.json up from: ' + dir);
  }
  else if (!dir || dir === '.') {
    throw new Error('Cannot find package.json from unspecified directory');
  }
  
  return pkginfo.find(pmodule, path.dirname(dir));
};

//
// ### function read (pmodule, dir)
// #### @pmodule {Module} Parent module to read from.
// #### @dir {string} **Optional** Directory to start search from.
// Searches up the directory tree from `dir` until it finds a directory
// which contains a `package.json` file and returns the package information.
//
pkginfo.read = function (pmodule, dir) { 
  dir = pkginfo.find(pmodule, dir);
  
  var data = fs.readFileSync(dir).toString();
      
  return {
    dir: dir, 
    package: JSON.parse(data)
  };
};

//
// Call `pkginfo` on this module and expose version.
//
pkginfo(module, {
  dir: __dirname,
  include: ['version'],
  target: pkginfo
});
return {
    fs: (typeof fs !== "undefined") ? fs : null,
    require: (typeof require !== "undefined") ? require : null,
    path: (typeof path !== "undefined") ? path : null,
    pkginfo: (typeof pkginfo !== "undefined") ? pkginfo : null,
    module: (typeof module !== "undefined") ? module : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    JSON: (typeof JSON !== "undefined") ? JSON : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/pkginfo/lib/pkginfo.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy/http-proxy.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy/http-proxy.js"}
require.memoize("b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy/http-proxy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy';
/*
  node-http-proxy.js: http proxy for node.js

  Copyright (c) 2010 Charlie Robbins, Mikeal Rogers, Marak Squires, Fedor Indutny

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

var events = require('__SYSTEM__/events'),
    http = require('__SYSTEM__/http'),
    util = require('__SYSTEM__/util'),
    url = require('__SYSTEM__/url'),
    httpProxy = require('../node-http-proxy');

//
// @private {RegExp} extractPort
// Reusable regular expression for getting the
// port from a host string.
//
var extractPort = /:(\d+)$/;

//
// ### function HttpProxy (options)
// #### @options {Object} Options for this instance.
// Constructor function for new instances of HttpProxy responsible
// for managing the life-cycle of streaming reverse proxyied HTTP requests.
//
// Example options:
//
//      {
//        target: {
//          host: 'localhost',
//          port: 9000
//        },
//        forward: {
//          host: 'localhost',
//          port: 9001
//        }
//      }
//
var HttpProxy = exports.HttpProxy = function (options) {
  if (!options || !options.target) {
    throw new Error('Both `options` and `options.target` are required.');
  }

  events.EventEmitter.call(this);

  var self  = this;

  //
  // Setup basic proxying options:
  //
  // * forward {Object} Options for a forward-proxy (if-any)
  // * target {Object} Options for the **sole** proxy target of this instance
  //
  this.forward  = options.forward;
  this.target   = options.target;
  this.timeout = options.timeout;

  //
  // Setup the necessary instances instance variables for
  // the `target` and `forward` `host:port` combinations
  // used by this instance.
  //
  // * agent {http[s].Agent} Agent to be used by this instance.
  // * protocol {http|https} Core node.js module to make requests with.
  // * base {Object} Base object to create when proxying containing any https settings.
  //
  function setupProxy (key) {
    self[key].agent    = httpProxy._getAgent(self[key]);
    self[key].protocol = httpProxy._getProtocol(self[key]);
    self[key].base     = httpProxy._getBase(self[key]);
  }

  setupProxy('target');
  if (this.forward) {
    setupProxy('forward');
  }

  //
  // Setup opt-in features
  //
  this.enable          = options.enable || {};
  this.enable.xforward = typeof this.enable.xforward === 'boolean'
    ? this.enable.xforward
    : true;

  // if event listener is set then  use it else unlimited.
  this.eventListenerCount = typeof options.eventListenerCount === 'number'? options.eventListenerCount : 0 ; 

  //
  // Setup additional options for WebSocket proxying. When forcing
  // the WebSocket handshake to change the `sec-websocket-location`
  // and `sec-websocket-origin` headers `options.source` **MUST**
  // be provided or the operation will fail with an `origin mismatch`
  // by definition.
  //
  this.source       = options.source       || { host: 'localhost', port: 80 };
  this.source.https = this.source.https    || options.https;
  this.changeOrigin = options.changeOrigin || false;
};

// Inherit from events.EventEmitter
util.inherits(HttpProxy, events.EventEmitter);

//
// ### function proxyRequest (req, res, buffer)
// #### @req {ServerRequest} Incoming HTTP Request to proxy.
// #### @res {ServerResponse} Outgoing HTTP Request to write proxied data to.
// #### @buffer {Object} Result from `httpProxy.buffer(req)`
//
HttpProxy.prototype.proxyRequest = function (req, res, buffer) {
  var self = this,
      errState = false,
      outgoing = new(this.target.base),
      reverseProxy,
      location;

  // If this is a DELETE request then set the "content-length"
  // header (if it is not already set)
  if (req.method === 'DELETE') {
    req.headers['content-length'] = req.headers['content-length'] || '0';
  }

  //
  // Add common proxy headers to the request so that they can
  // be availible to the proxy target server. If the proxy is
  // part of proxy chain it will append the address:
  //
  // * `x-forwarded-for`: IP Address of the original request
  // * `x-forwarded-proto`: Protocol of the original request
  // * `x-forwarded-port`: Port of the original request.
  //
  if (this.enable.xforward && req.connection && req.socket) {
    if (req.headers['x-forwarded-for']) {
      var addressToAppend = "," + req.connection.remoteAddress || req.socket.remoteAddress;
      req.headers['x-forwarded-for'] += addressToAppend;
    }
    else {
      req.headers['x-forwarded-for'] = req.connection.remoteAddress || req.socket.remoteAddress;
    }

    if (req.headers['x-forwarded-port']) {
      var portToAppend = "," + getPortFromHostHeader(req);
      req.headers['x-forwarded-port'] += portToAppend;
    }
    else {
      req.headers['x-forwarded-port'] = getPortFromHostHeader(req);
    }

    if (req.headers['x-forwarded-proto']) {
      var protoToAppend = "," + getProto(req);
      req.headers['x-forwarded-proto'] += protoToAppend;
    }
    else {
      req.headers['x-forwarded-proto'] = getProto(req);
    }
  }

  if (this.timeout) {
    req.socket.setTimeout(this.timeout);
  }

  //
  // Emit the `start` event indicating that we have begun the proxy operation.
  //
  this.emit('start', req, res, this.target);

  //
  // If forwarding is enabled for this instance, foward proxy the
  // specified request to the address provided in `this.forward`
  //
  if (this.forward) {
    this.emit('forward', req, res, this.forward);
    this._forwardRequest(req);
  }

  //
  // #### function proxyError (err)
  // #### @err {Error} Error contacting the proxy target
  // Short-circuits `res` in the event of any error when
  // contacting the proxy target at `host` / `port`.
  //
  function proxyError(err) {
    errState = true;

    //
    // Emit an `error` event, allowing the application to use custom
    // error handling. The error handler should end the response.
    //
    if (self.emit('proxyError', err, req, res)) {
      return;
    }

    res.writeHead(500, { 'Content-Type': 'text/plain' });

    if (req.method !== 'HEAD') {
      //
      // This NODE_ENV=production behavior is mimics Express and
      // Connect.
      //
      if (process.env.NODE_ENV === 'production') {
        res.write('Internal Server Error');
      }
      else {
        res.write('An error has occurred: ' + JSON.stringify(err));
      }
    }

    try { res.end() }
    catch (ex) { console.error("res.end error: %s", ex.message) }
  }

  //
  // Setup outgoing proxy with relevant properties.
  //
  outgoing.host       = this.target.host;
  outgoing.hostname   = this.target.hostname;
  outgoing.port       = this.target.port;
  outgoing.socketPath = this.target.socketPath;
  outgoing.agent      = this.target.agent;
  outgoing.method     = req.method;
  outgoing.path       = url.parse(req.url).path;
  outgoing.headers    = req.headers;

  //
  // If the changeOrigin option is specified, change the
  // origin of the host header to the target URL! Please
  // don't revert this without documenting it!
  //
  if (this.changeOrigin) {
    outgoing.headers.host = this.target.host;
    // Only add port information to the header if not default port
    // for this protocol.
    // See https://github.com/nodejitsu/node-http-proxy/issues/458
    if (this.target.port !== 443 && this.target.https ||
        this.target.port !== 80 && !this.target.https) {
      outgoing.headers.host += ':' + this.target.port;
    }
  }

  //
  // Open new HTTP request to internal resource with will act
  // as a reverse proxy pass
  //
  reverseProxy = this.target.protocol.request(outgoing, function (response) {
    //
    // Process the `reverseProxy` `response` when it's received.
    //
    if (req.httpVersion === '1.0') {
      if (req.headers.connection) {
        response.headers.connection = req.headers.connection
      } else {
        response.headers.connection = 'close'
      }
    } else if (!response.headers.connection) {
      if (req.headers.connection) { response.headers.connection = req.headers.connection }
      else {
        response.headers.connection = 'keep-alive'
      }
    }

    // Remove `Transfer-Encoding` header if client's protocol is HTTP/1.0
    // or if this is a DELETE request with no content-length header.
    // See: https://github.com/nodejitsu/node-http-proxy/pull/373
    if (req.httpVersion === '1.0' || (req.method === 'DELETE'
      && !req.headers['content-length'])) {
      delete response.headers['transfer-encoding'];
    }

    if ((response.statusCode === 301 || response.statusCode === 302)
      && typeof response.headers.location !== 'undefined') {
      location = url.parse(response.headers.location);
      if (location.host === req.headers.host) {
        if (self.source.https && !self.target.https) {
          response.headers.location = response.headers.location.replace(/^http\:/, 'https:');
        }
        if (self.target.https && !self.source.https) {
          response.headers.location = response.headers.location.replace(/^https\:/, 'http:');
        }
      }
    }

    //
    // When the `reverseProxy` `response` ends, end the
    // corresponding outgoing `res` unless we have entered
    // an error state. In which case, assume `res.end()` has
    // already been called and the 'error' event listener
    // removed.
    //
    var ended = false;
    response.on('close', function () {
      if (!ended) { response.emit('end') }
    });

    //
    // After reading a chunked response, the underlying socket
    // will hit EOF and emit a 'end' event, which will abort
    // the request. If the socket was paused at that time,
    // pending data gets discarded, truncating the response.
    // This code makes sure that we flush pending data.
    //
    response.connection.on('end', function () {
      if (response.readable && response.resume) {
        response.resume();
      }
    });

    response.on('end', function () {
      ended = true;
      if (!errState) {
        try { res.end() }
        catch (ex) { console.error("res.end error: %s", ex.message) }

        // Emit the `end` event now that we have completed proxying
        self.emit('end', req, res, response);
      }
    });

    // Allow observer to modify headers or abort response
    try { self.emit('proxyResponse', req, res, response) }
    catch (ex) {
      errState = true;
      return;
    }

    // Set the headers of the client response
    if (res.sentHeaders !== true) {
      Object.keys(response.headers).forEach(function (key) {
        res.setHeader(key, response.headers[key]);
      });
      res.writeHead(response.statusCode);
    }

    function ondata(chunk) {
      if (res.writable) {
        // Only pause if the underlying buffers are full,
        // *and* the connection is not in 'closing' state.
        // Otherwise, the pause will cause pending data to
        // be discarded and silently lost.
        if (false === res.write(chunk) && response.pause
            && response.connection.readable) {
          response.pause();
        }
      }
    }

    response.on('data', ondata);

    function ondrain() {
      if (response.readable && response.resume) {
        response.resume();
      }
    }

    res.on('drain', ondrain);
  });

  // allow unlimited listeners ... 
  reverseProxy.setMaxListeners(this.eventListenerCount);

  //
  // Handle 'error' events from the `reverseProxy`. Setup timeout override if needed
  //
  reverseProxy.once('error', proxyError);

  // Set a timeout on the socket if `this.timeout` is specified.
  reverseProxy.once('socket', function (socket) {
    if (self.timeout) {
      socket.setTimeout(self.timeout);
    }
  });

  //
  // Handle 'error' events from the `req` (e.g. `Parse Error`).
  //
  req.on('error', proxyError);

  //
  // If `req` is aborted, we abort our `reverseProxy` request as well.
  //
  req.on('aborted', function () {
    reverseProxy.abort();
  });

  //
  // For each data `chunk` received from the incoming
  // `req` write it to the `reverseProxy` request.
  //
  req.on('data', function (chunk) {
    if (!errState) {
      var flushed = reverseProxy.write(chunk);
      if (!flushed) {
        req.pause();
        reverseProxy.once('drain', function () {
          try { req.resume() }
          catch (er) { console.error("req.resume error: %s", er.message) }
        });

        //
        // Force the `drain` event in 100ms if it hasn't
        // happened on its own.
        //
        setTimeout(function () {
          reverseProxy.emit('drain');
        }, 100);
      }
    }
  });

  //
  // When the incoming `req` ends, end the corresponding `reverseProxy`
  // request unless we have entered an error state.
  //
  req.on('end', function () {
    if (!errState) {
      reverseProxy.end();
    }
  });

  //Aborts reverseProxy if client aborts the connection.
  req.on('close', function () {
    if (!errState) {
      reverseProxy.abort();
    }
  });

  //
  // If we have been passed buffered data, resume it.
  //
  if (buffer) {
    return !errState
      ? buffer.resume()
      : buffer.destroy();
  }
};

//
// ### function proxyWebSocketRequest (req, socket, head, buffer)
// #### @req {ServerRequest} Websocket request to proxy.
// #### @socket {net.Socket} Socket for the underlying HTTP request
// #### @head {string} Headers for the Websocket request.
// #### @buffer {Object} Result from `httpProxy.buffer(req)`
// Performs a WebSocket proxy operation to the location specified by
// `this.target`.
//
HttpProxy.prototype.proxyWebSocketRequest = function (req, socket, upgradeHead, buffer) {
  var self      = this,
      outgoing  = new(this.target.base),
      listeners = {},
      errState  = false,
      CRLF      = '\r\n',
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

  //
  // WebSocket requests must have the `GET` method and
  // the `upgrade:websocket` header
  //
  if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket') {
    //
    // This request is not WebSocket request
    //
    return socket.destroy();
  }

  //
  // Add common proxy headers to the request so that they can
  // be availible to the proxy target server. If the proxy is
  // part of proxy chain it will append the address:
  //
  // * `x-forwarded-for`: IP Address of the original request
  // * `x-forwarded-proto`: Protocol of the original request
  // * `x-forwarded-port`: Port of the original request.
  //
  if (this.enable.xforward && req.connection) {
    if (req.headers['x-forwarded-for']) {
      var addressToAppend = "," + req.connection.remoteAddress || socket.remoteAddress;
      req.headers['x-forwarded-for'] += addressToAppend;
    }
    else {
      req.headers['x-forwarded-for'] = req.connection.remoteAddress || socket.remoteAddress;
    }

    if (req.headers['x-forwarded-port']) {
      var portToAppend = "," + getPortFromHostHeader(req);
      req.headers['x-forwarded-port'] += portToAppend;
    }
    else {
      req.headers['x-forwarded-port'] = getPortFromHostHeader(req);
    }

    if (req.headers['x-forwarded-proto']) {
      var protoToAppend = "," + (req.connection.pair ? 'wss' : 'ws');
      req.headers['x-forwarded-proto'] += protoToAppend;
    }
    else {
      req.headers['x-forwarded-proto'] = req.connection.pair ? 'wss' : 'ws';
    }
  }

  self.emit('websocket:start', req, socket, head, this.target);

  //
  // Helper function for setting appropriate socket values:
  // 1. Turn of all bufferings
  // 2. For server set KeepAlive
  //
  function _socket(socket, keepAlive) {
    socket.setTimeout(0);
    socket.setNoDelay(true);

    if (keepAlive) {
      if (socket.setKeepAlive) {
        socket.setKeepAlive(true, 0);
      }
      else if (socket.pair.cleartext.socket.setKeepAlive) {
        socket.pair.cleartext.socket.setKeepAlive(true, 0);
      }
    }
  }

  //
  // Setup the incoming client socket.
  //
  _socket(socket, true);

  //
  // On `upgrade` from the Agent socket, listen to
  // the appropriate events.
  //
  function onUpgrade (reverseProxy, proxySocket) {
    if (!reverseProxy) {
      proxySocket.end();
      socket.end();
      return;
    }

    //
    // Any incoming data on this WebSocket to the proxy target
    // will be written to the `reverseProxy` socket.
    //
    proxySocket.on('data', listeners.onIncoming = function (data) {
      if (reverseProxy.incoming.socket.writable) {
        try {
          self.emit('websocket:outgoing', req, socket, head, data);
          var flushed = reverseProxy.incoming.socket.write(data);
          if (!flushed) {
            proxySocket.pause();
            reverseProxy.incoming.socket.once('drain', function () {
              try { proxySocket.resume() }
              catch (er) { console.error("proxySocket.resume error: %s", er.message) }
            });

            //
            // Force the `drain` event in 100ms if it hasn't
            // happened on its own.
            //
            setTimeout(function () {
              reverseProxy.incoming.socket.emit('drain');
            }, 100);
          }
        }
        catch (ex) {
          detach();
        }
      }
    });

    //
    // Any outgoing data on this Websocket from the proxy target
    // will be written to the `proxySocket` socket.
    //
    reverseProxy.incoming.socket.on('data', listeners.onOutgoing = function (data) {
      try {
        self.emit('websocket:incoming', reverseProxy, reverseProxy.incoming, head, data);
        var flushed = proxySocket.write(data);
        if (!flushed) {
          reverseProxy.incoming.socket.pause();
          proxySocket.once('drain', function () {
            try { reverseProxy.incoming.socket.resume() }
            catch (er) { console.error("reverseProxy.incoming.socket.resume error: %s", er.message) }
          });

          //
          // Force the `drain` event in 100ms if it hasn't
          // happened on its own.
          //
          setTimeout(function () {
            proxySocket.emit('drain');
          }, 100);
        }
      }
      catch (ex) {
        detach();
      }
    });

    //
    // Helper function to detach all event listeners
    // from `reverseProxy` and `proxySocket`.
    //
    function detach() {
      proxySocket.destroySoon();
      proxySocket.removeListener('end', listeners.onIncomingClose);
      proxySocket.removeListener('data', listeners.onIncoming);
      reverseProxy.incoming.socket.destroySoon();
      reverseProxy.incoming.socket.removeListener('end', listeners.onOutgoingClose);
      reverseProxy.incoming.socket.removeListener('data', listeners.onOutgoing);
    }

   //
    // If the incoming `proxySocket` socket closes, then
    // detach all event listeners.
    //
    listeners.onIncomingClose = function () {
      reverseProxy.incoming.socket.destroy();
      detach();

      // Emit the `end` event now that we have completed proxying
      self.emit('websocket:end', req, socket, head);
    }

    //
    // If the `reverseProxy` socket closes, then detach all
    // event listeners.
    //
    listeners.onOutgoingClose = function () {
      proxySocket.destroy();
      detach();
    }

    proxySocket.on('end', listeners.onIncomingClose);
    proxySocket.on('close', listeners.onIncomingClose);
    reverseProxy.incoming.socket.on('end', listeners.onOutgoingClose);
    reverseProxy.incoming.socket.on('close', listeners.onOutgoingClose);
  }

  function getPort (port) {
    port = port || 80;
    return port - 80 === 0 ? '' : ':' + port;
  }

  //
  // Get the protocol, and host for this request and create an instance
  // of `http.Agent` or `https.Agent` from the pool managed by `node-http-proxy`.
  //
  var agent        = this.target.agent,
      protocolName = this.target.https ? 'https' : 'http',
      portUri      = getPort(this.source.port),
      remoteHost   = this.target.host + portUri;

  //
  // Change headers (if requested).
  //
  if (this.changeOrigin) {
    req.headers.host   = remoteHost;
    req.headers.origin = protocolName + '://' + remoteHost;
  }

  //
  // Make the outgoing WebSocket request
  //
  outgoing.host    = this.target.host;
  outgoing.port    = this.target.port;
  outgoing.agent   = agent;
  outgoing.method  = 'GET';
  outgoing.path    = req.url;
  outgoing.headers = req.headers;
  outgoing.agent   = agent;

  var reverseProxy = this.target.protocol.request(outgoing);

  //
  // On any errors from the `reverseProxy` emit the
  // `webSocketProxyError` and close the appropriate
  // connections.
  //
  function proxyError (err) {
    reverseProxy.destroy();

    process.nextTick(function () {
      //
      // Destroy the incoming socket in the next tick, in case the error handler
      // wants to write to it.
      //
      socket.destroy();
    });

    self.emit('webSocketProxyError', err, req, socket, head);
  }

  //
  // Here we set the incoming `req`, `socket` and `head` data to the outgoing
  // request so that we can reuse this data later on in the closure scope
  // available to the `upgrade` event. This bookkeeping is not tracked anywhere
  // in nodejs core and is **very** specific to proxying WebSockets.
  //
  reverseProxy.incoming = {
    request: req,
    socket: socket,
    head: head
  };

  //
  // Here we set the handshake `headers` and `statusCode` data to the outgoing
  // request so that we can reuse this data later.
  //
  reverseProxy.handshake = {
    headers: {},
    statusCode: null,
  }

  //
  // If the agent for this particular `host` and `port` combination
  // is not already listening for the `upgrade` event, then do so once.
  // This will force us not to disconnect.
  //
  // In addition, it's important to note the closure scope here. Since
  // there is no mapping of the socket to the request bound to it.
  //
  reverseProxy.on('upgrade', function (res, remoteSocket, head) {
    //
    // Prepare handshake response 'headers' and 'statusCode'.
    //
    reverseProxy.handshake = {
      headers: res.headers,
      statusCode: res.statusCode,
    }

    //
    // Prepare the socket for the reverseProxy request and begin to
    // stream data between the two sockets. Here it is important to
    // note that `remoteSocket._httpMessage === reverseProxy`.
    //
    _socket(remoteSocket, true);
    onUpgrade(remoteSocket._httpMessage, remoteSocket);
  });

  //
  // If the reverseProxy connection has an underlying socket,
  // then execute the WebSocket handshake.
  //
  reverseProxy.once('socket', function (revSocket) {
    revSocket.on('data', function handshake (data) {
      // Set empty headers
      var headers = '';

      //
      // If the handshake statusCode 101, concat headers.
      //
      if (reverseProxy.handshake.statusCode && reverseProxy.handshake.statusCode == 101) {
        headers = [
          'HTTP/1.1 101 Switching Protocols',
          'Upgrade: websocket',
          'Connection: Upgrade',
          'Sec-WebSocket-Accept: ' + reverseProxy.handshake.headers['sec-websocket-accept']
        ];

        headers = headers.concat('', '').join('\r\n');
      }

      //
      // Ok, kind of harmfull part of code. Socket.IO sends a hash
      // at the end of handshake if protocol === 76, but we need
      // to replace 'host' and 'origin' in response so we split
      // data to printable data and to non-printable. (Non-printable
      // will come after double-CRLF).
      //
      var sdata = data.toString();

      // Get the Printable data
      sdata = sdata.substr(0, sdata.search(CRLF + CRLF));

      // Get the Non-Printable data
      data = data.slice(Buffer.byteLength(sdata), data.length);

      if (self.source.https && !self.target.https) {
        //
        // If the proxy server is running HTTPS but the client is running
        // HTTP then replace `ws` with `wss` in the data sent back to the client.
        //
        sdata = sdata.replace('ws:', 'wss:');
      }

      try {
        //
        // Write the printable and non-printable data to the socket
        // from the original incoming request.
        //
        self.emit('websocket:handshake', req, socket, head, sdata, data);
        // add headers to the socket
        socket.write(headers + sdata);
        var flushed = socket.write(data);
        if (!flushed) {
          revSocket.pause();
          socket.once('drain', function () {
            try { revSocket.resume() }
            catch (er) { console.error("reverseProxy.socket.resume error: %s", er.message) }
          });

          //
          // Force the `drain` event in 100ms if it hasn't
          // happened on its own.
          //
          setTimeout(function () {
            socket.emit('drain');
          }, 100);
        }
      }
      catch (ex) {
        //
        // Remove data listener on socket error because the
        // 'handshake' has failed.
        //
        revSocket.removeListener('data', handshake);
        return proxyError(ex);
      }

      //
      // Remove data listener now that the 'handshake' is complete
      //
      revSocket.removeListener('data', handshake);
    });
  });

  //
  // Handle 'error' events from the `reverseProxy`.
  //
  reverseProxy.on('error', proxyError);

  //
  // Handle 'error' events from the `req` (e.g. `Parse Error`).
  //
  req.on('error', proxyError);

  try {
    //
    // Attempt to write the upgrade-head to the reverseProxy
    // request. This is small, and there's only ever one of
    // it; no need for pause/resume.
    //
    // XXX This is very wrong and should be fixed in node's core
    //
    reverseProxy.write(head);
    if (head && head.length === 0) {
      reverseProxy._send('');
    }
  }
  catch (ex) {
    return proxyError(ex);
  }

  //
  // If we have been passed buffered data, resume it.
  //
  if (buffer) {
    return !errState
      ? buffer.resume()
      : buffer.destroy();
  }
};

//
// ### function close()
// Closes all sockets associated with the Agents
// belonging to this instance.
//
HttpProxy.prototype.close = function () {
  [this.forward, this.target].forEach(function (proxy) {
    if (proxy && proxy.agent) {
      for (var host in proxy.agent.sockets) {
        proxy.agent.sockets[host].forEach(function (socket) {
          socket.end();
        });
      }
    }
  });
};

//
// ### @private function _forwardRequest (req)
// #### @req {ServerRequest} Incoming HTTP Request to proxy.
// Forwards the specified `req` to the location specified
// by `this.forward` ignoring errors and the subsequent response.
//
HttpProxy.prototype._forwardRequest = function (req) {
  var self = this,
      outgoing = new(this.forward.base),
      forwardProxy;

  //
  // Setup outgoing proxy with relevant properties.
  //
  outgoing.host    = this.forward.host;
  outgoing.port    = this.forward.port,
  outgoing.agent   = this.forward.agent;
  outgoing.method  = req.method;
  outgoing.path    = req.url;
  outgoing.headers = req.headers;

  //
  // Open new HTTP request to internal resource with will
  // act as a reverse proxy pass.
  //
  forwardProxy = this.forward.protocol.request(outgoing, function (response) {
    //
    // Ignore the response from the forward proxy since this is a 'fire-and-forget' proxy.
    // Remark (indexzero): We will eventually emit a 'forward' event here for performance tuning.
    //
  });

  //
  // Add a listener for the connection timeout event.
  //
  // Remark: Ignoring this error in the event
  //         forward target doesn't exist.
  //
  forwardProxy.once('error', function (err) { });

  //
  // Chunk the client request body as chunks from
  // the proxied request come in
  //
  req.on('data', function (chunk) {
    var flushed = forwardProxy.write(chunk);
    if (!flushed) {
      req.pause();
      forwardProxy.once('drain', function () {
        try { req.resume() }
        catch (er) { console.error("req.resume error: %s", er.message) }
      });

      //
      // Force the `drain` event in 100ms if it hasn't
      // happened on its own.
      //
      setTimeout(function () {
        forwardProxy.emit('drain');
      }, 100);
    }
  });

  //
  // At the end of the client request, we are going to
  // stop the proxied request
  //
  req.on('end', function () {
    forwardProxy.end();
  });
};

function getPortFromHostHeader(req) {
  var match;
  if ((match = extractPort.exec(req.headers.host))) {
    return parseInt(match[1]);
  }

  return getProto(req) === 'https' ? 443 : 80;
}

function getProto(req) {
  return req.isSpdy ? 'https' : (req.connection.pair ? 'https' : 'http');
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy/http-proxy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy/proxy-table.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy/proxy-table.js"}
require.memoize("b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy/proxy-table.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy';
/*
  node-http-proxy.js: Lookup table for proxy targets in node.js

  Copyright (c) 2010 Charlie Robbins

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

var util = require('__SYSTEM__/util'),
    events = require('__SYSTEM__/events'),
    fs = require('__SYSTEM__/fs'),
    url = require('__SYSTEM__/url');

//
// ### function ProxyTable (router, silent)
// #### @router {Object} Object containing the host based routes
// #### @silent {Boolean} Value indicating whether we should suppress logs
// #### @hostnameOnly {Boolean} Value indicating if we should route based on __hostname string only__
// #### @pathnameOnly {Boolean} Value indicating if we should route based on only the pathname.  __This causes hostnames to be ignored.__.  Using this along with hostnameOnly wont work at all.
// Constructor function for the ProxyTable responsible for getting
// locations of proxy targets based on ServerRequest headers; specifically
// the HTTP host header.
//
var ProxyTable = exports.ProxyTable = function (options) {
  events.EventEmitter.call(this);

  this.silent       = options.silent || options.silent !== true;
  this.target       = options.target || {};
  this.pathnameOnly = options.pathnameOnly === true;
  this.hostnameOnly = options.hostnameOnly === true;

  if (typeof options.router === 'object') {
    //
    // If we are passed an object literal setup
    // the routes with RegExps from the router
    //
    this.setRoutes(options.router);
  }
  else if (typeof options.router === 'string') {
    //
    // If we are passed a string then assume it is a
    // file path, parse that file and watch it for changes
    //
    var self = this;
    this.routeFile = options.router;
    this.setRoutes(JSON.parse(fs.readFileSync(options.router)).router);

    fs.watchFile(this.routeFile, function () {
      fs.readFile(self.routeFile, function (err, data) {
        if (err) {
          self.emit('error', err);
        }

        self.setRoutes(JSON.parse(data).router);
        self.emit('routes', self.hostnameOnly === false ? self.routes : self.router);
      });
    });
  }
  else {
    throw new Error('Cannot parse router with unknown type: ' + typeof router);
  }
};

//
// Inherit from `events.EventEmitter`
//
util.inherits(ProxyTable, events.EventEmitter);

//
// ### function addRoute (route, target)
// #### @route {String} String containing route coming in
// #### @target {String} String containing the target
// Adds a host-based route to this instance.
//
ProxyTable.prototype.addRoute = function (route, target) {
  if (!this.router) {
    throw new Error('Cannot update ProxyTable routes without router.');
  }

  this.router[route] = target;
  this.setRoutes(this.router);
};

//
// ### function removeRoute (route)
// #### @route {String} String containing route to remove
// Removes a host-based route from this instance.
//
ProxyTable.prototype.removeRoute = function (route) {
  if (!this.router) {
    throw new Error('Cannot update ProxyTable routes without router.');
  }

  delete this.router[route];
  this.setRoutes(this.router);
};

//
// ### function setRoutes (router)
// #### @router {Object} Object containing the host based routes
// Sets the host-based routes to be used by this instance.
//
ProxyTable.prototype.setRoutes = function (router) {
  if (!router) {
    throw new Error('Cannot update ProxyTable routes without router.');
  }

  var self = this;
  this.router = router;

  if (this.hostnameOnly === false) {
    this.routes = [];

    Object.keys(router).forEach(function (path) {
      if (!/http[s]?/.test(router[path])) {
        router[path] = (self.target.https ? 'https://' : 'http://')
          + router[path];
      }

      var target = url.parse(router[path]),
          defaultPort = self.target.https ? 443 : 80;

      //
      // Setup a robust lookup table for the route:
      //
      //    {
      //      source: {
      //        regexp: /^foo.com/i,
      //        sref: 'foo.com',
      //        url: {
      //          protocol: 'http:',
      //          slashes: true,
      //          host: 'foo.com',
      //          hostname: 'foo.com',
      //          href: 'http://foo.com/',
      //          pathname: '/',
      //          path: '/'
      //        }
      //    },
      //    {
      //      target: {
      //        sref: '127.0.0.1:8000/',
      //        url: {
      //          protocol: 'http:',
      //          slashes: true,
      //          host: '127.0.0.1:8000',
      //          hostname: '127.0.0.1',
      //          href: 'http://127.0.0.1:8000/',
      //          pathname: '/',
      //          path: '/'
      //        }
      //    },
      //
      self.routes.push({
        source: {
          regexp: new RegExp('^' + path, 'i'),
          sref: path,
          url: url.parse('http://' + path)
        },
        target: {
          sref: target.hostname + ':' + (target.port || defaultPort) + target.path,
          url: target
        }
      });
    });
  }
};

//
// ### function getProxyLocation (req)
// #### @req {ServerRequest} The incoming server request to get proxy information about.
// Returns the proxy location based on the HTTP Headers in the  ServerRequest `req`
// available to this instance.
//
ProxyTable.prototype.getProxyLocation = function (req) {
  if (!req || !req.headers || !req.headers.host) {
    return null;
  }

  var targetHost = req.headers.host.split(':')[0];
  if (this.hostnameOnly === true) {
    var target = targetHost;
    if (this.router.hasOwnProperty(target)) {
      var location = this.router[target].split(':'),
          host = location[0],
          port = location.length === 1 ? 80 : location[1];

      return {
        port: port,
        host: host
      };
    }
  }
  else if (this.pathnameOnly === true) {
    var target = req.url;
    for (var i in this.routes) {
      var route = this.routes[i];
      //
      // If we are matching pathname only, we remove the matched pattern.
      //
      // IE /wiki/heartbeat
      // is redirected to
      // /heartbeat
      //
      // for the route "/wiki" : "127.0.0.1:8020"
      //
      if (target.match(route.source.regexp)) {
        req.url = url.format(target.replace(route.source.regexp, ''));
        return {
          protocol: route.target.url.protocol.replace(':', ''),
          host: route.target.url.hostname,
          port: route.target.url.port
            || (this.target.https ? 443 : 80)
        };
      }
    }

  }
  else {
    var target = targetHost + req.url;
    for (var i in this.routes) {
      var route = this.routes[i];
      if (target.match(route.source.regexp)) {
        //
        // Attempt to perform any path replacement for differences
        // between the source path and the target path. This replaces the
        // path's part of the URL to the target's part of the URL.
        //
        // 1. Parse the request URL
        // 2. Replace any portions of the source path with the target path
        // 3. Set the request URL to the formatted URL with replacements.
        //
        var parsed = url.parse(req.url);

        parsed.pathname = parsed.pathname.replace(
          route.source.url.pathname,
          route.target.url.pathname
        );

        req.url = url.format(parsed);

        return {
          protocol: route.target.url.protocol.replace(':', ''),
          host: route.target.url.hostname,
          port: route.target.url.port
            || (this.target.https ? 443 : 80)
        };
      }
    }
  }

  return null;
};

//
// ### close function ()
// Cleans up the event listeneners maintained
// by this instance.
//
ProxyTable.prototype.close = function () {
  if (typeof this.routeFile === 'string') {
    fs.unwatchFile(this.routeFile);
  }
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy/proxy-table.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy/routing-proxy.js"}
require.memoize("b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy/routing-proxy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy';
/*
 * routing-proxy.js: A routing proxy consuming a RoutingTable and multiple HttpProxy instances
 *
 * (C) 2011 Nodejitsu Inc.
 * MIT LICENCE
 *
 */

var events = require('__SYSTEM__/events'),
    utile = require('utile'),
    HttpProxy = require('./http-proxy').HttpProxy,
    ProxyTable = require('./proxy-table').ProxyTable;

//
// ### function RoutingProxy (options)
// #### @options {Object} Options for this instance
// Constructor function for the RoutingProxy object, a higher level
// reverse proxy Object which can proxy to multiple hosts and also interface
// easily with a RoutingTable instance.
//
var RoutingProxy = exports.RoutingProxy = function (options) {
  events.EventEmitter.call(this);

  var self = this;
  options = options || {};

  if (options.router) {
    this.proxyTable = new ProxyTable(options);
    this.proxyTable.on('routes', function (routes) {
      self.emit('routes', routes);
    });
  }

  //
  // Create a set of `HttpProxy` objects to be used later on calls
  // to `.proxyRequest()` and `.proxyWebSocketRequest()`.
  //
  this.proxies = {};

  //
  // Setup default target options (such as `https`).
  //
  this.target = {};
  this.target.https = options.target && options.target.https;
  this.target.maxSockets = options.target && options.target.maxSockets;

  //
  // Setup other default options to be used for instances of
  // `HttpProxy` created by this `RoutingProxy` instance.
  //
  this.source  = options.source    || { host: 'localhost', port: 8000 };
  this.https   = this.source.https || options.https;
  this.enable  = options.enable;
  this.forward = options.forward;
  this.changeOrigin = options.changeOrigin || false;

  //
  // Listen for 'newListener' events so that we can bind 'proxyError'
  // listeners to each HttpProxy's 'proxyError' event.
  //
  this.on('newListener', function (evt) {
    if (evt === 'proxyError' || evt === 'webSocketProxyError') {
      Object.keys(self.proxies).forEach(function (key) {
        self.proxies[key].on(evt, self.emit.bind(self, evt));
      });
    }
  });
};


//
// Inherit from `events.EventEmitter`.
//
utile.inherits(RoutingProxy, events.EventEmitter);

//
// ### function add (options)
// #### @options {Object} Options for the `HttpProxy` to add.
// Adds a new instance of `HttpProxy` to this `RoutingProxy` instance
// for the specified `options.host` and `options.port`.
//
RoutingProxy.prototype.add = function (options) {
  var self = this,
      key = this._getKey(options);

  //
  // TODO: Consume properties in `options` related to the `ProxyTable`.
  //
  options.target            = options.target       || {};
  options.target.host       = options.target.host  || options.host;
  options.target.port       = options.target.port  || options.port;
  options.target.socketPath = options.target.socketPath || options.socketPath;
  options.target.https      = this.target && this.target.https ||
                              options.target && options.target.https;
  options.target.maxSockets = this.target && this.target.maxSockets;

  //
  // Setup options to pass-thru to the new `HttpProxy` instance
  // for the specified `options.host` and `options.port` pair.
  //
  ['https', 'enable', 'forward', 'changeOrigin'].forEach(function (key) {
    if (options[key] !== false && self[key]) {
      options[key] = self[key];
    }
  });

  this.proxies[key] = new HttpProxy(options);

  if (this.listeners('proxyError').length > 0) {
    this.proxies[key].on('proxyError', this.emit.bind(this, 'proxyError'));
  }

  if (this.listeners('webSocketProxyError').length > 0) {
    this.proxies[key].on('webSocketProxyError', this.emit.bind(this, 'webSocketProxyError'));
  }

  [
    'start',
    'forward',
    'end',
    'proxyResponse',
    'websocket:start',
    'websocket:end',
    'websocket:incoming',
    'websocket:outgoing'
  ].forEach(function (event) {
    this.proxies[key].on(event, this.emit.bind(this, event));
  }, this);
};

//
// ### function remove (options)
// #### @options {Object} Options mapping to the `HttpProxy` to remove.
// Removes an instance of `HttpProxy` from this `RoutingProxy` instance
// for the specified `options.host` and `options.port` (if they exist).
//
RoutingProxy.prototype.remove = function (options) {
  var key = this._getKey(options),
      proxy = this.proxies[key];

  delete this.proxies[key];
  return proxy;
};

//
// ### function close()
// Cleans up any state left behind (sockets, timeouts, etc)
// associated with this instance.
//
RoutingProxy.prototype.close = function () {
  var self = this;

  if (this.proxyTable) {
    //
    // Close the `RoutingTable` associated with
    // this instance (if any).
    //
    this.proxyTable.close();
  }

  //
  // Close all sockets for all `HttpProxy` object(s)
  // associated with this instance.
  //
  Object.keys(this.proxies).forEach(function (key) {
    self.proxies[key].close();
  });
};

//
// ### function proxyRequest (req, res, [port, host, paused])
// #### @req {ServerRequest} Incoming HTTP Request to proxy.
// #### @res {ServerResponse} Outgoing HTTP Request to write proxied data to.
// #### @options {Object} Options for the outgoing proxy request.
//
//     options.port {number} Port to use on the proxy target host.
//     options.host {string} Host of the proxy target.
//     options.buffer {Object} Result from `httpProxy.buffer(req)`
//     options.https {Object|boolean} Settings for https.
//
RoutingProxy.prototype.proxyRequest = function (req, res, options) {
  options = options || {};

  var location;

  //
  // Check the proxy table for this instance to see if we need
  // to get the proxy location for the request supplied. We will
  // always ignore the proxyTable if an explicit `port` and `host`
  // arguments are supplied to `proxyRequest`.
  //
  if (this.proxyTable && !options.host) {
    location = this.proxyTable.getProxyLocation(req);

    //
    // If no location is returned from the ProxyTable instance
    // then respond with `404` since we do not have a valid proxy target.
    //
    if (!location) {
      try {
        if (!this.emit('notFound', req, res)) {
          res.writeHead(404);
          res.end();
        }
      }
      catch (er) {
        console.error("res.writeHead/res.end error: %s", er.message);
      }

      return;
    }

    //
    // When using the ProxyTable in conjunction with an HttpProxy instance
    // only the following arguments are valid:
    //
    // * `proxy.proxyRequest(req, res, { host: 'localhost' })`: This will be skipped
    // * `proxy.proxyRequest(req, res, { buffer: buffer })`: Buffer will get updated appropriately
    // * `proxy.proxyRequest(req, res)`: Options will be assigned appropriately.
    //
    options.port = location.port;
    options.host = location.host;
  }

  var key = this._getKey(options),
      proxy;

  if ((this.target && this.target.https)
    || (location && location.protocol === 'https')) {
    options.target = options.target || {};
    options.target.https = true;
  }

  if (!this.proxies[key]) {
    this.add(utile.clone(options));
  }

  proxy = this.proxies[key];
  proxy.proxyRequest(req, res, options.buffer);
};

//
// ### function proxyWebSocketRequest (req, socket, head, options)
// #### @req {ServerRequest} Websocket request to proxy.
// #### @socket {net.Socket} Socket for the underlying HTTP request
// #### @head {string} Headers for the Websocket request.
// #### @options {Object} Options to use when proxying this request.
//
//     options.port {number} Port to use on the proxy target host.
//     options.host {string} Host of the proxy target.
//     options.buffer {Object} Result from `httpProxy.buffer(req)`
//     options.https {Object|boolean} Settings for https.
//
RoutingProxy.prototype.proxyWebSocketRequest = function (req, socket, head, options) {
  options = options || {};

  var location,
      proxy,
      key;

  if (this.proxyTable && !options.host) {
    location = this.proxyTable.getProxyLocation(req);

    if (!location) {
      return socket.destroy();
    }

    options.port = location.port;
    options.host = location.host;
  }

  key = this._getKey(options);

  if (!this.proxies[key]) {
    this.add(utile.clone(options));
  }

  proxy = this.proxies[key];
  proxy.proxyWebSocketRequest(req, socket, head, options.buffer);
};

//
// ### function addHost (host, target)
// #### @host {String} Host to add to proxyTable
// #### @target {String} Target to add to proxyTable
// Adds a host to proxyTable
//
RoutingProxy.prototype.addHost = function (host, target) {
  if (this.proxyTable) {
    this.proxyTable.addRoute(host, target);
  }
};

//
// ### function removeHost (host)
// #### @host {String} Host to remove from proxyTable
// Removes a host to proxyTable
//
RoutingProxy.prototype.removeHost = function (host) {
  if (this.proxyTable) {
    this.proxyTable.removeRoute(host);
  }
};

//
// ### @private function _getKey (options)
// #### @options {Object} Options to extract the key from
// Ensures that the appropriate options are present in the `options`
// provided and responds with a string key representing the `host`, `port`
// combination contained within.
//
RoutingProxy.prototype._getKey = function (options) {
  if (!options || ((!options.host || !options.port)
    && (!options.target || !options.target.host || !options.target.port))) {
    throw new Error('options.host and options.port or options.target are required.');
  }

  return [
    options.host || options.target.host,
    options.port || options.target.port
  ].join(':');
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/index.js"}
require.memoize("d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib';
/*
 * index.js: Top-level include for the `utile` module.
 *
 * (C) 2011, Nodejitsu Inc.
 * MIT LICENSE
 *
 */

var fs = require('__SYSTEM__/fs'),
    path = require('__SYSTEM__/path'),
    util = require('__SYSTEM__/util');

var utile = module.exports;

//
// Extend the `utile` object with all methods from the
// core node `util` methods.
//
Object.keys(util).forEach(function (key) {
  utile[key] = util[key];
});

Object.defineProperties(utile, {

  //
  // ### function async
  // Simple wrapper to `require('async')`.
  //
  'async': {
    get: function() {
      return utile.async = require('async');
    }
  },

  //
  // ### function inflect
  // Simple wrapper to `require('i')`.
  //
  'inflect': {
    get: function() {
      return utile.inflect = require('i')();
    }
  },

  //
  // ### function mkdirp
  // Simple wrapper to `require('mkdirp')`
  //
  'mkdirp': {
    get: function() {
      return utile.mkdirp = require('mkdirp');
    }
  },

  //
  // ### function deepEqual
  // Simple wrapper to `require('deep-equal')`
  // Remark: deepEqual is 4x faster then using assert.deepEqual
  //         see: https://gist.github.com/2790507
  //
  'deepEqual': {
    get: function() {
      return utile.deepEqual = require('deep-equal');
    }
  },

  //
  // ### function rimraf
  // Simple wrapper to `require('rimraf')`
  //
  'rimraf': {
    get: function() {
      return utile.rimraf = require('rimraf');
    }
  },

  //
  // ### function cpr
  // Simple wrapper to `require('ncp').ncp`
  //
  'cpr': {
    get: function() {
      return utile.cpr = require('ncp').ncp;
    }
  },

  //
  // ### @file {Object}
  // Lazy-loaded `file` module
  //
  'file': {
    get: function() {
      return utile.file = require('./file');
    }
  },

  //
  // ### @args {Object}
  // Lazy-loaded `args` module
  //
  'args': {
    get: function() {
      return utile.args = require('./args');
    }
  },

  //
  // ### @base64 {Object}
  // Lazy-loaded `base64` object
  //
  'base64': {
    get: function() {
      return utile.base64 = require('./base64');
    }
  },

  //
  // ### @format {Object}
  // Lazy-loaded `format` object
  //
  'format': {
    get: function() {
      return utile.format = require('./format');
    }
  }

});


//
// ### function rargs(_args)
// #### _args {Arguments} Original function arguments
//
// Top-level method will accept a javascript "arguments" object
// (the actual keyword "arguments" inside any scope) and return
// back an Array.
//
utile.rargs = function (_args, slice) {
  if (!slice) {
    slice = 0;
  }

  var len = (_args || []).length,
      args = new Array(len - slice),
      i;

  //
  // Convert the raw `_args` to a proper Array.
  //
  for (i = slice; i < len; i++) {
    args[i - slice] = _args[i];
  }

  return args;
};

//
// ### function each (obj, iterator)
// #### @obj {Object} Object to iterate over
// #### @iterator {function} Continuation to use on each key. `function (value, key, object)`
// Iterate over the keys of an object.
//
utile.each = function (obj, iterator) {
  Object.keys(obj).forEach(function (key) {
    iterator(obj[key], key, obj);
  });
};

//
// ### function find (o)
//
//
utile.find = function (obj, pred) {
  var value, key;

  for (key in obj) {
    value = obj[key];
    if (pred(value, key)) {
      return value;
    }
  }
};

//
// ### function pad (str, len, chr)
// ### @str {String} String to pad
// ### @len {Number} Number of chars to pad str with
// ### @chr {String} Optional replacement character, defaults to empty space
// Appends chr to str until it reaches a length of len
//
utile.pad = function pad(str, len, chr) {
  var s;
  if (!chr) {
    chr = ' ';
  }
  str = str || '';
  s = str;
  if (str.length < len) {
    for (var i = 0; i < (len - str.length); i++) {
      s += chr;
    }
  }
  return s;
}

//
// ### function path (obj, path, value)
// ### @obj {Object} Object to insert value into
// ### @path {Array} List of nested keys to insert value at
// Retreives a value from given Object, `obj`, located at the
// nested keys, `path`.
//
utile.path = function (obj, path) {
  var key, i;

  for (i in path) {
    if (typeof obj === 'undefined') {
      return undefined;
    }

    key = path[i];
    obj = obj[key];
  }

  return obj;
};

//
// ### function createPath (obj, path, value)
// ### @obj {Object} Object to insert value into
// ### @path {Array} List of nested keys to insert value at
// ### @value {*} Value to insert into the object.
// Inserts the `value` into the given Object, `obj`, creating
// any keys in `path` along the way if necessary.
//
utile.createPath = function (obj, path, value) {
  var key, i;

  for (i in path) {
    key = path[i];
    if (!obj[key]) {
      obj[key] = ((+i + 1 === path.length) ? value : {});
    }

    obj = obj[key];
  }
};

//
// ### function mixin (target [source0, source1, ...])
// Copies enumerable properties from `source0 ... sourceN`
// onto `target` and returns the resulting object.
//
utile.mixin = function (target) {
  utile.rargs(arguments, 1).forEach(function (o) {
    Object.getOwnPropertyNames(o).forEach(function(attr) {
      var getter = Object.getOwnPropertyDescriptor(o, attr).get,
          setter = Object.getOwnPropertyDescriptor(o, attr).set;

      if (!getter && !setter) {
        target[attr] = o[attr];
      }
      else {
        Object.defineProperty(target, attr, {
          get: getter,
          set: setter
        });
      }
    });
  });

  return target;
};


//
// ### function capitalize (str)
// #### @str {string} String to capitalize
// Capitalizes the specified `str`.
//
utile.capitalize = utile.inflect.camelize;

//
// ### function escapeRegExp (str)
// #### @str {string} String to be escaped
// Escape string for use in Javascript regex
//
utile.escapeRegExp = function (str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

//
// ### function randomString (length)
// #### @length {integer} The number of bits for the random base64 string returned to contain
// randomString returns a pseude-random ASCII string (subset)
// the return value is a string of length bits/6 of characters
// from the base64 alphabet.
//
utile.randomString = function (length) {
  var chars, rand, i, ret, mod, bits;

  chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
  ret = '';
  // standard 4
  mod = 4;
  // default is 16
  bits = length * mod || 64;

  // in v8, Math.random() yields 32 pseudo-random bits (in spidermonkey it gives 53)
  while (bits > 0) {
    // 32-bit integer
    rand = Math.floor(Math.random() * 0x100000000);
    //we use the top bits
    for (i = 26; i > 0 && bits > 0; i -= mod, bits -= mod) {
      ret += chars[0x3F & rand >>> i];
    }
  }

  return ret;
};

//
// ### function filter (object, test)
// #### @obj {Object} Object to iterate over
// #### @pred {function} Predicate applied to each property. `function (value, key, object)`
// Returns an object with properties from `obj` which satisfy
// the predicate `pred`
//
utile.filter = function (obj, pred) {
  var copy;
  if (Array.isArray(obj)) {
    copy = [];
    utile.each(obj, function (val, key) {
      if (pred(val, key, obj)) {
        copy.push(val);
      }
    });
  }
  else {
    copy = {};
    utile.each(obj, function (val, key) {
      if (pred(val, key, obj)) {
        copy[key] = val;
      }
    });
  }
  return copy;
};

//
// ### function requireDir (directory)
// #### @directory {string} Directory to require
// Requires all files and directories from `directory`, returning an object
// with keys being filenames (without trailing `.js`) and respective values
// being return values of `require(filename)`.
//
utile.requireDir = function (directory) {
  var result = {},
      files = fs.readdirSync(directory);

  files.forEach(function (file) {
    if (file.substr(-3) === '.js') {
      file = file.substr(0, file.length - 3);
    }
    result[file] = require(path.resolve(directory, file));
  });
  return result;
};

//
// ### function requireDirLazy (directory)
// #### @directory {string} Directory to require
// Lazily requires all files and directories from `directory`, returning an
// object with keys being filenames (without trailing `.js`) and respective
// values (getters) being return values of `require(filename)`.
//
utile.requireDirLazy = function (directory) {
  var result = {},
      files = fs.readdirSync(directory);

  files.forEach(function (file) {
    if (file.substr(-3) === '.js') {
      file = file.substr(0, file.length - 3);
    }
    Object.defineProperty(result, file, {
      get: function() {
        return result[file] = require(path.resolve(directory, file));
      }
    });
  });
  
  return result;
};

//
// ### function clone (object, filter)
// #### @object {Object} Object to clone
// #### @filter {Function} Filter to be used
// Shallow clones the specified object.
//
utile.clone = function (object, filter) {
  return Object.keys(object).reduce(filter ? function (obj, k) {
    if (filter(k)) obj[k] = object[k];
    return obj;
  } : function (obj, k) {
    obj[k] = object[k];
    return obj;
  }, {});
};

//
// ### function camelToUnderscore (obj)
// #### @obj {Object} Object to convert keys on.
// Converts all keys of the type `keyName` to `key_name` on the
// specified `obj`.
//
utile.camelToUnderscore = function (obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    obj.forEach(utile.camelToUnderscore);
    return obj;
  }

  Object.keys(obj).forEach(function (key) {
    var k = utile.inflect.underscore(key);
    if (k !== key) {
      obj[k] = obj[key];
      delete obj[key];
      key = k;
    }
    utile.camelToUnderscore(obj[key]);
  });

  return obj;
};

//
// ### function underscoreToCamel (obj)
// #### @obj {Object} Object to convert keys on.
// Converts all keys of the type `key_name` to `keyName` on the
// specified `obj`.
//
utile.underscoreToCamel = function (obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    obj.forEach(utile.underscoreToCamel);
    return obj;
  }

  Object.keys(obj).forEach(function (key) {
    var k = utile.inflect.camelize(key, false);
    if (k !== key) {
      obj[k] = obj[key];
      delete obj[key];
      key = k;
    }
    utile.underscoreToCamel(obj[key]);
  });

  return obj;
};

return {
    fs: (typeof fs !== "undefined") ? fs : null,
    require: (typeof require !== "undefined") ? require : null,
    path: (typeof path !== "undefined") ? path : null,
    util: (typeof util !== "undefined") ? util : null,
    utile: (typeof utile !== "undefined") ? utile : null,
    module: (typeof module !== "undefined") ? module : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    Math: (typeof Math !== "undefined") ? Math : null,
    Array: (typeof Array !== "undefined") ? Array : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/async/lib/async.js","mtime":0,"wrapper":"amd-ish","format":"amd-ish","id":"0c08d0ba45e15dd8f8ceecf76c44bee1a9a1b30d-async/lib/async.js"}
require.memoize("0c08d0ba45e15dd8f8ceecf76c44bee1a9a1b30d-async/lib/async.js", 
wrapAMD(function(require, define) {
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

})
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/async/lib/async.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/inflect.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/inflect.js"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/inflect.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib';
// Requiring modules

module.exports = function (attach) {
  var methods = require('./methods');

  if (attach) {
    require('./native')(methods);
  }

  return methods
};

return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/inflect.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/methods.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/methods.js"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/methods.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib';
// The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,
// and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept
// in inflections.coffee
//
// If you discover an incorrect inflection and require it for your application, you'll need
// to correct it yourself (explained below).

var util = require('./util');

var inflect = module.exports;

// Import [inflections](inflections.html) instance
inflect.inflections = require('./inflections')

// Gives easy access to add inflections to this class
inflect.inflect = function (inflections_function) {
  inflections_function(inflect.inflections);
};

// By default, _camelize_ converts strings to UpperCamelCase. If the argument to _camelize_
// is set to _false_ then _camelize_ produces lowerCamelCase.
//
// _camelize_ will also convert '/' to '.' which is useful for converting paths to namespaces.
//
//     "bullet_record".camelize()             // => "BulletRecord"
//     "bullet_record".camelize(false)        // => "bulletRecord"
//     "bullet_record/errors".camelize()      // => "BulletRecord.Errors"
//     "bullet_record/errors".camelize(false) // => "bulletRecord.Errors"
//
// As a rule of thumb you can think of _camelize_ as the inverse of _underscore_,
// though there are cases where that does not hold:
//
//     "SSLError".underscore.camelize // => "SslError"
inflect.camelize = function(lower_case_and_underscored_word, first_letter_in_uppercase) {
  var result;
  if (first_letter_in_uppercase == null) first_letter_in_uppercase = true;
  result = util.string.gsub(lower_case_and_underscored_word, /\/(.?)/, function($) {
    return "." + (util.string.upcase($[1]));
  });
  result = util.string.gsub(result, /(?:_)(.)/, function($) {
    return util.string.upcase($[1]);
  });
  if (first_letter_in_uppercase) {
    return util.string.upcase(result);
  } else {
    return util.string.downcase(result);
  }
};

// Makes an underscored, lowercase form from the expression in the string.
//
// Changes '.' to '/' to convert namespaces to paths.
//
//     "BulletRecord".underscore()         // => "bullet_record"
//     "BulletRecord.Errors".underscore()  // => "bullet_record/errors"
//
// As a rule of thumb you can think of +underscore+ as the inverse of +camelize+,
// though there are cases where that does not hold:
//
//     "SSLError".underscore().camelize() // => "SslError"
inflect.underscore = function (camel_cased_word) {
  var self;
  self = util.string.gsub(camel_cased_word, /\./, '/');
  self = util.string.gsub(self, /([A-Z]+)([A-Z][a-z])/, "$1_$2");
  self = util.string.gsub(self, /([a-z\d])([A-Z])/, "$1_$2");
  self = util.string.gsub(self, /-/, '_');
  return self.toLowerCase();
};

// Replaces underscores with dashes in the string.
//
//     "puni_puni".dasherize()   // => "puni-puni"
inflect.dasherize = function (underscored_word) {
  return util.string.gsub(underscored_word, /_/, '-');
};

// Removes the module part from the expression in the string.
//
//     "BulletRecord.String.Inflections".demodulize() // => "Inflections"
//     "Inflections".demodulize()                     // => "Inflections"
inflect.demodulize = function (class_name_in_module) {
  return util.string.gsub(class_name_in_module, /^.*\./, '');
};

// Creates a foreign key name from a class name.
// _separate_class_name_and_id_with_underscore_ sets whether
// the method should put '_' between the name and 'id'.
//
//     "Message".foreign_key()      // => "message_id"
//     "Message".foreign_key(false) // => "messageid"
//     "Admin::Post".foreign_key()  // => "post_id"
inflect.foreign_key = function (class_name, separate_class_name_and_id_with_underscore) {
  if (separate_class_name_and_id_with_underscore == null) {
    separate_class_name_and_id_with_underscore = true;
  }
  return inflect.underscore(inflect.demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id");
};

// Turns a number into an ordinal string used to denote the position in an
// ordered sequence such as 1st, 2nd, 3rd, 4th.
//
//     ordinalize(1)     // => "1st"
//     ordinalize(2)     // => "2nd"
//     ordinalize(1002)  // => "1002nd"
//     ordinalize(1003)  // => "1003rd"
//     ordinalize(-11)   // => "-11th"
//     ordinalize(-1021) // => "-1021st"
inflect.ordinalize = function (number) {
  var _ref;
  number = parseInt(number);
  if ((_ref = Math.abs(number) % 100) === 11 || _ref === 12 || _ref === 13) {
    return "" + number + "th";
  } else {
    switch (Math.abs(number) % 10) {
      case 1:
        return "" + number + "st";
      case 2:
        return "" + number + "nd";
      case 3:
        return "" + number + "rd";
      default:
        return "" + number + "th";
    }
  }
};

// Checks a given word for uncountability
//
//     "money".uncountability()     // => true
//     "my money".uncountability()  // => true
inflect.uncountability = function (word) {
  return inflect.inflections.uncountables.some(function(ele, ind, arr) {
    return word.match(new RegExp("(\\b|_)" + ele + "$", 'i')) != null;
  });
};

// Returns the plural form of the word in the string.
//
//     "post".pluralize()             // => "posts"
//     "octopus".pluralize()          // => "octopi"
//     "sheep".pluralize()            // => "sheep"
//     "words".pluralize()            // => "words"
//     "CamelOctopus".pluralize()     // => "CamelOctopi"
inflect.pluralize = function (word) {
  var plural, result;
  result = word;
  if (word === '' || inflect.uncountability(word)) {
    return result;
  } else {
    for (var i = 0; i < inflect.inflections.plurals.length; i++) {
      plural = inflect.inflections.plurals[i];
      result = util.string.gsub(result, plural[0], plural[1]);
      if (word.match(plural[0]) != null) break;
    }
    return result;
  }
};

// The reverse of _pluralize_, returns the singular form of a word in a string.
//
//     "posts".singularize()            // => "post"
//     "octopi".singularize()           // => "octopus"
//     "sheep".singularize()            // => "sheep"
//     "word".singularize()             // => "word"
//     "CamelOctopi".singularize()      // => "CamelOctopus"
inflect.singularize = function (word) {
  var result, singular;
  result = word;
  if (word === '' || inflect.uncountability(word)) {
    return result;
  } else {
    for (var i = 0; i < inflect.inflections.singulars.length; i++) {
      singular = inflect.inflections.singulars[i];
      result = util.string.gsub(result, singular[0], singular[1]);
      if (word.match(singular[0])) break;
    }
    return result;
  }
};

// Capitalizes the first word and turns underscores into spaces and strips a
// trailing "_id", if any. Like _titleize_, this is meant for creating pretty output.
//
//     "employee_salary".humanize()   // => "Employee salary"
//     "author_id".humanize()         // => "Author"
inflect.humanize = function (lower_case_and_underscored_word) {
  var human, result;
  result = lower_case_and_underscored_word;
  for (var i = 0; i < inflect.inflections.humans.length; i++) {
    human = inflect.inflections.humans[i];
    result = util.string.gsub(result, human[0], human[1]);
  }
  result = util.string.gsub(result, /_id$/, "");
  result = util.string.gsub(result, /_/, " ");
  return util.string.capitalize(result, true);
};

// Capitalizes all the words and replaces some characters in the string to create
// a nicer looking title. _titleize_ is meant for creating pretty output. It is not
// used in the Bullet internals.
//
//
//     "man from the boondocks".titleize()   // => "Man From The Boondocks"
//     "x-men: the last stand".titleize()    // => "X Men: The Last Stand"
inflect.titleize = function (word) {
  var self;
  self = inflect.humanize(inflect.underscore(word));
  self = util.string.gsub(self, /[^a-zA-Z:']/, ' ');
  return util.string.capitalize(self);
};

// Create the name of a table like Bullet does for models to table names. This method
// uses the _pluralize_ method on the last word in the string.
//
//     "RawScaledScorer".tableize()   // => "raw_scaled_scorers"
//     "egg_and_ham".tableize()       // => "egg_and_hams"
//     "fancyCategory".tableize()     // => "fancy_categories"
inflect.tableize = function (class_name) {
  return inflect.pluralize(inflect.underscore(class_name));
};

// Create a class name from a plural table name like Bullet does for table names to models.
// Note that this returns a string and not a Class.
//
//     "egg_and_hams".classify()   // => "EggAndHam"
//     "posts".classify()          // => "Post"
//
// Singular names are not handled correctly:
//
//     "business".classify()       // => "Busines"
inflect.classify = function (table_name) {
  return inflect.camelize(inflect.singularize(util.string.gsub(table_name, /.*\./, '')));
}

return {
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    inflect: (typeof inflect !== "undefined") ? inflect : null,
    module: (typeof module !== "undefined") ? module : null,
    parseInt: (typeof parseInt !== "undefined") ? parseInt : null,
    Math: (typeof Math !== "undefined") ? Math : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/methods.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/util.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/util.js"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/util.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib';
// Some utility functions in js

var u = module.exports = {
  array: {
    // Returns a copy of the array with the value removed once
    //
    //     [1, 2, 3, 1].del 1 #=> [2, 3, 1]
    //     [1, 2, 3].del 4    #=> [1, 2, 3]
    del: function (arr, val) {
      var index = arr.indexOf(val);
      if (index != -1) {
        if (index == 0) {
         return arr.slice(1)
        } else {
          return arr.slice(0, index).concat(arr.slice(index+1));
        }
      } else {
        return arr;
      }
    },

    // Returns the first element of the array
    //
    //     [1, 2, 3].first() #=> 1
    first: function(arr) {
      return arr[0];
    },

    // Returns the last element of the array
    //
    //     [1, 2, 3].last()  #=> 3
    last: function(arr) {
      return arr[arr.length-1];
    }
  },
  string: {
    // Returns a copy of str with all occurrences of pattern replaced with either replacement or the return value of a function.
    // The pattern will typically be a Regexp; if it is a String then no regular expression metacharacters will be interpreted
    // (that is /\d/ will match a digit, but \d will match a backslash followed by a d).
    //
    // In the function form, the current match object is passed in as a parameter to the function, and variables such as
    // $[1], $[2], $[3] (where $ is the match object) will be set appropriately. The value returned by the function will be
    // substituted for the match on each call.
    //
    // The result inherits any tainting in the original string or any supplied replacement string.
    //
    //     "hello".gsub /[aeiou]/, '*'      #=> "h*ll*"
    //     "hello".gsub /[aeiou]/, '<$1>'   #=> "h<e>ll<o>"
    //     "hello".gsub /[aeiou]/, ($) {
    //       "<#{$[1]}>"                    #=> "h<e>ll<o>"
    //
    gsub: function (str, pattern, replacement) {
      var i, match, matchCmpr, matchCmprPrev, replacementStr, result, self;
      if (!((pattern != null) && (replacement != null))) return u.string.value(str);
      result = '';
      self = str;
      while (self.length > 0) {
        if ((match = self.match(pattern))) {
          result += self.slice(0, match.index);
          if (typeof replacement === 'function') {
            match[1] = match[1] || match[0];
            result += replacement(match);
          } else if (replacement.match(/\$[1-9]/)) {
            matchCmprPrev = match;
            matchCmpr = u.array.del(match, void 0);
            while (matchCmpr !== matchCmprPrev) {
              matchCmprPrev = matchCmpr;
              matchCmpr = u.array.del(matchCmpr, void 0);
            }
            match[1] = match[1] || match[0];
            replacementStr = replacement;
            for (i = 1; i <= 9; i++) {
              if (matchCmpr[i]) {
                replacementStr = u.string.gsub(replacementStr, new RegExp("\\\$" + i), matchCmpr[i]);
              }
            }
            result += replacementStr;
          } else {
            result += replacement;
          }
          self = self.slice(match.index + match[0].length);
        } else {
          result += self;
          self = '';
        }
      }
      return result;
    },

    // Returns a copy of the String with the first letter being upper case
    //
    //     "hello".upcase #=> "Hello"
    upcase: function(str) {
      var self = u.string.gsub(str, /_([a-z])/, function ($) {
        return "_" + $[1].toUpperCase();
      });
      self = u.string.gsub(self, /\/([a-z])/, function ($) {
        return "/" + $[1].toUpperCase();
      });
      return self[0].toUpperCase() + self.substr(1);
    },

    // Returns a copy of capitalized string
    //
    //     "employee salary" #=> "Employee Salary"
    capitalize: function (str, spaces) {
      var self = str.toLowerCase();
      if(!spaces) {
        self = u.string.gsub(self, /\s([a-z])/, function ($) {
          return " " + $[1].toUpperCase();
        });
      }
      return self[0].toUpperCase() + self.substr(1);
    },

    // Returns a copy of the String with the first letter being lower case
    //
    //     "HELLO".downcase #=> "hELLO"
    downcase: function(str) {
      var self = u.string.gsub(str, /_([A-Z])/, function ($) {
        return "_" + $[1].toLowerCase();
      });
      self = u.string.gsub(self, /\/([A-Z])/, function ($) {
        return "/" + $[1].toLowerCase();
      });
      return self[0].toLowerCase() + self.substr(1);
    },

    // Returns a string value for the String object
    //
    //     "hello".value() #=> "hello"
    value: function (str) {
      return str.substr(0);
    }
  }
}

return {
    u: (typeof u !== "undefined") ? u : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/util.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/inflections.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/inflections.js"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/inflections.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib';
// A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional
// inflection rules. Examples:
//
//     BulletSupport.Inflector.inflect ($) ->
//       $.plural /^(ox)$/i, '$1en'
//       $.singular /^(ox)en/i, '$1'
//
//       $.irregular 'octopus', 'octopi'
//
//       $.uncountable "equipment"
//
// New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the
// pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may
// already have been loaded.

var util = require('./util');

var Inflections = function () {
  this.plurals = [];
  this.singulars = [];
  this.uncountables = [];
  this.humans = [];
  require('./defaults')(this);
  return this;
};

// Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.
// The replacement should always be a string that may include references to the matched data from the rule.
Inflections.prototype.plural = function (rule, replacement) {
  if (typeof rule == 'string') {
    this.uncountables = util.array.del(this.uncountables, rule);
  }
  this.uncountables = util.array.del(this.uncountables, replacement);
  this.plurals.unshift([rule, replacement]);
};

// Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.
// The replacement should always be a string that may include references to the matched data from the rule.
Inflections.prototype.singular = function (rule, replacement) {
  if (typeof rule == 'string') {
    this.uncountables = util.array.del(this.uncountables, rule);
  }
  this.uncountables = util.array.del(this.uncountables, replacement);
  this.singulars.unshift([rule, replacement]);
};

// Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used
// for strings, not regular expressions. You simply pass the irregular in singular and plural form.
//
//     irregular 'octopus', 'octopi'
//     irregular 'person', 'people'
Inflections.prototype.irregular =  function (singular, plural) {
  this.uncountables = util.array.del(this.uncountables, singular);
  this.uncountables = util.array.del(this.uncountables, plural);
  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {
    this.plural(new RegExp("(" + singular[0] + ")" + singular.slice(1) + "$", "i"), '$1' + plural.slice(1));
    this.plural(new RegExp("(" + plural[0] + ")" + plural.slice(1) + "$", "i"), '$1' + plural.slice(1));
    this.singular(new RegExp("(" + plural[0] + ")" + plural.slice(1) + "$", "i"), '$1' + singular.slice(1));
  } else {
    this.plural(new RegExp("" + (singular[0].toUpperCase()) + singular.slice(1) + "$"), plural[0].toUpperCase() + plural.slice(1));
    this.plural(new RegExp("" + (singular[0].toLowerCase()) + singular.slice(1) + "$"), plural[0].toLowerCase() + plural.slice(1));
    this.plural(new RegExp("" + (plural[0].toUpperCase()) + plural.slice(1) + "$"), plural[0].toUpperCase() + plural.slice(1));
    this.plural(new RegExp("" + (plural[0].toLowerCase()) + plural.slice(1) + "$"), plural[0].toLowerCase() + plural.slice(1));
    this.singular(new RegExp("" + (plural[0].toUpperCase()) + plural.slice(1) + "$"), singular[0].toUpperCase() + singular.slice(1));
    this.singular(new RegExp("" + (plural[0].toLowerCase()) + plural.slice(1) + "$"), singular[0].toLowerCase() + singular.slice(1));
  }
};

// Specifies a humanized form of a string by a regular expression rule or by a string mapping.
// When using a regular expression based replacement, the normal humanize formatting is called after the replacement.
// When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')
//
//     human /(.*)_cnt$/i, '$1_count'
//     human "legacy_col_person_name", "Name"
Inflections.prototype.human = function (rule, replacement) {
  this.humans.unshift([rule, replacement]);
}

// Add uncountable words that shouldn't be attempted inflected.
//
//     uncountable "money"
//     uncountable ["money", "information"]
Inflections.prototype.uncountable = function (words) {
  this.uncountables = this.uncountables.concat(words);
}

// Clears the loaded inflections within a given scope (default is _'all'_).
// Give the scope as a symbol of the inflection type, the options are: _'plurals'_,
// _'singulars'_, _'uncountables'_, _'humans'_.
//
//     clear 'all'
//     clear 'plurals'
Inflections.prototype.clear = function (scope) {
  if (scope == null) scope = 'all';
  switch (scope) {
    case 'all':
      this.plurals = [];
      this.singulars = [];
      this.uncountables = [];
      this.humans = [];
    default:
      this[scope] = [];
  }
}

// Clears the loaded inflections and initializes them to [default](../inflections.html)
Inflections.prototype.default = function () {
  this.plurals = [];
  this.singulars = [];
  this.uncountables = [];
  this.humans = [];
  require('./defaults')(this);
  return this;
};

module.exports = new Inflections();

return {
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    Inflections: (typeof Inflections !== "undefined") ? Inflections : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/inflections.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/defaults.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/defaults.js"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/defaults.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib';
// Default inflections
module.exports = function (inflect) {

  inflect.plural(/$/, 's');
  inflect.plural(/s$/i, 's');
  inflect.plural(/(ax|test)is$/i, '$1es');
  inflect.plural(/(octop|vir)us$/i, '$1i');
  inflect.plural(/(octop|vir)i$/i, '$1i');
  inflect.plural(/(alias|status)$/i, '$1es');
  inflect.plural(/(bu)s$/i, '$1ses');
  inflect.plural(/(buffal|tomat)o$/i, '$1oes');
  inflect.plural(/([ti])um$/i, '$1a');
  inflect.plural(/([ti])a$/i, '$1a');
  inflect.plural(/sis$/i, 'ses');
  inflect.plural(/(?:([^f])fe|([lr])f)$/i, '$1ves');
  inflect.plural(/(hive)$/i, '$1s');
  inflect.plural(/([^aeiouy]|qu)y$/i, '$1ies');
  inflect.plural(/(x|ch|ss|sh)$/i, '$1es');
  inflect.plural(/(matr|vert|ind)(?:ix|ex)$/i, '$1ices');
  inflect.plural(/([m|l])ouse$/i, '$1ice');
  inflect.plural(/([m|l])ice$/i, '$1ice');
  inflect.plural(/^(ox)$/i, '$1en');
  inflect.plural(/^(oxen)$/i, '$1');
  inflect.plural(/(quiz)$/i, '$1zes');


  inflect.singular(/s$/i, '');
  inflect.singular(/(n)ews$/i, '$1ews');
  inflect.singular(/([ti])a$/i, '$1um');
  inflect.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1sis');
  inflect.singular(/(^analy)ses$/i, '$1sis');
  inflect.singular(/([^f])ves$/i, '$1fe');
  inflect.singular(/(hive)s$/i, '$1');
  inflect.singular(/(tive)s$/i, '$1');
  inflect.singular(/([lr])ves$/i, '$1f');
  inflect.singular(/([^aeiouy]|qu)ies$/i, '$1y');
  inflect.singular(/(s)eries$/i, '$1eries');
  inflect.singular(/(m)ovies$/i, '$1ovie');
  inflect.singular(/(x|ch|ss|sh)es$/i, '$1');
  inflect.singular(/([m|l])ice$/i, '$1ouse');
  inflect.singular(/(bus)es$/i, '$1');
  inflect.singular(/(o)es$/i, '$1');
  inflect.singular(/(shoe)s$/i, '$1');
  inflect.singular(/(cris|ax|test)es$/i, '$1is');
  inflect.singular(/(octop|vir)i$/i, '$1us');
  inflect.singular(/(alias|status)es$/i, '$1');
  inflect.singular(/^(ox)en/i, '$1');
  inflect.singular(/(vert|ind)ices$/i, '$1ex');
  inflect.singular(/(matr)ices$/i, '$1ix');
  inflect.singular(/(quiz)zes$/i, '$1');
  inflect.singular(/(database)s$/i, '$1');

  inflect.irregular('child', 'children');
  inflect.irregular('person', 'people');
  inflect.irregular('man', 'men');
  inflect.irregular('child', 'children');
  inflect.irregular('sex', 'sexes');
  inflect.irregular('move', 'moves');
  inflect.irregular('cow', 'kine');
  inflect.irregular('zombie', 'zombies');

  inflect.uncountable(['equipment', 'information', 'rice', 'money', 'species', 'series', 'fish', 'sheep', 'jeans']);
}

return {
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/defaults.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/native.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/native.js"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/native.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib';
module.exports = function (obj) {

  var addProperty = function (method, func) {
    String.prototype.__defineGetter__(method, func);
  }

  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight', 'gsub'
  ];

  Object.keys(obj).forEach(function (key) {
    if (key != 'inflect' && key != 'inflections') {
      if (stringPrototypeBlacklist.indexOf(key) !== -1) {
        console.log('warn: You should not override String.prototype.' + key);
      } else {
        addProperty(key, function () {
          return obj[key](this);
        });
      }
    }
  });

}

return {
    module: (typeof module !== "undefined") ? module : null,
    String: (typeof String !== "undefined") ? String : null,
    console: (typeof console !== "undefined") ? console : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/lib/native.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/mkdirp/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"9dee272ed9e5c28263eb5731e369dc4604b912a0-mkdirp/index.js"}
require.memoize("9dee272ed9e5c28263eb5731e369dc4604b912a0-mkdirp/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/mkdirp';
var path = require('__SYSTEM__/path');
var fs = require('__SYSTEM__/fs');

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = 0777 & (~process.umask());
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = 0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};

return {
    path: (typeof path !== "undefined") ? path : null,
    require: (typeof require !== "undefined") ? require : null,
    fs: (typeof fs !== "undefined") ? fs : null,
    module: (typeof module !== "undefined") ? module : null,
    mkdirP: (typeof mkdirP !== "undefined") ? mkdirP : null,
    process: (typeof process !== "undefined") ? process : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/mkdirp/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/index.js"}
require.memoize("e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal';
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return true;
}

return {
    pSlice: (typeof pSlice !== "undefined") ? pSlice : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    objectKeys: (typeof objectKeys !== "undefined") ? objectKeys : null,
    require: (typeof require !== "undefined") ? require : null,
    isArguments: (typeof isArguments !== "undefined") ? isArguments : null,
    deepEqual: (typeof deepEqual !== "undefined") ? deepEqual : null,
    module: (typeof module !== "undefined") ? module : null,
    objEquiv: (typeof objEquiv !== "undefined") ? objEquiv : null,
    isUndefinedOrNull: (typeof isUndefinedOrNull !== "undefined") ? isUndefinedOrNull : null,
    isBuffer: (typeof isBuffer !== "undefined") ? isBuffer : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/lib/keys.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/lib/keys.js"}
require.memoize("e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/lib/keys.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/lib';
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/lib/keys.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/lib/is_arguments.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/lib/is_arguments.js"}
require.memoize("e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/lib/is_arguments.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/lib';
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/lib/is_arguments.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/rimraf/rimraf.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"10366b02d071a3b553102db687f0f7cf7de08547-rimraf/rimraf.js"}
require.memoize("10366b02d071a3b553102db687f0f7cf7de08547-rimraf/rimraf.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/rimraf';
module.exports = rimraf
rimraf.sync = rimrafSync

var assert = require("__SYSTEM__/assert")
var path = require("__SYSTEM__/path")
var fs = require("__SYSTEM__/fs")

// for EMFILE handling
var timeout = 0
exports.EMFILE_MAX = 1000
exports.BUSYTRIES_MAX = 3

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  defaults(options)

  if (!cb) throw new Error("No callback passed to rimraf()")

  var busyTries = 0
  rimraf_(p, options, function CB (er) {
    if (er) {
      if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY") &&
          busyTries < exports.BUSYTRIES_MAX) {
        busyTries ++
        var time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(function () {
          rimraf_(p, options, CB)
        }, time)
      }

      // this one won't happen if graceful-fs is used.
      if (er.code === "EMFILE" && timeout < exports.EMFILE_MAX) {
        return setTimeout(function () {
          rimraf_(p, options, CB)
        }, timeout ++)
      }

      // already gone
      if (er.code === "ENOENT") er = null
    }

    timeout = 0
    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.unlink(p, function (er) {
    if (er) {
      if (er.code === "ENOENT")
        return cb(null)
      if (er.code === "EPERM")
        return (isWindows)
          ? fixWinEPERM(p, options, er, cb)
          : rmdir(p, options, er, cb)
      if (er.code === "EISDIR")
        return rmdir(p, options, er, cb)
    }
    return cb(er)
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, 666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, 666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p)
  assert(options)

  try {
    options.unlinkSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "EPERM")
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    if (er.code !== "EISDIR")
      throw er
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })
  options.rmdirSync(p, options)
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/rimraf/rimraf.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/ncp/lib/ncp.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"a434266567e763036a95b1043481a5a65bf21aed-ncp/lib/ncp.js"}
require.memoize("a434266567e763036a95b1043481a5a65bf21aed-ncp/lib/ncp.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/ncp/lib';
var fs = require('__SYSTEM__/fs'),
    path = require('__SYSTEM__/path');

module.exports = ncp
ncp.ncp = ncp

function ncp (source, dest, options, callback) {
  if (!callback) {
    callback = options;
    options = {};
  }

  var basePath = process.cwd(),
      currentPath = path.resolve(basePath, source),
      targetPath = path.resolve(basePath, dest),
      filter = options.filter,
      transform = options.transform,
      clobber = options.clobber !== false,
      errs = null,
      started = 0,
      finished = 0,
      running = 0,
      limit = options.limit || ncp.limit || 16;

  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;

  startCopy(currentPath);
  
  function startCopy(source) {
    started++;
    if (filter) {
      if (filter instanceof RegExp) {
        if (!filter.test(source)) {
          return cb(true);
        }
      }
      else if (typeof filter === 'function') {
        if (!filter(source)) {
          return cb(true);
        }
      }
    }
    return getStats(source);
  }

  function defer(fn) {
    if (typeof(setImmediate) === 'function')
      return setImmediate(fn);
    return process.nextTick(fn);
  }

  function getStats(source) {
    if (running >= limit) {
      return defer(function () {
        getStats(source);
      });
    }
    running++;
    fs.lstat(source, function (err, stats) {
      var item = {};
      if (err) {
        return onError(err);
      }

      // We need to get the mode from the stats object and preserve it.
      item.name = source;
      item.mode = stats.mode;

      if (stats.isDirectory()) {
        return onDir(item);
      }
      else if (stats.isFile()) {
        return onFile(item);
      }
      else if (stats.isSymbolicLink()) {
        // Symlinks don't really need to know about the mode.
        return onLink(source);
      }
    });
  }

  function onFile(file) {
    var target = file.name.replace(currentPath, targetPath);
    isWritable(target, function (writable) {
      if (writable) {
        return copyFile(file, target);
      }
      if(clobber)
        rmFile(target, function () {
          copyFile(file, target);
        });
    });
  }

  function copyFile(file, target) {
    var readStream = fs.createReadStream(file.name),
        writeStream = fs.createWriteStream(target, { mode: file.mode });
    if(transform) {
      transform(readStream, writeStream,file);
    } else {
      readStream.pipe(writeStream);
    }
    readStream.once('end', cb);
  }

  function rmFile(file, done) {
    fs.unlink(file, function (err) {
      if (err) {
        return onError(err);
      }
      return done();
    });
  }

  function onDir(dir) {
    var target = dir.name.replace(currentPath, targetPath);
    isWritable(target, function (writable) {
      if (writable) {
        return mkDir(dir, target);
      }
      copyDir(dir.name);
    });
  }

  function mkDir(dir, target) {
    fs.mkdir(target, dir.mode, function (err) {
      if (err) {
        return onError(err);
      }
      copyDir(dir.name);
    });
  }

  function copyDir(dir) {
    fs.readdir(dir, function (err, items) {
      if (err) {
        return onError(err);
      }
      items.forEach(function (item) {
        startCopy(dir + '/' + item);
      });
      return cb();
    });
  }

  function onLink(link) {
    var target = link.replace(currentPath, targetPath);
    fs.readlink(link, function (err, resolvedPath) {
      if (err) {
        return onError(err);
      }
      checkLink(resolvedPath, target);
    });
  }

  function checkLink(resolvedPath, target) {
    isWritable(target, function (writable) {
      if (writable) {
        return makeLink(resolvedPath, target);
      }
      fs.readlink(target, function (err, targetDest) {
        if (err) {
          return onError(err);
        }
        if (targetDest === resolvedPath) {
          return cb();
        }
        return rmFile(target, function () {
          makeLink(resolvedPath, target);
        });
      });
    });
  }

  function makeLink(linkPath, target) {
    fs.symlink(linkPath, target, function (err) {
      if (err) {
        return onError(err);
      }
      return cb();
    });
  }

  function isWritable(path, done) {
    fs.lstat(path, function (err, stats) {
      if (err) {
        if (err.code === 'ENOENT') return done(true);
        return done(false);
      }
      return done(false);
    });
  }

  function onError(err) {
    if (options.stopOnError) {
      return callback(err);
    }
    else if (!errs && options.errs) {
      errs = fs.createWriteStream(options.errs);
    }
    else if (!errs) {
      errs = [];
    }
    if (typeof errs.write === 'undefined') {
        errs.push(err);
    }
    else { 
        errs.write(err.stack + '\n\n');
    }
    return cb();
  }

  function cb(skipped) {
    if (!skipped) running--;
    finished++;
    if ((started === finished) && (running === 0)) {
      return errs ? callback(errs) : callback(null);
    }
  }
};



return {
    fs: (typeof fs !== "undefined") ? fs : null,
    require: (typeof require !== "undefined") ? require : null,
    path: (typeof path !== "undefined") ? path : null,
    module: (typeof module !== "undefined") ? module : null,
    ncp: (typeof ncp !== "undefined") ? ncp : null,
    process: (typeof process !== "undefined") ? process : null,
    setImmediate: (typeof setImmediate !== "undefined") ? setImmediate : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/ncp/lib/ncp.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/file.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/file.js"}
require.memoize("d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/file.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib';
/*
 * file.js: Simple utilities for working with the file system.
 *
 * (C) 2011, Nodejitsu Inc.
 * MIT LICENSE
 *
 */

var fs = require('__SYSTEM__/fs');

exports.readJson = exports.readJSON = function (file, callback) {
  if (typeof callback !== 'function') {
    throw new Error('utile.file.readJson needs a callback');
  }

  fs.readFile(file, 'utf-8', function (err, data) {
    if (err) {
      return callback(err);
    }

    try {
      var json = JSON.parse(data);
      callback(null, json);
    }
    catch (err) {
      return callback(err);
    }
  });
};

exports.readJsonSync = exports.readJSONSync = function (file) {
  return JSON.parse(fs.readFileSync(file, 'utf-8'));
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/file.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/args.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/args.js"}
require.memoize("d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/args.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib';
/*
 * args.js: function argument parsing helper utility
 *
 * (C) 2012, Nodejitsu Inc.
 * MIT LICENSE
 *
 */

var utile = require('./index');

//
// ### function args(_args)
// #### _args {Arguments} Original function arguments
//
// Top-level method will accept a javascript "arguments" object (the actual keyword
// "arguments" inside any scope), and attempt to return back an intelligent object
// representing the functions arguments
//
module.exports = function (_args) {
  var args = utile.rargs(_args),
      _cb;

  //
  // Find and define the first argument
  //
  Object.defineProperty(args, 'first', { value: args[0] });

  //
  // Find and define any callback
  //
  _cb = args[args.length - 1] || args[args.length];
  if (typeof _cb === "function") {
    Object.defineProperty(args, 'callback', { value: _cb });
    Object.defineProperty(args, 'cb', { value: _cb });
    args.pop();
  }

  //
  // Find and define the last argument
  //
  if (args.length) {
    Object.defineProperty(args, 'last', { value: args[args.length - 1] });
  }

  return args;
};

return {
    utile: (typeof utile !== "undefined") ? utile : null,
    require: (typeof require !== "undefined") ? require : null,
    module: (typeof module !== "undefined") ? module : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/args.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/base64.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/base64.js"}
require.memoize("d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/base64.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib';
/*
 * base64.js: An extremely simple implementation of base64 encoding / decoding using node.js Buffers
 *
 * (C) 2010, Nodejitsu Inc.
 *
 */

var base64 = exports;

//
// ### function encode (unencoded)
// #### @unencoded {string} The string to base64 encode
// Encodes the specified string to base64 using node.js Buffers.
//
base64.encode = function (unencoded) {
  var encoded;

  try {
    encoded = new Buffer(unencoded || '').toString('base64');
  }
  catch (ex) {
    return null;
  }

  return encoded;
};

//
// ### function decode (encoded)
// #### @encoded {string} The string to base64 decode
// Decodes the specified string from base64 using node.js Buffers.
//
base64.decode = function (encoded) {
  var decoded;

  try {
    decoded = new Buffer(encoded || '', 'base64').toString('utf8');
  }
  catch (ex) {
    return null;
  }

  return decoded;
};
return {
    base64: (typeof base64 !== "undefined") ? base64 : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/base64.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/format.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/format.js"}
require.memoize("d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/format.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib';
/*
 * format.js: `util.format` enhancement to allow custom formatting parameters.
 *
 * (C) 2012, Nodejitsu Inc.
 * MIT LICENSE
 *
 */

var util = require('__SYSTEM__/util');

exports = module.exports = function(str) {
  var formats = [].slice.call(arguments, 1, 3);

  if (!(formats[0] instanceof Array && formats[1] instanceof Array) || arguments.length > 3)
    return util.format.apply(null, arguments);

  var replacements = formats.pop(),
      formats = formats.shift();

  formats.forEach(function(format, id) {
    str = str.replace(new RegExp(format), replacements[id]);
  });

  return str;
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/lib/format.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/empty-port/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"ced8d3a56b61a7bac1f8aa0f1d76859b38a5c95b-empty-port/index.js"}
require.memoize("ced8d3a56b61a7bac1f8aa0f1d76859b38a5c95b-empty-port/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/empty-port';
var net = require('__SYSTEM__/net');

var empryPort = function (opt, callback) {
        var startPort = opt.startPort || opt.port || 1;
        var maxPort   = opt.maxPort   || opt.port || 65537;
        var host      = opt.host      || 'localhost';

        var usedPorts = {};
        var usedPortCount = 0;

        var range = maxPort - startPort;

        var pickRandomPort = function () {
                if (usedPortCount >= range) {
                        return null;
                }

                var port = startPort + parseInt(Math.random() * (range + 1));

                return usedPorts[port] ? pickRandomPort() : port;
        };

        var tryToConnect = function (port, callback) {
                var socket = new net.Socket();
                var server = new net.Server();

                socket.on('error', function(err) {
                        server.on('error', function (err) {
                                callback(err);
                        });
                        server.listen(port, host, function () {
                                server.close();
                                callback();
                        });
                });
                socket.connect(port, host, function() {
                        socket.end();
                        callback('listened port');
                });
        };

        var iterator = function (next) {
                var pickedPort = pickRandomPort();
                if (!pickedPort) {
                        return callback('not found.');
                }

                tryToConnect(pickedPort, function (err) {
                        if (err) {
                                usedPorts[pickedPort] = true;
                                usedPortCount++;
                                return iterator(next);
                        }
                        return callback(null, pickedPort);
                });
        };

        iterator();
};

module.exports = empryPort;
return {
    net: (typeof net !== "undefined") ? net : null,
    require: (typeof require !== "undefined") ? require : null,
    empryPort: (typeof empryPort !== "undefined") ? empryPort : null,
    parseInt: (typeof parseInt !== "undefined") ? parseInt : null,
    Math: (typeof Math !== "undefined") ? Math : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/empty-port/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"685b4ff7635533ef39e3b122158d8cfa4980b301-request/index.js"}
require.memoize("685b4ff7635533ef39e3b122158d8cfa4980b301-request/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request';
// Copyright 2010-2012 Mikeal Rogers
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

var Cookie = require('cookie-jar')
  , CookieJar = Cookie.Jar
  , cookieJar = new CookieJar

  , copy = require('./lib/copy')
  , Request = require('./request')
  ;



// organize params for patch, post, put, head, del
function initParams(uri, options, callback) {
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
    uri = options.uri
  }
  return { uri: uri, options: options, callback: callback }
}

function request (uri, options, callback) {
  if (typeof uri === 'undefined') throw new Error('undefined is not a valid uri or options object.')
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
  }

  options = copy(options)

  if (callback) options.callback = callback
  var r = new Request(options)
  return r
}

module.exports = request

request.Request = Request;

request.debug = process.env.NODE_DEBUG && /request/.test(process.env.NODE_DEBUG)

request.initParams = initParams

request.defaults = function (options, requester) {
  var def = function (method) {
    var d = function (uri, opts, callback) {
      var params = initParams(uri, opts, callback)
      for (var i in options) {
        if (params.options[i] === undefined) params.options[i] = options[i]
      }
      if(typeof requester === 'function') {
        if(method === request) {
          method = requester
        } else {
          params.options._requester = requester
        }
      }
      return method(params.options, params.callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.patch = def(request.patch)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  de.del = def(request.del)
  de.cookie = def(request.cookie)
  de.jar = request.jar
  return de
}

request.forever = function (agentOptions, optionsArg) {
  var options = {}
  if (optionsArg) {
    for (option in optionsArg) {
      options[option] = optionsArg[option]
    }
  }
  if (agentOptions) options.agentOptions = agentOptions
  options.forever = true
  return request.defaults(options)
}

request.get = request
request.post = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'POST'
  return request(params.uri || null, params.options, params.callback)
}
request.put = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PUT'
  return request(params.uri || null, params.options, params.callback)
}
request.patch = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PATCH'
  return request(params.uri || null, params.options, params.callback)
}
request.head = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'HEAD'
  if (params.options.body ||
      params.options.requestBodyStream ||
      (params.options.json && typeof params.options.json !== 'boolean') ||
      params.options.multipart) {
    throw new Error("HTTP HEAD requests MUST NOT include a request body.")
  }
  return request(params.uri || null, params.options, params.callback)
}
request.del = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'DELETE'
  if(typeof params.options._requester === 'function') {
    request = params.options._requester
  }
  return request(params.uri || null, params.options, params.callback)
}
request.jar = function () {
  return new CookieJar
}
request.cookie = function (str) {
  if (str && str.uri) str = str.uri
  if (typeof str !== 'string') throw new Error("The cookie function only accepts STRING as param")
  return new Cookie(str)
}

return {
    Cookie: (typeof Cookie !== "undefined") ? Cookie : null,
    require: (typeof require !== "undefined") ? require : null,
    CookieJar: (typeof CookieJar !== "undefined") ? CookieJar : null,
    cookieJar: (typeof cookieJar !== "undefined") ? cookieJar : null,
    copy: (typeof copy !== "undefined") ? copy : null,
    Request: (typeof Request !== "undefined") ? Request : null,
    initParams: (typeof initParams !== "undefined") ? initParams : null,
    request: (typeof request !== "undefined") ? request : null,
    module: (typeof module !== "undefined") ? module : null,
    process: (typeof process !== "undefined") ? process : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/index.js"}
require.memoize("73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar';
/*!
 * Tobi - Cookie
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var url = require('__SYSTEM__/url');

/**
 * Initialize a new `Cookie` with the given cookie `str` and `req`.
 *
 * @param {String} str
 * @param {IncomingRequest} req
 * @api private
 */

var Cookie = exports = module.exports = function Cookie(str, req) {
  this.str = str;

  // Map the key/val pairs
  str.split(/ *; */).reduce(function(obj, pair){
   var p = pair.indexOf('=');
   var key = p > 0 ? pair.substring(0, p).trim() : pair.trim();
   var lowerCasedKey = key.toLowerCase();
   var value = p > 0 ? pair.substring(p + 1).trim() : true;

   if (!obj.name) {
    // First key is the name
    obj.name = key;
    obj.value = value;
   }
   else if (lowerCasedKey === 'httponly') {
    obj.httpOnly = value;
   }
   else {
    obj[lowerCasedKey] = value;
   }
   return obj;
  }, this);

  // Expires
  this.expires = this.expires
    ? new Date(this.expires)
    : Infinity;

  // Default or trim path
  this.path = this.path
    ? this.path.trim(): req 
    ? url.parse(req.url).pathname: '/';
};

/**
 * Return the original cookie string.
 *
 * @return {String}
 * @api public
 */

Cookie.prototype.toString = function(){
  return this.str;
};

module.exports.Jar = require('./jar')
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar/jar.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/jar.js"}
require.memoize("73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/jar.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar';
/*!
* Tobi - CookieJar
* Copyright(c) 2010 LearnBoost <dev@learnboost.com>
* MIT Licensed
*/

/**
* Module dependencies.
*/

var url = require('__SYSTEM__/url');

/**
* Initialize a new `CookieJar`.
*
* @api private
*/

var CookieJar = exports = module.exports = function CookieJar() {
  this.cookies = [];
};

/**
* Add the given `cookie` to the jar.
*
* @param {Cookie} cookie
* @api private
*/

CookieJar.prototype.add = function(cookie){
  this.cookies = this.cookies.filter(function(c){
    // Avoid duplication (same path, same name)
    return !(c.name == cookie.name && c.path == cookie.path);
  });
  this.cookies.push(cookie);
};

/**
* Get cookies for the given `req`.
*
* @param {IncomingRequest} req
* @return {Array}
* @api private
*/

CookieJar.prototype.get = function(req){
  var path = url.parse(req.url).pathname
    , now = new Date
    , specificity = {};
  return this.cookies.filter(function(cookie){
    if (0 == path.indexOf(cookie.path) && now < cookie.expires
      && cookie.path.length > (specificity[cookie.name] || 0))
      return specificity[cookie.name] = cookie.path.length;
  });
};

/**
* Return Cookie string for the given `req`.
*
* @param {IncomingRequest} req
* @return {String}
* @api private
*/

CookieJar.prototype.cookieString = function(req){
  var cookies = this.get(req);
  if (cookies.length) {
    return cookies.map(function(cookie){
      return cookie.name + '=' + cookie.value;
    }).join('; ');
  }
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar/jar.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib/copy.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"685b4ff7635533ef39e3b122158d8cfa4980b301-request/lib/copy.js"}
require.memoize("685b4ff7635533ef39e3b122158d8cfa4980b301-request/lib/copy.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib';
module.exports =
function copy (obj) {
  var o = {}
  Object.keys(obj).forEach(function (i) {
    o[i] = obj[i]
  })
  return o
}
return {
    module: (typeof module !== "undefined") ? module : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib/copy.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/request.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"685b4ff7635533ef39e3b122158d8cfa4980b301-request/request.js"}
require.memoize("685b4ff7635533ef39e3b122158d8cfa4980b301-request/request.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request';
var http = require('__SYSTEM__/http')
  , https = false
  , tls = false
  , url = require('__SYSTEM__/url')
  , util = require('__SYSTEM__/util')
  , stream = require('__SYSTEM__/stream')
  , qs = require('qs')
  , querystring = require('__SYSTEM__/querystring')
  , crypto = require('__SYSTEM__/crypto')

  , oauth = require('oauth-sign')
  , hawk = require('hawk')
  , aws = require('aws-sign')
  , httpSignature = require('http-signature')
  , uuid = require('node-uuid')
  , mime = require('mime')
  , tunnel = require('tunnel-agent')
  , _safeStringify = require('json-stringify-safe')

  , ForeverAgent = require('forever-agent')
  , FormData = require('form-data')

  , Cookie = require('cookie-jar')
  , CookieJar = Cookie.Jar
  , cookieJar = new CookieJar

  , copy = require('./lib/copy')
  , debug = require('./lib/debug')
  , getSafe = require('./lib/getSafe')
  ;

function safeStringify (obj) {
  var ret
  try { ret = JSON.stringify(obj) }
  catch (e) { ret = _safeStringify(obj) }
  return ret
}

var globalPool = {}
var isUrl = /^https?:/i

try {
  https = require('__SYSTEM__/https')
} catch (e) {}

try {
  tls = require('__SYSTEM__/tls')
} catch (e) {}



// Hacky fix for pre-0.4.4 https
if (https && !https.Agent) {
  https.Agent = function (options) {
    http.Agent.call(this, options)
  }
  util.inherits(https.Agent, http.Agent)
  https.Agent.prototype._getConnection = function (host, port, cb) {
    var s = tls.connect(port, host, this.options, function () {
      // do other checks here?
      if (cb) cb()
    })
    return s
  }
}

function isReadStream (rs) {
  if (rs.readable && rs.path && rs.mode) {
    return true
  }
}

function toBase64 (str) {
  return (new Buffer(str || "", "ascii")).toString("base64")
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

function Request (options) {
  stream.Stream.call(this)
  this.readable = true
  this.writable = true

  if (typeof options === 'string') {
    options = {uri:options}
  }

  var reserved = Object.keys(Request.prototype)
  for (var i in options) {
    if (reserved.indexOf(i) === -1) {
      this[i] = options[i]
    } else {
      if (typeof options[i] === 'function') {
        delete options[i]
      }
    }
  }

  if (options.method) {
    this.explicitMethod = true
  }

  this.init(options)
}
util.inherits(Request, stream.Stream)
Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) options = {}

  if (!self.method) self.method = options.method || 'GET'
  self.localAddress = options.localAddress

  debug(options)
  if (!self.pool && self.pool !== false) self.pool = globalPool
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback && self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) return // Print a warning maybe?
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on('error', self.callback.bind())
    self.on('complete', self.callback.bind(self, null))
  }

  if (self.url && !self.uri) {
    // People use this property instead all the time so why not just support it.
    self.uri = self.url
    delete self.url
  }

  if (!self.uri) {
    // this will throw if unhandled but is handleable when in a redirect
    return self.emit('error', new Error("options.uri is a required argument"))
  } else {
    if (typeof self.uri == "string") self.uri = url.parse(self.uri)
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (self.proxy) {
    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)

    // do the HTTP CONNECT dance using koichik/node-tunnel
    if (http.globalAgent && self.uri.protocol === "https:") {
      var tunnelFn = self.proxy.protocol === "http:"
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps

      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth
                                   , headers: { Host: self.uri.hostname + ':' +
                                        (self.uri.port || self.uri.protocol === 'https:' ? 443 : 80) }}
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: this.ca }

      self.agent = tunnelFn(tunnelOptions)
      self.tunnel = true
    }
  }

  if (!self.uri.pathname) {self.uri.pathname = '/'}

  if (!self.uri.host) {
    // Invalid URI: it may generate lot of bad errors, like "TypeError: Cannot call method 'indexOf' of undefined" in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = 'Invalid URI "' + faultyUri + '"'
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (he didn't call request directly with this URL)
      // he should be warned that it can be caused by a redirection (can save some hair)
      message += '. This can be caused by a crappy redirection.'
    }
    self.emit('error', new Error(message))
    return // This error was fatal
  }

  self._redirectsFollowed = self._redirectsFollowed || 0
  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10
  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true
  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false
  if (self.followRedirect || self.followAllRedirects)
    self.redirects = self.redirects || []

  self.headers = self.headers ? copy(self.headers) : {}

  self.setHost = false
  if (!self.hasHeader('host')) {
    self.setHeader('host', self.uri.hostname)
    if (self.uri.port) {
      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&
           !(self.uri.port === 443 && self.uri.protocol === 'https:') )
      self.setHeader('host', self.getHeader('host') + (':'+self.uri.port) )
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.port) {
    if (self.uri.protocol == 'http:') {self.uri.port = 80}
    else if (self.uri.protocol == 'https:') {self.uri.port = 443}
  }

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  self.clientErrorHandler = function (error) {
    if (self._aborted) return

    if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
        && self.agent.addRequestNoreuse) {
      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
      self.start()
      self.req.end()
      return
    }
    if (self.timeout && self.timeoutTimer) {
      clearTimeout(self.timeoutTimer)
      self.timeoutTimer = null
    }
    self.emit('error', error)
  }

  self._parserErrorHandler = function (error) {
    if (this.res) {
      if (this.res.request) {
        this.res.request.emit('error', error)
      } else {
        this.res.emit('error', error)
      }
    } else {
      this._httpMessage.emit('error', error)
    }
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.qs) self.qs(options.qs)

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || "")
  }

  if (self.path.length === 0) self.path = '/'


  // Auth must happen last in case signing is dependent on other headers
  if (options.oauth) {
    self.oauth(options.oauth)
  }

  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    self.auth(
      (options.auth.user==="") ? options.auth.user : (options.auth.user || options.auth.username ),
      options.auth.pass || options.auth.password,
      options.auth.sendImmediately)
  }

  if (self.uri.auth && !self.hasHeader('authorization')) {
    var authPieces = self.uri.auth.split(':').map(function(item){ return querystring.unescape(item) })
    self.auth(authPieces[0], authPieces.slice(1).join(':'), true)
  }
  if (self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization') && !self.tunnel) {
    self.setHeader('proxy-authorization', "Basic " + toBase64(self.proxy.auth.split(':').map(function(item){ return querystring.unescape(item)}).join(':')))
  }


  if (self.proxy && !self.tunnel) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)

  if (options.json) {
    self.json(options.json)
  } else if (options.multipart) {
    self.boundary = uuid()
    self.multipart(options.multipart)
  }

  if (self.body) {
    var length = 0
    if (!Buffer.isBuffer(self.body)) {
      if (Array.isArray(self.body)) {
        for (var i = 0; i < self.body.length; i++) {
          length += self.body[i].length
        }
      } else {
        self.body = new Buffer(self.body)
        length = self.body.length
      }
    } else {
      length = self.body.length
    }
    if (length) {
      if (!self.hasHeader('content-length')) self.setHeader('content-length', length)
    } else {
      throw new Error('Argument error, options.body.')
    }
  }

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
    , defaultModules = {'http:':http, 'https:':https}
    , httpModules = self.httpModules || {}
    ;
  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) return this.emit('error', new Error("Invalid protocol"))

  if (options.ca) self.ca = options.ca

  if (!self.agent) {
    if (options.agentOptions) self.agentOptions = options.agentOptions

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getAgent()
    if (self.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.maxSockets
    }
    if (self.pool.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.pool.maxSockets
    }
  }

  self.on('pipe', function (src) {
    if (self.ntick && self._started) throw new Error("You cannot pipe to this stream after the outbound request has started.")
    self.src = src
    if (isReadStream(src)) {
      if (!self.hasHeader('content-type')) self.setHeader('content-type', mime.lookup(src.path))
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.hasHeader(i)) {
            self.setHeader(i, src.headers[i])
          }
        }
      }
      if (self._json && !self.hasHeader('content-type'))
        self.setHeader('content-type', 'application/json')
      if (src.method && !self.explicitMethod) {
        self.method = src.method
      }
    }

    // self.on('pipe', function () {
    //   console.error("You have already piped to this stream. Pipeing twice is likely to break the request.")
    // })
  })

  process.nextTick(function () {
    if (self._aborted) return

    if (self._form) {
      self.setHeaders(self._form.getHeaders())
      self._form.pipe(self)
    }
    if (self.body) {
      if (Array.isArray(self.body)) {
        self.body.forEach(function (part) {
          self.write(part)
        })
      } else {
        self.write(self.body)
      }
      self.end()
    } else if (self.requestBodyStream) {
      console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.")
      self.requestBodyStream.pipe(self)
    } else if (!self.src) {
      if (self.method !== 'GET' && typeof self.method !== 'undefined') {
        self.setHeader('content-length', 0)
      }
      self.end()
    }
    self.ntick = true
  })
}

// Must call this when following a redirect from https to http or vice versa
// Attempts to keep everything as identical as possible, but update the
// httpModule, Tunneling agent, and/or Forever Agent in use.
Request.prototype._updateProtocol = function () {
  var self = this
  var protocol = self.uri.protocol

  if (protocol === 'https:') {
    // previously was doing http, now doing https
    // if it's https, then we might need to tunnel now.
    if (self.proxy) {
      self.tunnel = true
      var tunnelFn = self.proxy.protocol === 'http:'
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps
      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: self.ca }
      self.agent = tunnelFn(tunnelOptions)
      return
    }

    self.httpModule = https
    switch (self.agentClass) {
      case ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        break
      case http.Agent:
        self.agentClass = https.Agent
        break
      default:
        // nothing we can do.  Just hope for the best.
        return
    }

    // if there's an agent, we need to get a new one.
    if (self.agent) self.agent = self.getAgent()

  } else {
    // previously was doing https, now doing http
    // stop any tunneling.
    if (self.tunnel) self.tunnel = false
    self.httpModule = http
    switch (self.agentClass) {
      case ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        break
      case https.Agent:
        self.agentClass = http.Agent
        break
      default:
        // nothing we can do.  just hope for the best
        return
    }

    // if there's an agent, then get a new one.
    if (self.agent) {
      self.agent = null
      self.agent = self.getAgent()
    }
  }
}

Request.prototype.getAgent = function () {
  var Agent = this.agentClass
  var options = {}
  if (this.agentOptions) {
    for (var i in this.agentOptions) {
      options[i] = this.agentOptions[i]
    }
  }
  if (this.ca) options.ca = this.ca
  if (typeof this.rejectUnauthorized !== 'undefined') options.rejectUnauthorized = this.rejectUnauthorized

  if (this.cert && this.key) {
    options.key = this.key
    options.cert = this.cert
  }

  var poolKey = ''

  // different types of agents are in different pools
  if (Agent !== this.httpModule.Agent) {
    poolKey += Agent.name
  }

  if (!this.httpModule.globalAgent) {
    // node 0.4.x
    options.host = this.host
    options.port = this.port
    if (poolKey) poolKey += ':'
    poolKey += this.host + ':' + this.port
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = this.proxy
  if (typeof proxy === 'string') proxy = url.parse(proxy)
  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'
  if (isHttps) {
    if (options.ca) {
      if (poolKey) poolKey += ':'
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== 'undefined') {
      if (poolKey) poolKey += ':'
      poolKey += options.rejectUnauthorized
    }

    if (options.cert)
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')

    if (options.ciphers) {
      if (poolKey) poolKey += ':'
      poolKey += options.ciphers
    }

    if (options.secureOptions) {
      if (poolKey) poolKey += ':'
      poolKey += options.secureOptions
    }
  }

  if (this.pool === globalPool && !poolKey && Object.keys(options).length === 0 && this.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return this.httpModule.globalAgent
  }

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = this.uri.protocol + poolKey

  // already generated an agent for this setting
  if (this.pool[poolKey]) return this.pool[poolKey]

  return this.pool[poolKey] = new Agent(options)
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self._aborted) return

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {
    self.setHeader('content-length', self.src.stat.size)
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug('make request', self.uri.href)
  self.req = self.httpModule.request(reqOptions, self.onResponse.bind(self))

  if (self.timeout && !self.timeoutTimer) {
    self.timeoutTimer = setTimeout(function () {
      self.req.abort()
      var e = new Error("ETIMEDOUT")
      e.code = "ETIMEDOUT"
      self.emit("error", e)
    }, self.timeout)

    // Set additional timeout on socket - in case if remote
    // server freeze after sending headers
    if (self.req.setTimeout) { // only works on node 0.6+
      self.req.setTimeout(self.timeout, function () {
        if (self.req) {
          self.req.abort()
          var e = new Error("ESOCKETTIMEDOUT")
          e.code = "ESOCKETTIMEDOUT"
          self.emit("error", e)
        }
      })
    }
  }

  self.req.on('error', self.clientErrorHandler)
  self.req.on('drain', function() {
    self.emit('drain')
  })
  self.on('end', function() {
    if ( self.req.connection ) self.req.connection.removeListener('error', self._parserErrorHandler)
  })
  self.emit('request', self.req)
}
Request.prototype.onResponse = function (response) {
  var self = this
  debug('onResponse', self.uri.href, response.statusCode, response.headers)
  response.on('end', function() {
    debug('response end', self.uri.href, response.statusCode, response.headers)
  });

  if (response.connection.listeners('error').indexOf(self._parserErrorHandler) === -1) {
    response.connection.once('error', self._parserErrorHandler)
  }
  if (self._aborted) {
    debug('aborted', self.uri.href)
    response.resume()
    return
  }
  if (self._paused) response.pause()
  else response.resume()

  self.response = response
  response.request = self
  response.toJSON = toJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
      self.strictSSL &&
      !response.client.authorized) {
    debug('strict ssl error', self.uri.href)
    var sslErr = response.client.authorizationError
    self.emit('error', new Error('SSL Error: '+ sslErr))
    return
  }

  if (self.setHost && self.hasHeader('host')) delete self.headers[self.hasHeader('host')]
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var addCookie = function (cookie) {
    if (self._jar){
      if(self._jar.add){
        self._jar.add(new Cookie(cookie))
      }
      else cookieJar.add(new Cookie(cookie))
    }

  }

  if (hasHeader('set-cookie', response.headers) && (!self._disableCookies)) {
    var headerName = hasHeader('set-cookie', response.headers)
    if (Array.isArray(response.headers[headerName])) response.headers[headerName].forEach(addCookie)
    else addCookie(response.headers[headerName])
  }

  var redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && hasHeader('location', response.headers)) {
    var location = response.headers[hasHeader('location', response.headers)]
    debug('redirect', location)

    if (self.followAllRedirects) {
      redirectTo = location
    } else if (self.followRedirect) {
      switch (self.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = location
          break
      }
    }
  } else if (response.statusCode == 401 && self._hasAuth && !self._sentAuth) {
    var authHeader = response.headers[hasHeader('www-authenticate', response.headers)]
    var authVerb = authHeader && authHeader.split(' ')[0]
    debug('reauth', authVerb)

    switch (authVerb) {
      case 'Basic':
        self.auth(self._user, self._pass, true)
        redirectTo = self.uri
        break

      case 'Digest':
        // TODO: More complete implementation of RFC 2617.  For reference:
        // http://tools.ietf.org/html/rfc2617#section-3
        // https://github.com/bagder/curl/blob/master/lib/http_digest.c

        var matches = authHeader.match(/([a-z0-9_-]+)="([^"]+)"/gi)
        var challenge = {}

        for (var i = 0; i < matches.length; i++) {
          var eqPos = matches[i].indexOf('=')
          var key = matches[i].substring(0, eqPos)
          var quotedValue = matches[i].substring(eqPos + 1)
          challenge[key] = quotedValue.substring(1, quotedValue.length - 1)
        }

        var ha1 = md5(self._user + ':' + challenge.realm + ':' + self._pass)
        var ha2 = md5(self.method + ':' + self.uri.path)
        var digestResponse = md5(ha1 + ':' + challenge.nonce + ':1::auth:' + ha2)
        var authValues = {
          username: self._user,
          realm: challenge.realm,
          nonce: challenge.nonce,
          uri: self.uri.path,
          qop: challenge.qop,
          response: digestResponse,
          nc: 1,
          cnonce: ''
        }

        authHeader = []
        for (var k in authValues) {
          authHeader.push(k + '="' + authValues[k] + '"')
        }
        authHeader = 'Digest ' + authHeader.join(', ')
        self.setHeader('authorization', authHeader)
        self._sentAuth = true

        redirectTo = self.uri
        break
    }
  }

  if (redirectTo) {
    debug('redirect to', redirectTo)

    // ignore any potential response body.  it cannot possibly be useful
    // to us at this point.
    if (self._paused) response.resume()

    if (self._redirectsFollowed >= self.maxRedirects) {
      self.emit('error', new Error("Exceeded maxRedirects. Probably stuck in a redirect loop "+self.uri.href))
      return
    }
    self._redirectsFollowed += 1

    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(self.uri.href, redirectTo)
    }

    var uriPrev = self.uri
    self.uri = url.parse(redirectTo)

    // handle the case where we change protocol from https to http or vice versa
    if (self.uri.protocol !== uriPrev.protocol) {
      self._updateProtocol()
    }

    self.redirects.push(
      { statusCode : response.statusCode
      , redirectUri: redirectTo
      }
    )
    if (self.followAllRedirects && response.statusCode != 401) self.method = 'GET'
    // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215
    delete self.src
    delete self.req
    delete self.agent
    delete self._started
    if (response.statusCode != 401) {
      // Remove parameters from the previous response, unless this is the second request
      // for a server that requires digest authentication.
      delete self.body
      delete self._form
      if (self.headers) {
        if (self.hasHeader('host')) delete self.headers[self.hasHeader('host')]
        if (self.hasHeader('content-type')) delete self.headers[self.hasHeader('content-type')]
        if (self.hasHeader('content-length')) delete self.headers[self.hasHeader('content-length')]
      }
    }

    self.emit('redirect');

    self.init()
    return // Ignore the rest of the response
  } else {
    self._redirectsFollowed = self._redirectsFollowed || 0
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function () {
      if (!self._ended) self.response.emit('end')
    })

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.")
      } else {
        response.setEncoding(self.encoding)
      }
    }

    self.emit('response', response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    response.on("data", function (chunk) {
      self._destdata = true
      self.emit("data", chunk)
    })
    response.on("end", function (chunk) {
      self._ended = true
      self.emit("end", chunk)
    })
    response.on("close", function () {self.emit("close")})

    if (self.callback) {
      var buffer = []
      var bodyLen = 0
      self.on("data", function (chunk) {
        buffer.push(chunk)
        bodyLen += chunk.length
      })
      self.on("end", function () {
        debug('end event', self.uri.href)
        if (self._aborted) {
          debug('aborted', self.uri.href)
          return
        }

        if (buffer.length && Buffer.isBuffer(buffer[0])) {
          debug('has body', self.uri.href, bodyLen)
          var body = new Buffer(bodyLen)
          var i = 0
          buffer.forEach(function (chunk) {
            chunk.copy(body, i, 0, chunk.length)
            i += chunk.length
          })
          if (self.encoding === null) {
            response.body = body
          } else {
            response.body = body.toString(self.encoding)
          }
        } else if (buffer.length) {
          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
          if (self.encoding === 'utf8' && buffer[0].length > 0 && buffer[0][0] === "\uFEFF") {
            buffer[0] = buffer[0].substring(1)
          }
          response.body = buffer.join('')
        }

        if (self._json) {
          try {
            response.body = JSON.parse(response.body)
          } catch (e) {}
        }
        debug('emitting complete', self.uri.href)
        if(response.body == undefined && !self._json) {
          response.body = "";
        }
        self.emit('complete', response, response.body)
      })
    }
    //if no callback
    else{
      self.on("end", function () {
        if (self._aborted) {
          debug('aborted', self.uri.href)
          return
        }
        self.emit('complete', response);
      });
    }
  }
  debug('finish init function', self.uri.href)
}

Request.prototype.abort = function () {
  this._aborted = true

  if (this.req) {
    this.req.abort()
  }
  else if (this.response) {
    this.response.abort()
  }

  this.emit("abort")
}

Request.prototype.pipeDest = function (dest) {
  var response = this.response
  // Called after the response is received
  if (dest.headers && !dest.headersSent) {
    if (hasHeader('content-type', response.headers)) {
      var ctname = hasHeader('content-type', response.headers)
      if (dest.setHeader) dest.setHeader(ctname, response.headers[ctname])
      else dest.headers[ctname] = response.headers[ctname]
    }

    if (hasHeader('content-length', response.headers)) {
      var clname = hasHeader('content-length', response.headers)
      if (dest.setHeader) dest.setHeader(clname, response.headers[clname])
      else dest.headers[clname] = response.headers[clname]
    }
  }
  if (dest.setHeader && !dest.headersSent) {
    for (var i in response.headers) {
      dest.setHeader(i, response.headers[i])
    }
    dest.statusCode = response.statusCode
  }
  if (this.pipefilter) this.pipefilter(response, dest)
}

// Composable API
Request.prototype.setHeader = function (name, value, clobber) {
  if (clobber === undefined) clobber = true
  if (clobber || !this.hasHeader(name)) this.headers[name] = value
  else this.headers[this.hasHeader(name)] += ',' + value
  return this
}
Request.prototype.setHeaders = function (headers) {
  for (var i in headers) {this.setHeader(i, headers[i])}
  return this
}
Request.prototype.hasHeader = function (header, headers) {
  var headers = Object.keys(headers || this.headers)
    , lheaders = headers.map(function (h) {return h.toLowerCase()})
    ;
  header = header.toLowerCase()
  for (var i=0;i<lheaders.length;i++) {
    if (lheaders[i] === header) return headers[i]
  }
  return false
}

var hasHeader = Request.prototype.hasHeader

Request.prototype.qs = function (q, clobber) {
  var base
  if (!clobber && this.uri.query) base = qs.parse(this.uri.query)
  else base = {}

  for (var i in q) {
    base[i] = q[i]
  }

  if (qs.stringify(base) === ''){
    return this
  }

  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base))
  this.url = this.uri
  this.path = this.uri.path

  return this
}
Request.prototype.form = function (form) {
  if (form) {
    this.setHeader('content-type', 'application/x-www-form-urlencoded; charset=utf-8')
    this.body = qs.stringify(form).toString('utf8')
    return this
  }
  // create form-data object
  this._form = new FormData()
  return this._form
}
Request.prototype.multipart = function (multipart) {
  var self = this
  self.body = []

  if (!self.hasHeader('content-type')) {
    self.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)
  } else {
    self.setHeader('content-type', self.headers['content-type'].split(';')[0] + '; boundary=' + self.boundary)
  }

  if (!multipart.forEach) throw new Error('Argument error, options.multipart.')

  if (self.preambleCRLF) {
    self.body.push(new Buffer('\r\n'))
  }

  multipart.forEach(function (part) {
    var body = part.body
    if(body == null) throw Error('Body attribute missing in multipart.')
    delete part.body
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part).forEach(function (key) {
      preamble += key + ': ' + part[key] + '\r\n'
    })
    preamble += '\r\n'
    self.body.push(new Buffer(preamble))
    self.body.push(new Buffer(body))
    self.body.push(new Buffer('\r\n'))
  })
  self.body.push(new Buffer('--' + self.boundary + '--'))
  return self
}
Request.prototype.json = function (val) {
  var self = this

  if (!self.hasHeader('accept')) self.setHeader('accept', 'application/json')

  this._json = true
  if (typeof val === 'boolean') {
    if (typeof this.body === 'object') {
      this.body = safeStringify(this.body)
      self.setHeader('content-type', 'application/json')
    }
  } else {
    this.body = safeStringify(val)
    self.setHeader('content-type', 'application/json')
  }
  return this
}
Request.prototype.getHeader = function (name, headers) {
  var result, re, match
  if (!headers) headers = this.headers
  Object.keys(headers).forEach(function (key) {
    re = new RegExp(name, 'i')
    match = key.match(re)
    if (match) result = headers[key]
  })
  return result
}
var getHeader = Request.prototype.getHeader

Request.prototype.auth = function (user, pass, sendImmediately) {
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
    throw new Error('auth() received invalid user or password')
  }
  this._user = user
  this._pass = pass
  this._hasAuth = true
  var header = typeof pass !== 'undefined' ? user + ':' + pass : user
  if (sendImmediately || typeof sendImmediately == 'undefined') {
    this.setHeader('authorization', 'Basic ' + toBase64(header))
    this._sentAuth = true
  }
  return this
}
Request.prototype.aws = function (opts, now) {
  if (!now) {
    this._aws = opts
    return this
  }
  var date = new Date()
  this.setHeader('date', date.toUTCString())
  var auth =
    { key: opts.key
    , secret: opts.secret
    , verb: this.method.toUpperCase()
    , date: date
    , contentType: this.getHeader('content-type') || ''
    , md5: this.getHeader('content-md5') || ''
    , amazonHeaders: aws.canonicalizeHeaders(this.headers)
    }
  if (opts.bucket && this.path) {
    auth.resource = '/' + opts.bucket + this.path
  } else if (opts.bucket && !this.path) {
    auth.resource = '/' + opts.bucket
  } else if (!opts.bucket && this.path) {
    auth.resource = this.path
  } else if (!opts.bucket && !this.path) {
    auth.resource = '/'
  }
  auth.resource = aws.canonicalizeResource(auth.resource)
  this.setHeader('authorization', aws.authorization(auth))

  return this
}
Request.prototype.httpSignature = function (opts) {
  var req = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return getHeader(header, req.headers)
    },
    setHeader: function(header, value) {
      req.setHeader(header, value)
    },
    method: this.method,
    path: this.path
  }, opts)
  debug('httpSignature authorization', this.getHeader('authorization'))

  return this
}

Request.prototype.hawk = function (opts) {
  this.setHeader('Authorization', hawk.client.header(this.uri, this.method, opts).field)
}

Request.prototype.oauth = function (_oauth) {
  var form
  if (this.hasHeader('content-type') &&
      this.getHeader('content-type').slice(0, 'application/x-www-form-urlencoded'.length) ===
        'application/x-www-form-urlencoded'
     ) {
    form = qs.parse(this.body)
  }
  if (this.uri.query) {
    form = qs.parse(this.uri.query)
  }
  if (!form) form = {}
  var oa = {}
  for (var i in form) oa[i] = form[i]
  for (var i in _oauth) oa['oauth_'+i] = _oauth[i]
  if (!oa.oauth_version) oa.oauth_version = '1.0'
  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')

  oa.oauth_signature_method = 'HMAC-SHA1'

  var consumer_secret = oa.oauth_consumer_secret
  delete oa.oauth_consumer_secret
  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret
  var timestamp = oa.oauth_timestamp

  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname
  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret)

  // oa.oauth_signature = signature
  for (var i in form) {
    if ( i.slice(0, 'oauth_') in _oauth) {
      // skip
    } else {
      delete oa['oauth_'+i]
      if (i !== 'x_auth_mode') delete oa[i]
    }
  }
  oa.oauth_timestamp = timestamp
  var authHeader = 'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'="'+oauth.rfc3986(oa[i])+'"'}).join(',')
  authHeader += ',oauth_signature="' + oauth.rfc3986(signature) + '"'
  this.setHeader('Authorization', authHeader)
  return this
}
Request.prototype.jar = function (jar) {
  var cookies

  if (this._redirectsFollowed === 0) {
    this.originalCookieHeader = this.getHeader('cookie')
  }

  if (!jar) {
    // disable cookies
    cookies = false
    this._disableCookies = true
  } else if (jar && jar.get) {
    // fetch cookie from the user defined cookie jar
    cookies = jar.get({ url: this.uri.href })
  } else {
    // fetch cookie from the global cookie jar
    cookies = cookieJar.get({ url: this.uri.href })
  }

  if (cookies && cookies.length) {
    var cookieString = cookies.map(function (c) {
      return c.name + "=" + c.value
    }).join("; ")

    if (this.originalCookieHeader) {
      // Don't overwrite existing Cookie header
      this.setHeader('cookie', this.originalCookieHeader + '; ' + cookieString)
    } else {
      this.setHeader('cookie', cookieString)
    }
  }
  this._jar = jar
  return this
}


// Stream API
Request.prototype.pipe = function (dest, opts) {
  if (this.response) {
    if (this._destdata) {
      throw new Error("You cannot pipe after data has been emitted from the response.")
    } else if (this._ended) {
      throw new Error("You cannot pipe after the response has been ended.")
    } else {
      stream.Stream.prototype.pipe.call(this, dest, opts)
      this.pipeDest(dest)
      return dest
    }
  } else {
    this.dests.push(dest)
    stream.Stream.prototype.pipe.call(this, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  if (!this._started) this.start()
  return this.req.write.apply(this.req, arguments)
}
Request.prototype.end = function (chunk) {
  if (chunk) this.write(chunk)
  if (!this._started) this.start()
  this.req.end()
}
Request.prototype.pause = function () {
  if (!this.response) this._paused = true
  else this.response.pause.apply(this.response, arguments)
}
Request.prototype.resume = function () {
  if (!this.response) this._paused = false
  else this.response.resume.apply(this.response, arguments)
}
Request.prototype.destroy = function () {
  if (!this._ended) this.end()
  else if (this.response) this.response.destroy()
}

function toJSON () {
  return getSafe(this, '__' + (((1+Math.random())*0x10000)|0).toString(16))
}

Request.prototype.toJSON = toJSON


module.exports = Request
return {
    http: (typeof http !== "undefined") ? http : null,
    require: (typeof require !== "undefined") ? require : null,
    https: (typeof https !== "undefined") ? https : null,
    tls: (typeof tls !== "undefined") ? tls : null,
    url: (typeof url !== "undefined") ? url : null,
    util: (typeof util !== "undefined") ? util : null,
    stream: (typeof stream !== "undefined") ? stream : null,
    qs: (typeof qs !== "undefined") ? qs : null,
    querystring: (typeof querystring !== "undefined") ? querystring : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    oauth: (typeof oauth !== "undefined") ? oauth : null,
    hawk: (typeof hawk !== "undefined") ? hawk : null,
    aws: (typeof aws !== "undefined") ? aws : null,
    httpSignature: (typeof httpSignature !== "undefined") ? httpSignature : null,
    uuid: (typeof uuid !== "undefined") ? uuid : null,
    mime: (typeof mime !== "undefined") ? mime : null,
    tunnel: (typeof tunnel !== "undefined") ? tunnel : null,
    _safeStringify: (typeof _safeStringify !== "undefined") ? _safeStringify : null,
    ForeverAgent: (typeof ForeverAgent !== "undefined") ? ForeverAgent : null,
    FormData: (typeof FormData !== "undefined") ? FormData : null,
    Cookie: (typeof Cookie !== "undefined") ? Cookie : null,
    CookieJar: (typeof CookieJar !== "undefined") ? CookieJar : null,
    cookieJar: (typeof cookieJar !== "undefined") ? cookieJar : null,
    copy: (typeof copy !== "undefined") ? copy : null,
    debug: (typeof debug !== "undefined") ? debug : null,
    getSafe: (typeof getSafe !== "undefined") ? getSafe : null,
    safeStringify: (typeof safeStringify !== "undefined") ? safeStringify : null,
    JSON: (typeof JSON !== "undefined") ? JSON : null,
    globalPool: (typeof globalPool !== "undefined") ? globalPool : null,
    isUrl: (typeof isUrl !== "undefined") ? isUrl : null,
    isReadStream: (typeof isReadStream !== "undefined") ? isReadStream : null,
    toBase64: (typeof toBase64 !== "undefined") ? toBase64 : null,
    md5: (typeof md5 !== "undefined") ? md5 : null,
    Request: (typeof Request !== "undefined") ? Request : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    clearTimeout: (typeof clearTimeout !== "undefined") ? clearTimeout : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    console: (typeof console !== "undefined") ? console : null,
    process: (typeof process !== "undefined") ? process : null,
    setTimeout: (typeof setTimeout !== "undefined") ? setTimeout : null,
    hasHeader: (typeof hasHeader !== "undefined") ? hasHeader : null,
    getHeader: (typeof getHeader !== "undefined") ? getHeader : null,
    Date: (typeof Date !== "undefined") ? Date : null,
    Math: (typeof Math !== "undefined") ? Math : null,
    toJSON: (typeof toJSON !== "undefined") ? toJSON : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/request.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/qs/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"c70b9b617a7da4031b6086f59e85be2a33adb799-qs/index.js"}
require.memoize("c70b9b617a7da4031b6086f59e85be2a33adb799-qs/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/qs';
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      ret.push(key);
    }
  }
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = {}
  var t = {};
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  
  // illegal
  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;
  
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = {};
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: {} }).base;

  return compact(ret);
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/qs/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/oauth-sign/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"a539f9d7ca6a8781e1ff659d774d5f222017a60d-oauth-sign/index.js"}
require.memoize("a539f9d7ca6a8781e1ff659d774d5f222017a60d-oauth-sign/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/oauth-sign';
var crypto = require('__SYSTEM__/crypto')
  , qs = require('__SYSTEM__/querystring')
  ;

function sha1 (key, body) {
  return crypto.createHmac('sha1', key).update(body).digest('base64')
}

function rfc3986 (str) {
  return encodeURIComponent(str)
    .replace(/!/g,'%21')
    .replace(/\*/g,'%2A')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29')
    .replace(/'/g,'%27')
    ;
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  var querystring = Object.keys(params).sort().map(function(key){
    // big WTF here with the escape + encoding but it's what twitter wants
    return escape(rfc3986(key)) + "%3D" + escape(rfc3986(params[key]))
  }).join('%26')

  var base = [
    httpMethod ? httpMethod.toUpperCase() : 'GET',
    rfc3986(base_uri),
    querystring
  ].join('&')

  var key = [
    consumer_secret,
    token_secret || ''
  ].map(rfc3986).join('&')

  return sha1(key, base)
}

exports.hmacsign = hmacsign
exports.rfc3986 = rfc3986

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/oauth-sign/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/index.js"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/index.js"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib';
// Export sub-modules

exports.error = exports.Error = require('boom');
exports.sntp = require('sntp');
exports.server = require('./server');
exports.client = require('./client');
exports.crypto = require('./crypto');
exports.utils = require('./utils');

exports.uri = {
    authenticate: exports.server.authenticateBewit,
    getBewit: exports.client.getBewit
};



}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/index.js"}
require.memoize("534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/lib/index.js"}
require.memoize("534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom/lib';
// Load modules

var Http = require('__SYSTEM__/http');
var NodeUtil = require('__SYSTEM__/util');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports = module.exports = internals.Boom = function (/* (new Error) or (code, message) */) {

    var self = this;

    Hoek.assert(this.constructor === internals.Boom, 'Error must be instantiated using new');

    Error.call(this);
    this.isBoom = true;

    this.response = {
        code: 0,
        payload: {},
        headers: {}
        // type: 'content-type'
    };

    if (arguments[0] instanceof Error) {

        // Error

        var error = arguments[0];

        this.data = error;
        this.response.code = error.code || 500;
        if (error.message) {
            this.message = error.message;
        }
    }
    else {

        // code, message

        var code = arguments[0];
        var message = arguments[1];

        Hoek.assert(!isNaN(parseFloat(code)) && isFinite(code) && code >= 400, 'First argument must be a number (400+)');

        this.response.code = code;
        if (message) {
            this.message = message;
        }
    }

    // Response format

    this.reformat();

    return this;
};

NodeUtil.inherits(internals.Boom, Error);


internals.Boom.prototype.reformat = function () {

    this.response.payload.code = this.response.code;
    this.response.payload.error = Http.STATUS_CODES[this.response.code] || 'Unknown';
    if (this.message) {
        this.response.payload.message = Hoek.escapeHtml(this.message);         // Prevent XSS from error message
    }
};


// Utilities

internals.Boom.badRequest = function (message) {

    return new internals.Boom(400, message);
};


internals.Boom.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])

    var err = new internals.Boom(401, message);

    if (!scheme) {
        return err;
    }

    var wwwAuthenticate = '';

    if (typeof scheme === 'string') {

        // function (message, scheme, attributes)

        wwwAuthenticate = scheme;
        if (attributes) {
            var names = Object.keys(attributes);
            for (var i = 0, il = names.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ',';
                }

                var value = attributes[names[i]];
                if (value === null ||
                    value === undefined) {              // Value can be zero

                    value = '';
                }
                wwwAuthenticate += ' ' + names[i] + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
            }
        }

        if (message) {
            if (attributes) {
                wwwAuthenticate += ',';
            }
            wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
        }
        else {
            err.isMissing = true;
        }
    }
    else {

        // function (message, wwwAuthenticate[])

        var wwwArray = scheme;
        for (var i = 0, il = wwwArray.length; i < il; ++i) {
            if (i) {
                wwwAuthenticate += ', ';
            }

            wwwAuthenticate += wwwArray[i];
        }
    }

    err.response.headers['WWW-Authenticate'] = wwwAuthenticate;

    return err;
};


internals.Boom.clientTimeout = function (message) {

    return new internals.Boom(408, message);
};


internals.Boom.serverTimeout = function (message) {

    return new internals.Boom(503, message);
};


internals.Boom.forbidden = function (message) {

    return new internals.Boom(403, message);
};


internals.Boom.notFound = function (message) {

    return new internals.Boom(404, message);
};


internals.Boom.internal = function (message, data) {

    var err = new internals.Boom(500, message);

    if (data && data.stack) {
        err.trace = data.stack.split('\n');
        err.outterTrace = Hoek.displayStack(1);
    }
    else {
        err.trace = Hoek.displayStack(1);
    }

    err.data = data;
    err.response.payload.message = 'An internal server error occurred';                     // Hide actual error from user

    return err;
};


internals.Boom.passThrough = function (code, payload, contentType, headers) {

    var err = new internals.Boom(500, 'Pass-through');                                      // 500 code is only used to initialize

    err.data = {
        code: code,
        payload: payload,
        type: contentType
    };

    err.response.code = code;
    err.response.type = contentType;
    err.response.headers = headers;
    err.response.payload = payload;

    return err;
};



}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/index.js"}
require.memoize("0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/lib/index.js"}
require.memoize("0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp/lib';
// Load modules

var Dgram = require('__SYSTEM__/dgram');
var Dns = require('__SYSTEM__/dns');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports.time = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var settings = Hoek.clone(options);
    settings.host = settings.host || 'pool.ntp.org';
    settings.port = settings.port || 123;
    settings.resolveReference = settings.resolveReference || false;

    // Declare variables used by callback

    var timeoutId = 0;
    var sent = 0;

    // Ensure callback is only called once

    var isFinished = false;
    var finish = function (err, result) {

        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = 0;
        }

        if (!isFinished) {
            isFinished = true;
            socket.removeAllListeners();
            socket.close();
            return callback(err, result);
        }
    };

    // Create UDP socket

    var socket = Dgram.createSocket('udp4');

    socket.once('error', function (err) {

        return finish(err);
    });

    // Listen to incoming messages

    socket.on('message', function (buffer, rinfo) {

        var received = Date.now();

        var message = new internals.NtpMessage(buffer);
        if (!message.isValid) {
            return finish(new Error('Invalid server response'), message);
        }

        if (message.originateTimestamp !== sent) {
            return finish(new Error('Wrong originate timestamp'), message);
        }

        // Timestamp Name          ID   When Generated
        // ------------------------------------------------------------
        // Originate Timestamp     T1   time request sent by client
        // Receive Timestamp       T2   time request received by server
        // Transmit Timestamp      T3   time reply sent by server
        // Destination Timestamp   T4   time reply received by client
        //
        // The roundtrip delay d and system clock offset t are defined as:
        //
        // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2

        var T1 = message.originateTimestamp;
        var T2 = message.receiveTimestamp;
        var T3 = message.transmitTimestamp;
        var T4 = received;

        message.d = (T4 - T1) - (T3 - T2);
        message.t = ((T2 - T1) + (T3 - T4)) / 2;
        message.receivedLocally = received;

        if (!settings.resolveReference ||
            message.stratum !== 'secondary') {

            return finish(null, message);
        }

        // Resolve reference IP address

        Dns.reverse(message.referenceId, function (err, domains) {

            if (!err) {
                message.referenceHost = domains[0];
            }

            return finish(null, message);
        });
    });

    // Set timeout

    if (settings.timeout) {
        timeoutId = setTimeout(function () {

            timeoutId = 0;
            return finish(new Error('Timeout'));
        }, settings.timeout);
    }

    // Construct NTP message

    var message = new Buffer(48);
    for (var i = 0; i < 48; i++) {                      // Zero message
        message[i] = 0;
    }

    message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
    sent = Date.now();
    internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)

    // Send NTP request

    socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {

        if (err ||
            bytes !== 48) {

            return finish(err || new Error('Could not send entire message'));
        }
    });
};


internals.NtpMessage = function (buffer) {

    this.isValid = false;

    // Validate

    if (buffer.length !== 48) {
        return;
    }

    // Leap indicator

    var li = (buffer[0] >> 6);
    switch (li) {
        case 0: this.leapIndicator = 'no-warning'; break;
        case 1: this.leapIndicator = 'last-minute-61'; break;
        case 2: this.leapIndicator = 'last-minute-59'; break;
        case 3: this.leapIndicator = 'alarm'; break;
    }

    // Version

    var vn = ((buffer[0] & 0x38) >> 3);
    this.version = vn;

    // Mode

    var mode = (buffer[0] & 0x7);
    switch (mode) {
        case 1: this.mode = 'symmetric-active'; break;
        case 2: this.mode = 'symmetric-passive'; break;
        case 3: this.mode = 'client'; break;
        case 4: this.mode = 'server'; break;
        case 5: this.mode = 'broadcast'; break;
        case 0:
        case 6:
        case 7: this.mode = 'reserved'; break;
    }

    // Stratum

    var stratum = buffer[1];
    if (stratum === 0) {
        this.stratum = 'death';
    }
    else if (stratum === 1) {
        this.stratum = 'primary';
    }
    else if (stratum <= 15) {
        this.stratum = 'secondary';
    }
    else {
        this.stratum = 'reserved';
    }

    // Poll interval (msec)

    this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;

    // Precision (msecs)

    this.precision = Math.pow(2, buffer[3]) * 1000;

    // Root delay (msecs)

    var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
    this.rootDelay = 1000 * (rootDelay / 0x10000);

    // Root dispersion (msecs)

    this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;

    // Reference identifier

    this.referenceId = '';
    switch (this.stratum) {
        case 'death':
        case 'primary':
            this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
            break;
        case 'secondary':
            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
            break;
    }

    // Reference timestamp

    this.referenceTimestamp = internals.toMsecs(buffer, 16);

    // Originate timestamp

    this.originateTimestamp = internals.toMsecs(buffer, 24);

    // Receive timestamp

    this.receiveTimestamp = internals.toMsecs(buffer, 32);

    // Transmit timestamp

    this.transmitTimestamp = internals.toMsecs(buffer, 40);

    // Validate

    if (this.version === 4 &&
        this.stratum !== 'reserved' &&
        this.mode === 'server' &&
        this.originateTimestamp &&
        this.receiveTimestamp &&
        this.transmitTimestamp) {

        this.isValid = true;
    }

    return this;
};


internals.toMsecs = function (buffer, offset) {

    var seconds = 0;
    var fraction = 0;

    for (var i = 0; i < 4; ++i) {
        seconds = (seconds * 256) + buffer[offset + i];
    }

    for (i = 4; i < 8; ++i) {
        fraction = (fraction * 256) + buffer[offset + i];
    }

    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
};


internals.fromMsecs = function (ts, buffer, offset) {

    var seconds = Math.floor(ts / 1000) + 2208988800;
    var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));

    buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
    buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
    buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
    buffer[offset + 3] = (seconds & 0x000000FF);

    buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
    buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
    buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
    buffer[offset + 7] = (fraction & 0x000000FF);
};


// Offset singleton

internals.last = {
    offset: 0,
    expires: 0,
    host: '',
    port: 0
};


exports.offset = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var now = Date.now();
    var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily

    if (internals.last.offset &&
        internals.last.host === options.host &&
        internals.last.port === options.port &&
        now < internals.last.expires) {

        process.nextTick(function () {
                
            callback(null, internals.last.offset);
        });

        return;
    }

    exports.time(options, function (err, time) {

        if (err) {
            return callback(err, 0);
        }

        internals.last = {
            offset: Math.round(time.t),
            expires: now + clockSyncRefresh,
            host: options.host,
            port: options.port
        };

        return callback(null, internals.last.offset);
    });
};


// Now singleton

internals.now = {
    intervalId: 0
};


exports.start = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    if (internals.now.intervalId) {
        process.nextTick(function () {
            
            callback();
        });
        
        return;
    }

    exports.offset(options, function (err, offset) {

        internals.now.intervalId = setInterval(function () {

            exports.offset(options, function () { });
        }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily

        return callback();
    });
};


exports.stop = function () {

    if (!internals.now.intervalId) {
        return;
    }

    clearInterval(internals.now.intervalId);
    internals.now.intervalId = 0;
};


exports.isLive = function () {

    return !!internals.now.intervalId;
};


exports.now = function () {

    var now = Date.now();
    if (!exports.isLive() ||
        now >= internals.last.expires) {

        return now;
    }

    return now + internals.last.offset;
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/server.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/server.js"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/server.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib';
// Load modules

var Boom = require('boom');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Hawk authentication

/*
   req:                 node's HTTP request object or an object as follows:
  
                        var request = {
                            method: 'GET',
                            url: '/resource/4?a=1&b=2',
                            host: 'example.com',
                            port: 8080,
                            authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
                        };
  
   credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
                        The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
                        needed by the application. This function is the equivalent of verifying the username and
                        password in Basic authentication.
  
                        var credentialsFunc = function (id, callback) {
    
                            // Lookup credentials in database
                            db.lookup(id, function (err, item) {
    
                                if (err || !item) {
                                    return callback(err);
                                }
    
                                var credentials = {
                                    // Required
                                    key: item.key,
                                    algorithm: item.algorithm,
                                    // Application specific
                                    user: item.user
                                };
    
                                return callback(null, credentials);
                            });
                        };
  
   options: {

        hostHeaderName:        optional header field name, used to override the default 'Host' header when used
                               behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
                               the original (which is what the module must verify) in the 'x-forwarded-host' header field.
                               Only used when passed a node Http.ServerRequest object.
  
        nonceFunc:             optional nonce validation function. The function signature is function(nonce, ts, callback)
                               where 'callback' must be called using the signature function(err).
  
        timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
                               Provides a +/- skew which means actual allowed window is double the number of seconds.
  
        localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
                               Defaults to 0.
  
        payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
                               header attribute. The server always ensures the value provided has been included in the request
                               MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
                               a hash value over the entire payload (assuming it has already be normalized to the same format and
                               encoding used by the client to calculate the hash on request). If the payload is not available at the time
                               of authentication, the authenticatePayload() method can be used by passing it the credentials and
                               attributes.hash returned in the authenticate callback.

        host:                  optional host name override. Only used when passed a node request object.
        port:                  optional port override. Only used when passed a node request object.
    }

    callback: function (err, credentials, artifacts) { }
 */

exports.authenticate = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);
    
    // Default options

    options.nonceFunc = options.nonceFunc || function (nonce, ts, nonceCallback) { return nonceCallback(); };   // No validation
    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Parse HTTP Authorization header

    var attributes = Utils.parseAuthorizationHeader(request.authorization);
    if (attributes instanceof Error) {
        return callback(attributes);
    }

    // Construct artifacts container

    var artifacts = {
        method: request.method,
        host: request.host,
        port: request.port,
        resource: request.url,
        ts: attributes.ts,
        nonce: attributes.nonce,
        hash: attributes.hash,
        ext: attributes.ext,
        app: attributes.app,
        dlg: attributes.dlg,
        mac: attributes.mac,
        id: attributes.id
    };

    // Verify required header attributes

    if (!attributes.id ||
        !attributes.ts ||
        !attributes.nonce ||
        !attributes.mac) {

        return callback(Boom.badRequest('Missing attributes'), null, artifacts);
    }

    // Fetch Hawk credentials

    credentialsFunc(attributes.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, artifacts);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('header', credentials, artifacts);
        if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
        }

        // Check payload hash

        if (options.payload !== null &&
            options.payload !== undefined) {       // '' is valid

            if (!attributes.hash) {
                return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
            }

            var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
            if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
                return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
            }
        }

        // Check nonce

        options.nonceFunc(attributes.nonce, attributes.ts, function (err) {

            if (err) {
                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
            }

            // Check timestamp staleness

            if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                var fresh = Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);            // Get fresh now
                var tsm = Crypto.calculateTsMac(fresh, credentials);
                return callback(Boom.unauthorized('Stale timestamp', 'Hawk', { ts: fresh, tsm: tsm }), credentials, artifacts);
            }

            // Successful authentication

            return callback(null, credentials, artifacts);
        });
    });
};


// Authenticate payload hash - used when payload cannot be provided during authenticate()

/*
    payload:        raw request payload
    credentials:    from authenticate callback
    artifacts:      from authenticate callback
    contentType:    req.headers['content-type']
*/

exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {

    var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
    return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
};


// Generate a Server-Authorization header for a given response

/*
    credentials: {},                                        // Object received from authenticate()
    artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
    options: {
        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
    }
*/

exports.header = function (credentials, artifacts, options) {

    // Prepare inputs

    options = options || {};

    if (!artifacts ||
        typeof artifacts !== 'object' ||
        typeof options !== 'object') {

        return '';
    }

    artifacts = Hoek.clone(artifacts);
    delete artifacts.mac;
    artifacts.hash = options.hash;
    artifacts.ext = options.ext;

    // Validate credentials

    if (!credentials ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('response', credentials, artifacts);

    // Construct header

    var header = 'Hawk mac="' + mac + '"' +
                 (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');

    if (artifacts.ext !== null &&
        artifacts.ext !== undefined &&
        artifacts.ext !== '') {                       // Other falsey values allowed

        header += ', ext="' + Utils.escapeHeaderAttribute(artifacts.ext) + '"';
    }

    return header;
};


/*
 * Arguments and options are the same as authenticate() with the exception that the only supported options are:
 * 'hostHeaderName', 'localtimeOffsetMsec', 'host', 'port'
 */

exports.authenticateBewit = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Extract bewit

    //                                 1     2             3           4     
    var resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/);
    if (!resource) {
        return callback(Boom.unauthorized(null, 'Hawk'));
    }

    // Bewit not empty

    if (!resource[3]) {
        return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
    }

    // Verify method is GET

    if (request.method !== 'GET' &&
        request.method !== 'HEAD') {

        return callback(Boom.unauthorized('Invalid method', 'Hawk'));
    }

    // No other authentication

    if (request.authorization) {
        return callback(Boom.badRequest('Multiple authentications', 'Hawk'));
    }

    // Parse bewit

    var bewitString = Utils.base64urlDecode(resource[3]);
    if (bewitString instanceof Error) {
        return callback(Boom.badRequest('Invalid bewit encoding'));
    }

    // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)

    var bewitParts = bewitString.split('\\');
    if (!bewitParts ||
        bewitParts.length !== 4) {

        return callback(Boom.badRequest('Invalid bewit structure'));
    }

    var bewit = {
        id: bewitParts[0],
        exp: parseInt(bewitParts[1], 10),
        mac: bewitParts[2],
        ext: bewitParts[3] || ''
    };

    if (!bewit.id ||
        !bewit.exp ||
        !bewit.mac) {

        return callback(Boom.badRequest('Missing bewit attributes'));
    }

    // Construct URL without bewit

    var url = resource[1];
    if (resource[4]) {
        url += resource[2] + resource[4];
    }

    // Check expiration

    if (bewit.exp * 1000 <= now) {
        return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
    }

    // Fetch Hawk credentials

    credentialsFunc(bewit.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, bewit.ext);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, bewit);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('bewit', credentials, {
            ts: bewit.exp,
            nonce: '',
            method: 'GET',
            resource: url,
            host: request.host,
            port: request.port,
            ext: bewit.ext
        });

        if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
        }

        // Successful authentication

        return callback(null, credentials, bewit);
    });
};


/*
 *  options are the same as authenticate() with the exception that the only supported options are:
 * 'nonceFunc', 'timestampSkewSec', 'localtimeOffsetMsec'
 */

exports.authenticateMessage = function (host, port, message, authorization, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);
    
    // Default options

    options.nonceFunc = options.nonceFunc || function (nonce, ts, nonceCallback) { return nonceCallback(); };   // No validation
    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Validate authorization
    
    if (!authorization.id ||
        !authorization.ts ||
        !authorization.nonce ||
        !authorization.hash ||
        !authorization.mac) {
        
            return callback(Boom.badRequest('Invalid authorization'))
    }

    // Fetch Hawk credentials

    credentialsFunc(authorization.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'));
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials);
        }

        // Construct artifacts container

        var artifacts = {
            ts: authorization.ts,
            nonce: authorization.nonce,
            host: host,
            port: port,
            hash: authorization.hash
        };

        // Calculate MAC

        var mac = Crypto.calculateMac('message', credentials, artifacts);
        if (!Cryptiles.fixedTimeComparison(mac, authorization.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials);
        }

        // Check payload hash

        var hash = Crypto.calculatePayloadHash(message, credentials.algorithm);
        if (!Cryptiles.fixedTimeComparison(hash, authorization.hash)) {
            return callback(Boom.unauthorized('Bad message hash', 'Hawk'), credentials);
        }

        // Check nonce

        options.nonceFunc(authorization.nonce, authorization.ts, function (err) {

            if (err) {
                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials);
            }

            // Check timestamp staleness

            if (Math.abs((authorization.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                return callback(Boom.unauthorized('Stale timestamp'), credentials);
            }

            // Successful authentication

            return callback(null, credentials);
        });
    });
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/server.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/index.js"}
require.memoize("8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/lib/index.js"}
require.memoize("8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/lib';
// Load modules

var Fs = require('__SYSTEM__/fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/lib/escape.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/lib/escape.js"}
require.memoize("8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/lib/escape.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/lib';
// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/lib/escape.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/index.js"}
require.memoize("2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles';
module.exports = require('./lib');
return {
    module: (typeof module !== "undefined") ? module : null,
    require: (typeof require !== "undefined") ? require : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles/lib/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/lib/index.js"}
require.memoize("2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles/lib';
// Load modules

var Crypto = require('__SYSTEM__/crypto');
var Boom = require('boom');


// Declare internals

var internals = {};


// Generate a cryptographically strong pseudo-random data

exports.randomString = function (size) {

    var buffer = exports.randomBits((size + 1) * 6);
    if (buffer instanceof Error) {
        return buffer;
    }

    var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
};


exports.randomBits = function (bits) {

    if (!bits ||
        bits < 0) {

        return Boom.internal('Invalid random bits count');
    }

    var bytes = Math.ceil(bits / 8);
    try {
        return Crypto.randomBytes(bytes);
    }
    catch (err) {
        return Boom.internal('Failed generating random bits: ' + err.message);
    }
};


// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)

exports.fixedTimeComparison = function (a, b) {

    if (typeof a !== 'string' ||
        typeof b !== 'string') {

        return false;
    }

    var mismatch = (a.length === b.length ? 0 : 1);
    if (mismatch) {
        b = a;
    }

    for (var i = 0, il = a.length; i < il; ++i) {
        var ac = a.charCodeAt(i);
        var bc = b.charCodeAt(i);
        mismatch += (ac === bc ? 0 : 1);
    }

    return (mismatch === 0);
};



}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/crypto.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/crypto.js"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/crypto.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib';
// Load modules

var Crypto = require('__SYSTEM__/crypto');
var Url = require('__SYSTEM__/url');
var Utils = require('./utils');


// Declare internals

var internals = {};


// MAC normalization format version

exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats


// Supported HMAC algorithms

exports.algorithms = ['sha1', 'sha256'];


// Calculate the request MAC

/*
    type: 'header',                                 // 'header', 'bewit', 'response'
    credentials: {
        key: 'aoijedoaijsdlaksjdl',
        algorithm: 'sha256'                         // 'sha1', 'sha256'
    },
    options: {
        method: 'GET',
        resource: '/resource?a=1&b=2',
        host: 'example.com',
        port: 8080,
        ts: 1357718381034,
        nonce: 'd3d345f',
        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
        ext: 'app-specific-data',
        app: 'hf48hd83qwkj',                        // Application id (Oz)
        dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
    }
*/

exports.calculateMac = function (type, credentials, options) {

    var normalized = exports.generateNormalizedString(type, options);

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest('base64');
    return digest;
};


exports.generateNormalizedString = function (type, options) {

    var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
                     options.ts + '\n' +
                     options.nonce + '\n' +
                     (options.method || '').toUpperCase() + '\n' +
                     (options.resource || '') + '\n' +
                     options.host.toLowerCase() + '\n' +
                     options.port + '\n' +
                     (options.hash || '') + '\n';

    if (options.ext) {
        normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
    }

    normalized += '\n';

    if (options.app) {
        normalized += options.app + '\n' +
                      (options.dlg || '') + '\n';
    }

    return normalized;
};


exports.calculatePayloadHash = function (payload, algorithm, contentType) {

    var hash = exports.initializePayloadHash(algorithm, contentType);
    hash.update(payload || '');
    return exports.finalizePayloadHash(hash);
};


exports.initializePayloadHash = function (algorithm, contentType) {

    var hash = Crypto.createHash(algorithm);
    hash.update('hawk.' + exports.headerVersion + '.payload\n');
    hash.update(Utils.parseContentType(contentType) + '\n');
    return hash;
};


exports.finalizePayloadHash = function (hash) {

    hash.update('\n');
    return hash.digest('base64');
};


exports.calculateTsMac = function (ts, credentials) {

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
    hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
    return hmac.digest('base64');
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/crypto.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/utils.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/utils.js"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/utils.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib';
// Load modules

var Hoek = require('hoek');
var Sntp = require('sntp');
var Boom = require('boom');


// Declare internals

var internals = {};


// Import Hoek Utilities

internals.import = function () {

    for (var i in Hoek) {
        if (Hoek.hasOwnProperty(i)) {
            exports[i] = Hoek[i];
        }
    }
};

internals.import();


// Hawk version

exports.version = function () {

    return exports.loadPackage(__dirname + '/..').version;
};


// Extract host and port from request

exports.parseHost = function (req, hostHeaderName) {

    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
    var hostHeader = req.headers[hostHeaderName];
    if (!hostHeader) {
        return null;
    }

    var hostHeaderRegex;
    if (hostHeader[0] === '[') {
        hostHeaderRegex = /^(?:(?:\r\n)?\s)*(\[[^\]]+\])(?::(\d+))?(?:(?:\r\n)?\s)*$/;      // IPv6
    }
    else {
        hostHeaderRegex = /^(?:(?:\r\n)?\s)*([^:]+)(?::(\d+))?(?:(?:\r\n)?\s)*$/;           // IPv4, hostname
    }
    
    var hostParts = hostHeader.match(hostHeaderRegex);

    if (!hostParts ||
        hostParts.length !== 3 ||
        !hostParts[1]) {

        return null;
    }

    return {
        name: hostParts[1],
        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
    };
};


// Parse Content-Type header content

exports.parseContentType = function (header) {

    if (!header) {
        return '';
    }

    return header.split(';')[0].trim().toLowerCase();
};


// Convert node's  to request configuration object

exports.parseRequest = function (req, options) {

    if (!req.headers) {
        return req;
    }
    
    // Obtain host and port information

    if (!options.host || !options.port) {
        var host = exports.parseHost(req, options.hostHeaderName);
        if (!host) {
            return new Error('Invalid Host header');
        }
    }

    var request = {
        method: req.method,
        url: req.url,
        host: options.host || host.name,
        port: options.port || host.port,
        authorization: req.headers.authorization,
        contentType: req.headers['content-type'] || ''
    };

    return request;
};


exports.now = function () {

    return Sntp.now();
};


// Parse Hawk HTTP Authorization header

exports.parseAuthorizationHeader = function (header, keys) {

    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];

    if (!header) {
        return Boom.unauthorized(null, 'Hawk');
    }

    var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
    if (!headerParts) {
        return Boom.badRequest('Invalid header syntax');
    }

    var scheme = headerParts[1];
    if (scheme.toLowerCase() !== 'hawk') {
        return Boom.unauthorized(null, 'Hawk');
    }

    var attributesString = headerParts[2];
    if (!attributesString) {
        return Boom.badRequest('Invalid header syntax');
    }

    var attributes = {};
    var errorMessage = '';
    var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {

        // Check valid attribute names

        if (keys.indexOf($1) === -1) {
            errorMessage = 'Unknown attribute: ' + $1;
            return;
        }

        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9

        if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
            errorMessage = 'Bad attribute value: ' + $1;
            return;
        }

        // Check for duplicates

        if (attributes.hasOwnProperty($1)) {
            errorMessage = 'Duplicate attribute: ' + $1;
            return;
        }

        attributes[$1] = $2;
        return '';
    });

    if (verify !== '') {
        return Boom.badRequest(errorMessage || 'Bad header format');
    }

    return attributes;
};


exports.unauthorized = function (message) {

    return Boom.unauthorized(message, 'Hawk');
};


}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/utils.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/client.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/client.js"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/lib/client.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib';
// Load modules

var Url = require('__SYSTEM__/url');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Generate an Authorization header for a given request

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    method: HTTP verb (e.g. 'GET', 'POST')
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                                 // 'sha1', 'sha256'
        },

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        timestamp: Date.now(),                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
        app: '24s23423f34dx',                               // Oz application id
        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
    }
*/

exports.header = function (uri, method, options) {

    var result = {
        field: '',
        artifacts: {}
    };

    // Validate inputs

    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
        !method || typeof method !== 'string' ||
        !options || typeof options !== 'object') {

        return result;
    }

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000)

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return result;
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return result;
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        method: method,
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        hash: options.hash,
        ext: options.ext,
        app: options.app,
        dlg: options.dlg
    };

    result.artifacts = artifacts;

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('header', credentials, artifacts);

    // Construct header

    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
    var header = 'Hawk id="' + credentials.id +
                 '", ts="' + artifacts.ts +
                 '", nonce="' + artifacts.nonce +
                 (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                 (hasExt ? '", ext="' + Utils.escapeHeaderAttribute(artifacts.ext) : '') +
                 '", mac="' + mac + '"';

    if (artifacts.app) {
        header += ', app="' + artifacts.app +
                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
    }

    result.field = header;

    return result;
};


// Validate server response

/*
    res:        node's response object
    artifacts:  object recieved from header().artifacts
    options: {
        payload:    optional payload received
        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
    }
*/

exports.authenticate = function (res, credentials, artifacts, options) {

    artifacts = Hoek.clone(artifacts);
    options = options || {};

    if (res.headers['www-authenticate']) {

        // Parse HTTP WWW-Authenticate header

        var attributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
        if (attributes instanceof Error) {
            return false;
        }

        if (attributes.ts) {
            var tsm = Crypto.calculateTsMac(attributes.ts, credentials);
            if (tsm !== attributes.tsm) {
                return false;
            }
        }
    }

    // Parse HTTP Server-Authorization header

    if (!res.headers['server-authorization'] &&
        !options.required) {

        return true;
    }

    var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
    if (attributes instanceof Error) {
        return false;
    }

    artifacts.ext = attributes.ext;
    artifacts.hash = attributes.hash;

    var mac = Crypto.calculateMac('response', credentials, artifacts);
    if (mac !== attributes.mac) {
        return false;
    }

    if (!options.hasOwnProperty('payload')) {
        return true;
    }

    if (!attributes.hash) {
        return false;
    }

    var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
    return (calculatedHash === attributes.hash);
};


// Generate a bewit value for a given URI

/*
 * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
 * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'
 */
/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        },
        ttlSec: 60 * 60,                                    // TTL in seconds

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        localtimeOffsetMsec: 400                            // Time offset to sync with server time
    };
*/

exports.getBewit = function (uri, options) {

    // Validate inputs

    if (!uri ||
        (typeof uri !== 'string' && typeof uri !== 'object') ||
        !options ||
        typeof options !== 'object' ||
        !options.ttlSec) {

        return '';
    }

    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var exp = Math.floor(now / 1000) + options.ttlSec;
    var mac = Crypto.calculateMac('bewit', credentials, {
        ts: exp,
        nonce: '',
        method: 'GET',
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        ext: options.ext
    });

    // Construct bewit: id\exp\mac\ext

    var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
    return Utils.base64urlEncode(bewit);
};


// Generate an authorization string for a message

/*
    host: 'example.com',
    port: 8000,
    message: '{"some":"payload"}',                          // UTF-8 encoded string for body hash generation
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        },

        // Optional

        timestamp: Date.now(),                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
    }
*/

exports.message = function (host, port, message, options) {

    // Validate inputs

    if (!host || typeof host !== 'string' ||
        !port || typeof port !== 'number' ||
        message === null || message === undefined || typeof message !== 'string' ||
        !options || typeof options !== 'object') {

        return null;
    }

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000)

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return null;
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return null;
    }

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        host: host,
        port: port,
        hash: Crypto.calculatePayloadHash(message, credentials.algorithm)
    };

    // Construct authorization

    var result = {
        id: credentials.id,
        ts: artifacts.ts,
        nonce: artifacts.nonce,
        hash: artifacts.hash,
        mac: Crypto.calculateMac('message', credentials, artifacts)
    };

    return result;
};




}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/lib/client.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/aws-sign/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"fd19611375576f45cadda2116c3987363f8c18f2-aws-sign/index.js"}
require.memoize("fd19611375576f45cadda2116c3987363f8c18f2-aws-sign/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/aws-sign';

/*!
 * knox - auth
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var crypto = require('__SYSTEM__/crypto')
  , parse = require('__SYSTEM__/url').parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ]

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options) {
  return 'AWS ' + options.key + ':' + sign(options)
}

module.exports = authorization
module.exports.authorization = authorization

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options) {
  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

module.exports.hmacSha1 = hmacSha1

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign (options) {
  options.message = stringToSign(options)
  return hmacSha1(options)
}
module.exports.sign = sign

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options) {
  options.message = queryStringToSign(options)
  return hmacSha1(options)
}
module.exports.signQuery= signQuery

/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options) {
  var headers = options.amazonHeaders || ''
  if (headers) headers += '\n'
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date.toUTCString()
    , headers + options.resource
    ]
  return r.join('\n')
}
module.exports.queryStringToSign = stringToSign

/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options){
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers) {
  var buf = []
    , fields = Object.keys(headers)
    ;
  for (var i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase()
      ;
    if (0 !== field.indexOf('x-amz')) continue
    buf.push(field + ':' + val)
  }
  return buf.sort().join('\n')
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource) {
  var url = parse(resource, true)
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query).forEach(function(key){
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
    buf.push(key + val)
  })

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
module.exports.canonicalizeResource = canonicalizeResource

return {
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    require: (typeof require !== "undefined") ? require : null,
    parse: (typeof parse !== "undefined") ? parse : null,
    keys: (typeof keys !== "undefined") ? keys : null,
    authorization: (typeof authorization !== "undefined") ? authorization : null,
    sign: (typeof sign !== "undefined") ? sign : null,
    module: (typeof module !== "undefined") ? module : null,
    hmacSha1: (typeof hmacSha1 !== "undefined") ? hmacSha1 : null,
    stringToSign: (typeof stringToSign !== "undefined") ? stringToSign : null,
    signQuery: (typeof signQuery !== "undefined") ? signQuery : null,
    queryStringToSign: (typeof queryStringToSign !== "undefined") ? queryStringToSign : null,
    canonicalizeHeaders: (typeof canonicalizeHeaders !== "undefined") ? canonicalizeHeaders : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    canonicalizeResource: (typeof canonicalizeResource !== "undefined") ? canonicalizeResource : null,
    encodeURIComponent: (typeof encodeURIComponent !== "undefined") ? encodeURIComponent : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/aws-sign/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/index.js"}
require.memoize("7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib';
// Copyright 2011 Joyent, Inc.  All rights reserved.

var parser = require('./parser');
var signer = require('./signer');
var verify = require('./verify');
var util = require('./util');



///--- API

module.exports = {

  parse: parser.parseRequest,
  parseRequest: parser.parseRequest,

  sign: signer.signRequest,
  signRequest: signer.signRequest,

  sshKeyToPEM: util.sshKeyToPEM,
  sshKeyFingerprint: util.fingerprint,

  verify: verify.verifySignature,
  verifySignature: verify.verifySignature
};

return {
    parser: (typeof parser !== "undefined") ? parser : null,
    require: (typeof require !== "undefined") ? require : null,
    signer: (typeof signer !== "undefined") ? signer : null,
    verify: (typeof verify !== "undefined") ? verify : null,
    util: (typeof util !== "undefined") ? util : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/parser.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/parser.js"}
require.memoize("7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/parser.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib';
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var util = require('__SYSTEM__/util');



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var State = {
  New: 0,
  Params: 1
};

var ParamsState = {
  Name: 0,
  Quote: 1,
  Value: 2,
  Comma: 3
};



///--- Specific Errors

function HttpSignatureError(message, caller) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, caller || HttpSignatureError);

  this.message = message;
  this.name = caller.name;
}
util.inherits(HttpSignatureError, Error);

function ExpiredRequestError(message) {
  HttpSignatureError.call(this, message, ExpiredRequestError);
}
util.inherits(ExpiredRequestError, HttpSignatureError);


function InvalidHeaderError(message) {
  HttpSignatureError.call(this, message, InvalidHeaderError);
}
util.inherits(InvalidHeaderError, HttpSignatureError);


function InvalidParamsError(message) {
  HttpSignatureError.call(this, message, InvalidParamsError);
}
util.inherits(InvalidParamsError, HttpSignatureError);


function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);



///--- Exported API

module.exports = {

  /**
   * Parses the 'Authorization' header out of an http.ServerRequest object.
   *
   * Note that this API will fully validate the Authorization header, and throw
   * on any error.  It will not however check the signature, or the keyId format
   * as those are specific to your environment.  You can use the options object
   * to pass in extra constraints.
   *
   * As a response object you can expect this:
   *
   *     {
   *       "scheme": "Signature",
   *       "params": {
   *         "keyId": "foo",
   *         "algorithm": "rsa-sha256",
   *         "headers": [
   *           "date" or "x-date",
   *           "content-md5"
   *         ],
   *         "signature": "base64"
   *       },
   *       "signingString": "ready to be passed to crypto.verify()"
   *     }
   *
   * @param {Object} request an http.ServerRequest.
   * @param {Object} options an optional options object with:
   *                   - clockSkew: allowed clock skew in seconds (default 300).
   *                   - headers: required header names (def: date or x-date)
   *                   - algorithms: algorithms to support (default: all).
   * @return {Object} parsed out object (see above).
   * @throws {TypeError} on invalid input.
   * @throws {InvalidHeaderError} on an invalid Authorization header error.
   * @throws {InvalidParamsError} if the params in the scheme are invalid.
   * @throws {MissingHeaderError} if the params indicate a header not present,
   *                              either in the request headers from the params,
   *                              or not in the params from a required header
   *                              in options.
   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
   */
  parseRequest: function parseRequest(request, options) {
    assert.object(request, 'request');
    assert.object(request.headers, 'request.headers');
    if (options === undefined) {
      options = {};
    }
    if (options.headers === undefined) {
      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
    }
    assert.object(options, 'options');
    assert.arrayOfString(options.headers, 'options.headers');
    assert.optionalNumber(options.clockSkew, 'options.clockSkew');

    if (!request.headers.authorization)
      throw new MissingHeaderError('no authorization header present in ' +
                                   'the request');

    options.clockSkew = options.clockSkew || 300;


    var i = 0;
    var state = State.New;
    var substate = ParamsState.Name;
    var tmpName = '';
    var tmpValue = '';

    var parsed = {
      scheme: '',
      params: {},
      signingString: '',

      get algorithm() {
        return this.params.algorithm.toUpperCase();
      },

      get keyId() {
        return this.params.keyId;
      }

    };

    var authz = request.headers.authorization;
    for (i = 0; i < authz.length; i++) {
      var c = authz.charAt(i);

      switch (Number(state)) {

      case State.New:
        if (c !== ' ') parsed.scheme += c;
        else state = State.Params;
        break;

      case State.Params:
        switch (Number(substate)) {

        case ParamsState.Name:
          var code = c.charCodeAt(0);
          // restricted name of A-Z / a-z
          if ((code >= 0x41 && code <= 0x5a) || // A-Z
              (code >= 0x61 && code <= 0x7a)) { // a-z
            tmpName += c;
          } else if (c === '=') {
            if (tmpName.length === 0)
              throw new InvalidHeaderError('bad param format');
            substate = ParamsState.Quote;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Quote:
          if (c === '"') {
            tmpValue = '';
            substate = ParamsState.Value;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Value:
          if (c === '"') {
            parsed.params[tmpName] = tmpValue;
            substate = ParamsState.Comma;
          } else {
            tmpValue += c;
          }
          break;

        case ParamsState.Comma:
          if (c === ',') {
            tmpName = '';
            substate = ParamsState.Name;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        default:
          throw new Error('Invalid substate');
        }
        break;

      default:
        throw new Error('Invalid substate');
      }

    }

    if (!parsed.params.headers || parsed.params.headers === '') {
      if (request.headers['x-date']) {
        parsed.params.headers = ['x-date'];
      } else {
        parsed.params.headers = ['date'];
      }
    } else {
      parsed.params.headers = parsed.params.headers.split(' ');
    }

    // Minimally validate the parsed object
    if (!parsed.scheme || parsed.scheme !== 'Signature')
      throw new InvalidHeaderError('scheme was not "Signature"');

    if (!parsed.params.keyId)
      throw new InvalidHeaderError('keyId was not specified');

    if (!parsed.params.algorithm)
      throw new InvalidHeaderError('algorithm was not specified');

    if (!parsed.params.signature)
      throw new InvalidHeaderError('signature was not specified');

    // Check the algorithm against the official list
    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
    if (!Algorithms[parsed.params.algorithm])
      throw new InvalidParamsError(parsed.params.algorithm +
                                   ' is not supported');

    // Build the signingString
    for (i = 0; i < parsed.params.headers.length; i++) {
      var h = parsed.params.headers[i].toLowerCase();
      parsed.params.headers[i] = h;

      if (h !== 'request-line') {
        var value = request.headers[h];
        if (!value)
          throw new MissingHeaderError(h + ' was not in the request');
        parsed.signingString += h + ': ' + value;
      } else {
        parsed.signingString +=
          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
      }

      if ((i + 1) < parsed.params.headers.length)
        parsed.signingString += '\n';
    }

    // Check against the constraints
    var date;
    if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
      var now = new Date();
      var skew = Math.abs(now.getTime() - date.getTime());

      if (skew > options.clockSkew * 1000) {
        throw new ExpiredRequestError('clock skew of ' +
                                      (skew / 1000) +
                                      's was greater than ' +
                                      options.clockSkew + 's');
      }
    }

    options.headers.forEach(function (hdr) {
      // Remember that we already checked any headers in the params
      // were in the request, so if this passes we're good.
      if (parsed.params.headers.indexOf(hdr) < 0)
        throw new MissingHeaderError(hdr + ' was not a signed header');
    });

    if (options.algorithms) {
      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
        throw new InvalidParamsError(parsed.params.algorithm +
                                     ' is not a supported algorithm');
    }

    return parsed;
  }

};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    util: (typeof util !== "undefined") ? util : null,
    Algorithms: (typeof Algorithms !== "undefined") ? Algorithms : null,
    State: (typeof State !== "undefined") ? State : null,
    ParamsState: (typeof ParamsState !== "undefined") ? ParamsState : null,
    HttpSignatureError: (typeof HttpSignatureError !== "undefined") ? HttpSignatureError : null,
    Error: (typeof Error !== "undefined") ? Error : null,
    ExpiredRequestError: (typeof ExpiredRequestError !== "undefined") ? ExpiredRequestError : null,
    InvalidHeaderError: (typeof InvalidHeaderError !== "undefined") ? InvalidHeaderError : null,
    InvalidParamsError: (typeof InvalidParamsError !== "undefined") ? InvalidParamsError : null,
    MissingHeaderError: (typeof MissingHeaderError !== "undefined") ? MissingHeaderError : null,
    module: (typeof module !== "undefined") ? module : null,
    Number: (typeof Number !== "undefined") ? Number : null,
    Math: (typeof Math !== "undefined") ? Math : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/parser.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/assert-plus/assert.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"8f17ce5faccfa48645e3b9e946567a604b0f9f82-assert-plus/assert.js"}
require.memoize("8f17ce5faccfa48645e3b9e946567a604b0f9f82-assert-plus/assert.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/assert-plus';
// Copyright (c) 2012, Mark Cavage. All rights reserved.

var assert = require('__SYSTEM__/assert');
var Stream = require('__SYSTEM__/stream').Stream;
var util = require('__SYSTEM__/util');



///--- Globals

var NDEBUG = process.env.NODE_NDEBUG || false;



///--- Messages

var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
var TYPE_REQUIRED = '%s (%s) is required';



///--- Internal

function capitalize(str) {
        return (str.charAt(0).toUpperCase() + str.slice(1));
}

function uncapitalize(str) {
        return (str.charAt(0).toLowerCase() + str.slice(1));
}

function _() {
        return (util.format.apply(util, arguments));
}


function _assert(arg, type, name, stackFunc) {
        if (!NDEBUG) {
                name = name || type;
                stackFunc = stackFunc || _assert.caller;
                var t = typeof (arg);

                if (t !== type) {
                        throw new assert.AssertionError({
                                message: _(TYPE_REQUIRED, name, type),
                                actual: t,
                                expected: type,
                                operator: '===',
                                stackStartFunction: stackFunc
                        });
                }
        }
}



///--- API

function array(arr, type, name) {
        if (!NDEBUG) {
                name = name || type;

                if (!Array.isArray(arr)) {
                        throw new assert.AssertionError({
                                message: _(ARRAY_TYPE_REQUIRED, name, type),
                                actual: typeof (arr),
                                expected: 'array',
                                operator: 'Array.isArray',
                                stackStartFunction: array.caller
                        });
                }

                for (var i = 0; i < arr.length; i++) {
                        _assert(arr[i], type, name, array);
                }
        }
}


function bool(arg, name) {
        _assert(arg, 'boolean', name, bool);
}


function buffer(arg, name) {
        if (!Buffer.isBuffer(arg)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'buffer',
                        operator: 'Buffer.isBuffer',
                        stackStartFunction: buffer
                });
        }
}


function func(arg, name) {
        _assert(arg, 'function', name);
}


function number(arg, name) {
        _assert(arg, 'number', name);
}


function object(arg, name) {
        _assert(arg, 'object', name);
}


function stream(arg, name) {
        if (!(arg instanceof Stream)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'Stream',
                        operator: 'instanceof',
                        stackStartFunction: buffer
                });
        }
}


function string(arg, name) {
        _assert(arg, 'string', name);
}



///--- Exports

module.exports = {
        bool: bool,
        buffer: buffer,
        func: func,
        number: number,
        object: object,
        stream: stream,
        string: string
};


Object.keys(module.exports).forEach(function (k) {
        if (k === 'buffer')
                return;

        var name = 'arrayOf' + capitalize(k);

        if (k === 'bool')
                k = 'boolean';
        if (k === 'func')
                k = 'function';
        module.exports[name] = function (arg, name) {
                array(arg, k, name);
        };
});

Object.keys(module.exports).forEach(function (k) {
        var _name = 'optional' + capitalize(k);
        var s = uncapitalize(k.replace('arrayOf', ''));
        if (s === 'bool')
                s = 'boolean';
        if (s === 'func')
                s = 'function';

        if (k.indexOf('arrayOf') !== -1) {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          array(arg, s, name);
                  }
          };
        } else {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          _assert(arg, s, name);
                  }
          };
        }
});


// Reexport built-in assertions
Object.keys(assert).forEach(function (k) {
        if (k === 'AssertionError') {
                module.exports[k] = assert[k];
                return;
        }

        module.exports[k] = function () {
                if (!NDEBUG) {
                        assert[k].apply(assert[k], arguments);
                }
        };
});

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    Stream: (typeof Stream !== "undefined") ? Stream : null,
    util: (typeof util !== "undefined") ? util : null,
    NDEBUG: (typeof NDEBUG !== "undefined") ? NDEBUG : null,
    process: (typeof process !== "undefined") ? process : null,
    ARRAY_TYPE_REQUIRED: (typeof ARRAY_TYPE_REQUIRED !== "undefined") ? ARRAY_TYPE_REQUIRED : null,
    TYPE_REQUIRED: (typeof TYPE_REQUIRED !== "undefined") ? TYPE_REQUIRED : null,
    capitalize: (typeof capitalize !== "undefined") ? capitalize : null,
    uncapitalize: (typeof uncapitalize !== "undefined") ? uncapitalize : null,
    _: (typeof _ !== "undefined") ? _ : null,
    _assert: (typeof _assert !== "undefined") ? _assert : null,
    array: (typeof array !== "undefined") ? array : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    bool: (typeof bool !== "undefined") ? bool : null,
    buffer: (typeof buffer !== "undefined") ? buffer : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    func: (typeof func !== "undefined") ? func : null,
    number: (typeof number !== "undefined") ? number : null,
    object: (typeof object !== "undefined") ? object : null,
    stream: (typeof stream !== "undefined") ? stream : null,
    string: (typeof string !== "undefined") ? string : null,
    module: (typeof module !== "undefined") ? module : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/assert-plus/assert.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/signer.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/signer.js"}
require.memoize("7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/signer.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib';
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('__SYSTEM__/crypto');
var http = require('__SYSTEM__/http');

var sprintf = require('__SYSTEM__/util').format;



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var Authorization =
  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';



///--- Specific Errors

function MissingHeaderError(message) {
    this.name = 'MissingHeaderError';
    this.message = message;
    this.stack = (new Error()).stack;
}
MissingHeaderError.prototype = new Error();


function InvalidAlgorithmError(message) {
    this.name = 'InvalidAlgorithmError';
    this.message = message;
    this.stack = (new Error()).stack;
}
InvalidAlgorithmError.prototype = new Error();



///--- Internal Functions

function _pad(val) {
  if (parseInt(val, 10) < 10) {
    val = '0' + val;
  }
  return val;
}


function _rfc1123() {
  var date = new Date();

  var months = ['Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'];
  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  return days[date.getUTCDay()] + ', ' +
    _pad(date.getUTCDate()) + ' ' +
    months[date.getUTCMonth()] + ' ' +
    date.getUTCFullYear() + ' ' +
    _pad(date.getUTCHours()) + ':' +
    _pad(date.getUTCMinutes()) + ':' +
    _pad(date.getUTCSeconds()) +
    ' GMT';
}



///--- Exported API

module.exports = {

  /**
   * Adds an 'Authorization' header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it's not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn't need to check the return type; it's just there if you want
   * to be pedantic.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to ['date'].
   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
   *                   - {String} httpVersion optional; defaults to '1.1'.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert.object(request, 'request');
    assert.object(options, 'options');
    assert.optionalString(options.algorithm, 'options.algorithm');
    assert.string(options.keyId, 'options.keyId');
    assert.optionalArrayOfString(options.headers, 'options.headers');
    assert.optionalString(options.httpVersion, 'options.httpVersion');

    if (!request.getHeader('Date'))
      request.setHeader('Date', _rfc1123());
    if (!options.headers)
      options.headers = ['date'];
    if (!options.algorithm)
      options.algorithm = 'rsa-sha256';
    if (!options.httpVersion)
      options.httpVersion = '1.1';

    options.algorithm = options.algorithm.toLowerCase();

    if (!Algorithms[options.algorithm])
      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');

    var i;
    var stringToSign = '';
    for (i = 0; i < options.headers.length; i++) {
      if (typeof (options.headers[i]) !== 'string')
        throw new TypeError('options.headers must be an array of Strings');

      var h = options.headers[i].toLowerCase();

      if (h !== 'request-line') {
        var value = request.getHeader(h);
        if (!value) {
          throw new MissingHeaderError(h + ' was not in the request');
        }
        stringToSign += h + ': ' + value;
      } else {
        value =
        stringToSign +=
          request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
      }

      if ((i + 1) < options.headers.length)
        stringToSign += '\n';
    }

    var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
    var signature;
    if (alg[1] === 'hmac') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest('base64');
    } else {
      var signer = crypto.createSign(options.algorithm.toUpperCase());
      signer.update(stringToSign);
      signature = signer.sign(options.key, 'base64');
    }

    request.setHeader('Authorization', sprintf(Authorization,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(' '),
                                               signature));

    return true;
  }

};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    http: (typeof http !== "undefined") ? http : null,
    sprintf: (typeof sprintf !== "undefined") ? sprintf : null,
    Algorithms: (typeof Algorithms !== "undefined") ? Algorithms : null,
    Authorization: (typeof Authorization !== "undefined") ? Authorization : null,
    MissingHeaderError: (typeof MissingHeaderError !== "undefined") ? MissingHeaderError : null,
    InvalidAlgorithmError: (typeof InvalidAlgorithmError !== "undefined") ? InvalidAlgorithmError : null,
    _pad: (typeof _pad !== "undefined") ? _pad : null,
    parseInt: (typeof parseInt !== "undefined") ? parseInt : null,
    _rfc1123: (typeof _rfc1123 !== "undefined") ? _rfc1123 : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/signer.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/verify.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/verify.js"}
require.memoize("7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/verify.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib';
// Copyright 2011 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('__SYSTEM__/crypto');



///--- Exported API

module.exports = {

  /**
   * Simply wraps up the node crypto operations for you, and returns
   * true or false.  You are expected to pass in an object that was
   * returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} key either an RSA private key PEM or HMAC secret.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   */
  verifySignature: function verifySignature(parsedSignature, key) {
    assert.object(parsedSignature, 'parsedSignature');
    assert.string(key, 'key');

    var alg = parsedSignature.algorithm.match(/(HMAC|RSA|DSA)-(\w+)/);
    if (!alg || alg.length !== 3)
      throw new TypeError('parsedSignature: unsupported algorithm ' +
                          parsedSignature.algorithm);

    if (alg[1] === 'HMAC') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), key);
      hmac.update(parsedSignature.signingString);
      return (hmac.digest('base64') === parsedSignature.params.signature);
    } else {
      var verify = crypto.createVerify(alg[0]);
      verify.update(parsedSignature.signingString);
      return verify.verify(key, parsedSignature.params.signature, 'base64');
    }
  }

};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/verify.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/util.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/util.js"}
require.memoize("7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/util.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib';
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('__SYSTEM__/crypto');

var asn1 = require('asn1');
var ctype = require('ctype');



///--- Helpers

function readNext(buffer, offset) {
  var len = ctype.ruint32(buffer, 'big', offset);
  offset += 4;

  var newOffset = offset + len;

  return {
    data: buffer.slice(offset, newOffset),
    offset: newOffset
  };
}


function writeInt(writer, buffer) {
  writer.writeByte(0x02); // ASN1.Integer
  writer.writeLength(buffer.length);

  for (var i = 0; i < buffer.length; i++)
    writer.writeByte(buffer[i]);

  return writer;
}


function rsaToPEM(key) {
  var buffer;
  var der;
  var exponent;
  var i;
  var modulus;
  var newKey = '';
  var offset = 0;
  var type;
  var tmp;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    if (type !== 'ssh-rsa')
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    exponent = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    modulus = tmp.data;
  } catch (e) {
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.113549.1.1.1');
  der.writeNull();
  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);

  // Actual key
  der.startSequence();
  writeInt(der, modulus);
  writeInt(der, exponent);
  der.endSequence();

  // bit string
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


function dsaToPEM(key) {
  var buffer;
  var offset = 0;
  var tmp;
  var der;
  var newKey = '';

  var type;
  var p;
  var q;
  var g;
  var y;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    /* JSSTYLED */
    if (!/^ssh-ds[as].*/.test(type))
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    p = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    q = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    g = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    y = tmp.data;
  } catch (e) {
    console.log(e.stack);
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.10040.4.1');

  der.startSequence();
  writeInt(der, p);
  writeInt(der, q);
  writeInt(der, g);
  der.endSequence();

  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);
  writeInt(der, y);
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (var i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


///--- API

module.exports = {

  /**
   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key) {
    assert.string(key, 'ssh_key');

    /* JSSTYLED */
    if (/^ssh-rsa.*/.test(key))
      return rsaToPEM(key);

    /* JSSTYLED */
    if (/^ssh-ds[as].*/.test(key))
      return dsaToPEM(key);

    throw new Error('Only RSA and DSA public keys are allowed');
  },


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key) {
    assert.string(key, 'ssh_key');

    var pieces = key.split(' ');
    if (!pieces || !pieces.length || pieces.length < 2)
      throw new Error('invalid ssh key');

    var data = new Buffer(pieces[1], 'base64');

    var hash = crypto.createHash('md5');
    hash.update(data);
    var digest = hash.digest('hex');

    var fp = '';
    for (var i = 0; i < digest.length; i++) {
      if (i && i % 2 === 0)
        fp += ':';

      fp += digest[i];
    }

    return fp;
  }


};

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    crypto: (typeof crypto !== "undefined") ? crypto : null,
    asn1: (typeof asn1 !== "undefined") ? asn1 : null,
    ctype: (typeof ctype !== "undefined") ? ctype : null,
    readNext: (typeof readNext !== "undefined") ? readNext : null,
    writeInt: (typeof writeInt !== "undefined") ? writeInt : null,
    rsaToPEM: (typeof rsaToPEM !== "undefined") ? rsaToPEM : null,
    dsaToPEM: (typeof dsaToPEM !== "undefined") ? dsaToPEM : null,
    console: (typeof console !== "undefined") ? console : null,
    i: (typeof i !== "undefined") ? i : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/lib/util.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/index.js"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

var Ber = require('./ber/index');



///--- Exported API

module.exports = {

  Ber: Ber,

  BerReader: Ber.Reader,

  BerWriter: Ber.Writer

};

return {
    Ber: (typeof Ber !== "undefined") ? Ber : null,
    require: (typeof require !== "undefined") ? require : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/index.js"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var errors = require('./errors');
var types = require('./types');

var Reader = require('./reader');
var Writer = require('./writer');


///--- Exports

module.exports = {

  Reader: Reader,

  Writer: Writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}

return {
    errors: (typeof errors !== "undefined") ? errors : null,
    require: (typeof require !== "undefined") ? require : null,
    types: (typeof types !== "undefined") ? types : null,
    Reader: (typeof Reader !== "undefined") ? Reader : null,
    Writer: (typeof Writer !== "undefined") ? Writer : null,
    module: (typeof module !== "undefined") ? module : null,
    t: (typeof t !== "undefined") ? t : null,
    e: (typeof e !== "undefined") ? e : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/errors.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/errors.js"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/errors.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {

  newInvalidAsn1Error: function(msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};

return {
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/errors.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/types.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/types.js"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/types.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};

return {
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/types.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/reader.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/reader.js"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/reader.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('__SYSTEM__/assert');

var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



///--- API

function Reader(data) {
  if (!data || !Buffer.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;

  var self = this;
  this.__defineGetter__('length', function() { return self._len; });
  this.__defineGetter__('offset', function() { return self._offset; });
  this.__defineGetter__('remain', function() {
    return self._size - self._offset;
  });
  this.__defineGetter__('buffer', function() {
    return self._buf.slice(self._offset);
  });
}


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function(peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function() {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function(offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) == 0x80) {
    lenB &= 0x7f;

    if (lenB == 0)
      throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function(tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function() {
  return this._readTag(ASN1.Integer);
};


Reader.prototype.readBoolean = function() {
  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function() {
  return this._readTag(ASN1.Enumeration);
};


Reader.prototype.readString = function(tag, retbuf) {
  if (!tag)
    tag = ASN1.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function(tag) {
  if (!tag)
    tag = ASN1.OID;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  var values = [];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    var byte = this._buf[this._offset++] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) == 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function(tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset++];
  var value = 0;

  value = fb & 0x7F;
  for (var i = 1; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) == 0x80)
    value = -value;

  return value;
};



///--- Exported API

module.exports = Reader;

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    ASN1: (typeof ASN1 !== "undefined") ? ASN1 : null,
    errors: (typeof errors !== "undefined") ? errors : null,
    newInvalidAsn1Error: (typeof newInvalidAsn1Error !== "undefined") ? newInvalidAsn1Error : null,
    Reader: (typeof Reader !== "undefined") ? Reader : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/reader.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/writer.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/writer.js"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/ber/writer.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber';
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('__SYSTEM__/assert');
var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


///--- Helpers

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof(from), 'object');
  assert.ok(to);
  assert.equal(typeof(to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function(key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



///--- API

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = new Buffer(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];

  var self = this;
  this.__defineGetter__('buffer', function() {
    if (self._seq.length)
      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');

    return self._buf.slice(0, self._offset);
  });
}


Writer.prototype.writeByte = function(b) {
  if (typeof(b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&
         (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function() {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function(b, tag) {
  if (typeof(b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof(tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
  if (typeof(tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function(buf, tag) {
  if (typeof(tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function(strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function(s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof(tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function(len) {
  if (typeof(len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function(tag) {
  if (typeof(tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function() {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw new InvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function(start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function(len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = new Buffer(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



///--- Exported API

module.exports = Writer;

return {
    assert: (typeof assert !== "undefined") ? assert : null,
    require: (typeof require !== "undefined") ? require : null,
    ASN1: (typeof ASN1 !== "undefined") ? ASN1 : null,
    errors: (typeof errors !== "undefined") ? errors : null,
    newInvalidAsn1Error: (typeof newInvalidAsn1Error !== "undefined") ? newInvalidAsn1Error : null,
    DEFAULT_OPTS: (typeof DEFAULT_OPTS !== "undefined") ? DEFAULT_OPTS : null,
    merge: (typeof merge !== "undefined") ? merge : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    Writer: (typeof Writer !== "undefined") ? Writer : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    parseInt: (typeof parseInt !== "undefined") ? parseInt : null,
    start: (typeof start !== "undefined") ? start : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/lib/ber/writer.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/ctype.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctype.js"}
require.memoize("13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctype.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype';
/*
 * rm - Feb 2011
 * ctype.js
 *
 * This module provides a simple abstraction towards reading and writing
 * different types of binary data. It is designed to use ctio.js and provide a
 * richer and more expressive API on top of it.
 *
 * By default we support the following as built in basic types:
 *	int8_t
 *	int16_t
 *	int32_t
 *	uint8_t
 *	uint16_t
 *	uint32_t
 *	uint64_t
 *	float
 *	double
 *	char
 *	char[]
 *
 * Each type is returned as a Number, with the exception of char and char[]
 * which are returned as Node Buffers. A char is considered a uint8_t.
 *
 * Requests to read and write data are specified as an array of JSON objects.
 * This is also the same way that one declares structs. Even if just a single
 * value is requested, it must be done as a struct. The array order determines
 * the order that we try and read values. Each entry has the following format
 * with values marked with a * being optional.
 *
 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
 *
 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
 * value. Value is defined when we're writing out data, otherwise it's ignored.
 *
 */

var mod_ctf = require('./ctf.js');
var mod_ctio = require('./ctio.js');
var mod_assert = require('__SYSTEM__/assert');

/*
 * This is the set of basic types that we support.
 *
 *	read		The function to call to read in a value from a buffer
 *
 *	write		The function to call to write a value to a buffer
 *
 */
var deftypes = {
    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
    'float': { read: ctReadFloat, write: ctWriteFloat },
    'double': { read: ctReadDouble, write: ctWriteDouble },
    'char': { read: ctReadChar, write: ctWriteChar },
    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
};

/*
 * The following are wrappers around the CType IO low level API. They encode
 * knowledge about the size and return something in the expected format.
 */
function ctReadUint8(endian, buffer, offset)
{
	var val = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadUint16(endian, buffer, offset)
{
	var val = mod_ctio.ruint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadUint32(endian, buffer, offset)
{
	var val = mod_ctio.ruint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadUint64(endian, buffer, offset)
{
	var val = mod_ctio.ruint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadSint8(endian, buffer, offset)
{
	var val = mod_ctio.rsint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadSint16(endian, buffer, offset)
{
	var val = mod_ctio.rsint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadSint32(endian, buffer, offset)
{
	var val = mod_ctio.rsint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadSint64(endian, buffer, offset)
{
	var val = mod_ctio.rsint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadFloat(endian, buffer, offset)
{
	var val = mod_ctio.rfloat(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadDouble(endian, buffer, offset)
{
	var val = mod_ctio.rdouble(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

/*
 * Reads a single character into a node buffer
 */
function ctReadChar(endian, buffer, offset)
{
	var res = new Buffer(1);
	res[0] = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: res, size: 1 });
}

function ctReadCharArray(length, endian, buffer, offset)
{
	var ii;
	var res = new Buffer(length);

	for (ii = 0; ii < length; ii++)
		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

	return ({ value: res, size: length });
}

function ctWriteUint8(value, endian, buffer, offset)
{
	mod_ctio.wuint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteUint16(value, endian, buffer, offset)
{
	mod_ctio.wuint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteUint32(value, endian, buffer, offset)
{
	mod_ctio.wuint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteUint64(value, endian, buffer, offset)
{
	mod_ctio.wuint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteSint8(value, endian, buffer, offset)
{
	mod_ctio.wsint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteSint16(value, endian, buffer, offset)
{
	mod_ctio.wsint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteSint32(value, endian, buffer, offset)
{
	mod_ctio.wsint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteSint64(value, endian, buffer, offset)
{
	mod_ctio.wsint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteFloat(value, endian, buffer, offset)
{
	mod_ctio.wfloat(value, endian, buffer, offset);
	return (4);
}

function ctWriteDouble(value, endian, buffer, offset)
{
	mod_ctio.wdouble(value, endian, buffer, offset);
	return (8);
}

/*
 * Writes a single character into a node buffer
 */
function ctWriteChar(value, endian, buffer, offset)
{
	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	mod_ctio.ruint8(value[0], endian, buffer, offset);
	return (1);
}

/*
 * We're going to write 0s into the buffer if the string is shorter than the
 * length of the array.
 */
function ctWriteCharArray(value, length, endian, buffer, offset)
{
	var ii;

	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	if (value.length > length)
		throw (new Error('value length greater than array length'));

	for (ii = 0; ii < value.length && ii < length; ii++)
		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

	for (; ii < length; ii++)
		mod_ctio.wuint8(0, endian, offset + ii);


	return (length);
}

/*
 * Each parser has their own set of types. We want to make sure that they each
 * get their own copy as they may need to modify it.
 */
function ctGetBasicTypes()
{
	var ret = {};
	var key;
	for (key in deftypes)
		ret[key] = deftypes[key];

	return (ret);
}

/*
 * Given a string in the form of type[length] we want to split this into an
 * object that extracts that information. We want to note that we could possibly
 * have nested arrays so this should only check the furthest one. It may also be
 * the case that we have no [] pieces, in which case we just return the current
 * type.
 */
function ctParseType(str)
{
	var begInd, endInd;
	var type, len;
	if (typeof (str) != 'string')
		throw (new Error('type must be a Javascript string'));

	endInd = str.lastIndexOf(']');
	if (endInd == -1) {
		if (str.lastIndexOf('[') != -1)
			throw (new Error('found invalid type with \'[\' but ' +
			    'no corresponding \']\''));

		return ({ type: str });
	}

	begInd = str.lastIndexOf('[');
	if (begInd == -1)
		throw (new Error('found invalid type with \']\' but ' +
		    'no corresponding \'[\''));

	if (begInd >= endInd)
		throw (new Error('malformed type, \']\' appears before \'[\''));

	type = str.substring(0, begInd);
	len = str.substring(begInd + 1, endInd);

	return ({ type: type, len: len });
}

/*
 * Given a request validate that all of the fields for it are valid and make
 * sense. This includes verifying the following notions:
 *  - Each type requested is present in types
 *  - Only allow a name for a field to be specified once
 *  - If an array is specified, validate that the requested field exists and
 *    comes before it.
 *  - If fields is defined, check that each entry has the occurrence of field
 */
function ctCheckReq(def, types, fields)
{
	var ii, jj;
	var req, keys, key;
	var found = {};

	if (!(def instanceof Array))
		throw (new Error('definition is not an array'));

	if (def.length === 0)
		throw (new Error('definition must have at least one element'));

	for (ii = 0; ii < def.length; ii++) {
		req = def[ii];
		if (!(req instanceof Object))
			throw (new Error('definition must be an array of' +
			    'objects'));

		keys = Object.keys(req);
		if (keys.length != 1)
			throw (new Error('definition entry must only have ' +
			    'one key'));

		if (keys[0] in found)
			throw (new Error('Specified name already ' +
			    'specified: ' + keys[0]));

		if (!('type' in req[keys[0]]))
			throw (new Error('missing required type definition'));

		key = ctParseType(req[keys[0]]['type']);

		/*
		 * We may have nested arrays, we need to check the validity of
		 * the types until the len field is undefined in key. However,
		 * each time len is defined we need to verify it is either an
		 * integer or corresponds to an already seen key.
		 */
		while (key['len'] !== undefined) {
			if (isNaN(parseInt(key['len'], 10))) {
				if (!(key['len'] in found))
					throw (new Error('Given an array ' +
					    'length without a matching type'));

			}

			key = ctParseType(key['type']);
		}

		/* Now we can validate if the type is valid */
		if (!(key['type'] in types))
			throw (new Error('type not found or typdefed: ' +
			    key['type']));

		/* Check for any required fields */
		if (fields !== undefined) {
			for (jj = 0; jj < fields.length; jj++) {
				if (!(fields[jj] in req[keys[0]]))
					throw (new Error('Missing required ' +
					    'field: ' + fields[jj]));
			}
		}

		found[keys[0]] = true;
	}
}


/*
 * Create a new instance of the parser. Each parser has its own store of
 * typedefs and endianness. Conf is an object with the following required
 * values:
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 * And the following optional values:
 *
 * 	char-type	Valid options here are uint8 and int8. If uint8 is
 * 			specified this changes the default behavior of a single
 * 			char from being a buffer of a single character to being
 * 			a uint8_t. If int8, it becomes an int8_t instead.
 */
function CTypeParser(conf)
{
	if (!conf) throw (new Error('missing required argument'));

	if (!('endian' in conf))
		throw (new Error('missing required endian value'));

	if (conf['endian'] != 'big' && conf['endian'] != 'little')
		throw (new Error('Invalid endian type'));

	if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
	    conf['char-type'] != 'int8'))
		throw (new Error('invalid option for char-type: ' +
		    conf['char-type']));

	this.endian = conf['endian'];
	this.types = ctGetBasicTypes();

	/*
	 * There may be a more graceful way to do this, but this will have to
	 * serve.
	 */
	if ('char-type' in conf && conf['char-type'] == 'uint8')
		this.types['char'] = this.types['uint8_t'];

	if ('char-type' in conf && conf['char-type'] == 'int8')
		this.types['char'] = this.types['int8_t'];
}

/*
 * Sets the current endian value for the Parser. If the value is not valid,
 * throws an Error.
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 */
CTypeParser.prototype.setEndian = function (endian)
{
	if (endian != 'big' && endian != 'little')
		throw (new Error('invalid endian type, must be big or ' +
		    'little'));

	this.endian = endian;
};

/*
 * Returns the current value of the endian value for the parser.
 */
CTypeParser.prototype.getEndian = function ()
{
	return (this.endian);
};

/*
 * A user has requested to add a type, let us honor their request. Yet, if their
 * request doth spurn us, send them unto the Hells which Dante describes.
 *
 * 	name		The string for the type definition we're adding
 *
 *	value		Either a string that is a type/array name or an object
 *			that describes a struct.
 */
CTypeParser.prototype.typedef = function (name, value)
{
	var type;

	if (name === undefined)
		throw (new (Error('missing required typedef argument: name')));

	if (value === undefined)
		throw (new (Error('missing required typedef argument: value')));

	if (typeof (name) != 'string')
		throw (new (Error('the name of a type must be a string')));

	type = ctParseType(name);

	if (type['len'] !== undefined)
		throw (new Error('Cannot have an array in the typedef name'));

	if (name in this.types)
		throw (new Error('typedef name already present: ' + name));

	if (typeof (value) != 'string' && !(value instanceof Array))
		throw (new Error('typedef value must either be a string or ' +
		    'struct'));

	if (typeof (value) == 'string') {
		type = ctParseType(value);
		if (type['len'] !== undefined) {
			if (isNaN(parseInt(type['len'], 10)))
				throw (new (Error('typedef value must use ' +
				    'fixed size array when outside of a ' +
				    'struct')));
		}

		this.types[name] = value;
	} else {
		/* We have a struct, validate it */
		ctCheckReq(value, this.types);
		this.types[name] = value;
	}
};

/*
 * Include all of the typedefs, but none of the built in types. This should be
 * treated as read-only.
 */
CTypeParser.prototype.lstypes = function ()
{
	var key;
	var ret = {};

	for (key in this.types) {
		if (key in deftypes)
			continue;
		ret[key] = this.types[key];
	}

	return (ret);
};

/*
 * Given a type string that may have array types that aren't numbers, try and
 * fill them in from the values object. The object should be of the format where
 * indexing into it should return a number for that type.
 *
 *	str		The type string
 *
 *	values		An object that can be used to fulfill type information
 */
function ctResolveArray(str, values)
{
	var ret = '';
	var type = ctParseType(str);

	while (type['len'] !== undefined) {
		if (isNaN(parseInt(type['len'], 10))) {
			if (typeof (values[type['len']]) != 'number')
				throw (new Error('cannot sawp in non-number ' +
				    'for array value'));
			ret = '[' + values[type['len']] + ']' + ret;
		} else {
			ret = '[' + type['len'] + ']' + ret;
		}
		type = ctParseType(type['type']);
	}

	ret = type['type'] + ret;

	return (ret);
}

/*
 * [private] Either the typedef resolves to another type string or to a struct.
 * If it resolves to a struct, we just pass it off to read struct. If not, we
 * can just pass it off to read entry.
 */
CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
    offset, value)
{
	var pt;

	mod_assert.ok(type in this.types);
	if (typeof (this.types[type]) == 'string') {
		pt = ctParseType(this.types[type]);
		if (dispatch == 'read')
			return (this.readEntry(pt, buffer, offset));
		else if (dispatch == 'write')
			return (this.writeEntry(value, pt, buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	} else {
		if (dispatch == 'read')
			return (this.readStruct(this.types[type], buffer,
			    offset));
		else if (dispatch == 'write')
			return (this.writeStruct(value, this.types[type],
			    buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	}

};

/*
 * [private] Try and read in the specific entry.
 */
CTypeParser.prototype.readEntry = function (type, buffer, offset)
{
	var parse, len;

	/*
	 * Because we want to special case char[]s this is unfortunately
	 * a bit uglier than it really should be. We want to special
	 * case char[]s so that we return a node buffer, thus they are a
	 * first class type where as all other arrays just call into a
	 * generic array routine which calls their data-specific routine
	 * the specified number of times.
	 *
	 * The valid dispatch options we have are:
	 *  - Array and char => char[] handler
	 *  - Generic array handler
	 *  - Generic typedef handler
	 *  - Basic type handler
	 */
	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			parse = this.types['char[]']['read'](len,
			    this.endian, buffer, offset);
		else
			parse = this.readArray(type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			parse = this.types[type['type']]['read'](this.endian,
			    buffer, offset);
		else
			parse = this.resolveTypedef(type['type'], 'read',
			    buffer, offset);
	}

	return (parse);
};

/*
 * [private] Read an array of data
 */
CTypeParser.prototype.readArray = function (type, length, buffer, offset)
{
	var ii, ent, pt;
	var baseOffset = offset;
	var ret = new Array(length);
	pt = ctParseType(type);

	for (ii = 0; ii < length; ii++) {
		ent = this.readEntry(pt, buffer, offset);
		offset += ent['size'];
		ret[ii] = ent['value'];
	}

	return ({ value: ret, size: offset - baseOffset });
};

/*
 * [private] Read a single struct in.
 */
CTypeParser.prototype.readStruct = function (def, buffer, offset)
{
	var parse, ii, type, entry, key;
	var baseOffset = offset;
	var ret = {};

	/* Walk it and handle doing what's necessary */
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		/* Resolve all array values */
		type = ctParseType(ctResolveArray(entry['type'], ret));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		parse = this.readEntry(type, buffer, offset);

		offset += parse['size'];
		ret[key] = parse['value'];
	}

	return ({ value: ret, size: (offset-baseOffset)});
};

/*
 * This is what we were born to do. We read the data from a buffer and return it
 * in an object whose keys match the values from the object.
 *
 *	def		The array definition of the data to read in
 *
 *	buffer		The buffer to read data from
 *
 *	offset		The offset to start writing to
 *
 * Returns an object where each key corresponds to an entry in def and the value
 * is the read value.
 */
CTypeParser.prototype.readData = function (def, buffer, offset)
{
	/* Sanity check for arguments */
	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	/* Sanity check the object definition */
	ctCheckReq(def, this.types);

	return (this.readStruct(def, buffer, offset)['value']);
};

/*
 * [private] Write out an array of data
 */
CTypeParser.prototype.writeArray = function (value, type, length, buffer,
    offset)
{
	var ii, pt;
	var baseOffset = offset;
	if (!(value instanceof Array))
		throw (new Error('asked to write an array, but value is not ' +
		    'an array'));

	if (value.length != length)
		throw (new Error('asked to write array of length ' + length +
		    ' but that does not match value length: ' + value.length));

	pt = ctParseType(type);
	for (ii = 0; ii < length; ii++)
		offset += this.writeEntry(value[ii], pt, buffer, offset);

	return (offset - baseOffset);
};

/*
 * [private] Write the specific entry
 */
CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
{
	var len, ret;

	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			ret = this.types['char[]']['write'](value, len,
			    this.endian, buffer, offset);
		else
			ret = this.writeArray(value, type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			ret = this.types[type['type']]['write'](value,
			    this.endian, buffer, offset);
		else
			ret = this.resolveTypedef(type['type'], 'write',
			    buffer, offset, value);
	}

	return (ret);
};

/*
 * [private] Write a single struct out.
 */
CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
{
	var ii, entry, type, key;
	var baseOffset = offset;
	var vals = {};

	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		type = ctParseType(ctResolveArray(entry['type'], vals));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		offset += this.writeEntry(value[ii], type, buffer, offset);
		/* Now that we've written it out, we can use it for arrays */
		vals[key] = value[ii];
	}

	return (offset);
};

/*
 * Unfortunately, we're stuck with the sins of an initial poor design. Because
 * of that, we are going to have to support the old way of writing data via
 * writeData. There we insert the values that you want to write into the
 * definition. A little baroque. Internally, we use the new model. So we need to
 * just get those values out of there. But to maintain the principle of least
 * surprise, we're not going to modify the input data.
 */
function getValues(def)
{
	var ii, out, key;
	out = [];
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		mod_assert.ok('value' in def[ii][key]);
		out.push(def[ii][key]['value']);
	}

	return (out);
}

/*
 * This is the second half of what we were born to do, write out the data
 * itself. Historically this function required you to put your values in the
 * definition section. This was not the smartest thing to do and a bit of an
 * oversight to be honest. As such, this function now takes a values argument.
 * If values is non-null and non-undefined, it will be used to determine the
 * values. This means that the old method is still supported, but is no longer
 * acceptable.
 *
 *	def		The array definition of the data to write out with
 *			values
 *
 *	buffer		The buffer to write to
 *
 *	offset		The offset in the buffer to write to
 *
 *	values		An array of values to write.
 */
CTypeParser.prototype.writeData = function (def, buffer, offset, values)
{
	var hv;

	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	hv = (values != null && values != undefined);
	if (hv) {
		if (!Array.isArray(values))
			throw (new Error('missing values for writing'));
		ctCheckReq(def, this.types);
	} else {
		ctCheckReq(def, this.types, [ 'value' ]);
	}

	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
};

/*
 * Functions to go to and from 64 bit numbers in a way that is compatible with
 * Javascript limitations. There are two sets. One where the user is okay with
 * an approximation and one where they are definitely not okay with an
 * approximation.
 */

/*
 * Attempts to convert an array of two integers returned from rsint64 / ruint64
 * into an absolute 64 bit number. If however the value would exceed 2^52 this
 * will instead throw an error. The mantissa in a double is a 52 bit number and
 * rather than potentially give you a value that is an approximation this will
 * error. If you would rather an approximation, please see toApprox64.
 *
 *	val		An array of two 32-bit integers
 */
function toAbs64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	/* We have 20 bits worth of precision in this range */
	if (val[0] >= 0x100000)
		throw (new Error('value would become approximated'));

	return (val[0] * Math.pow(2, 32) + val[1]);
}

/*
 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
 * to a value as close as it can. Note that Javascript stores all numbers as a
 * double and the mantissa only has 52 bits. Thus this version may approximate
 * the value.
 *
 *	val		An array of two 32-bit integers
 */
function toApprox64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	return (Math.pow(2, 32) * val[0] + val[1]);
}

function parseCTF(json, conf)
{
	var ctype = new CTypeParser(conf);
	mod_ctf.ctfParseJson(json, ctype);

	return (ctype);
}

/*
 * Export the few things we actually want to. Currently this is just the CType
 * Parser and ctio.
 */
exports.Parser = CTypeParser;
exports.toAbs64 = toAbs64;
exports.toApprox64 = toApprox64;

exports.parseCTF = parseCTF;

exports.ruint8 = mod_ctio.ruint8;
exports.ruint16 = mod_ctio.ruint16;
exports.ruint32 = mod_ctio.ruint32;
exports.ruint64 = mod_ctio.ruint64;
exports.wuint8 = mod_ctio.wuint8;
exports.wuint16 = mod_ctio.wuint16;
exports.wuint32 = mod_ctio.wuint32;
exports.wuint64 = mod_ctio.wuint64;

exports.rsint8 = mod_ctio.rsint8;
exports.rsint16 = mod_ctio.rsint16;
exports.rsint32 = mod_ctio.rsint32;
exports.rsint64 = mod_ctio.rsint64;
exports.wsint8 = mod_ctio.wsint8;
exports.wsint16 = mod_ctio.wsint16;
exports.wsint32 = mod_ctio.wsint32;
exports.wsint64 = mod_ctio.wsint64;

exports.rfloat = mod_ctio.rfloat;
exports.rdouble = mod_ctio.rdouble;
exports.wfloat = mod_ctio.wfloat;
exports.wdouble = mod_ctio.wdouble;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/ctype.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/ctf.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctf.js"}
require.memoize("13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctf.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype';
/*
 * ctf.js
 *
 * Understand and parse all of the different JSON formats of CTF data and
 * translate that into a series of node-ctype friendly pieces. The reason for
 * the abstraction is to handle different changes in the file format.
 *
 * We have to be careful here that we don't end up using a name that is already
 * a built in type.
 */
var mod_assert = require('__SYSTEM__/assert');
var ASSERT = mod_assert.ok;

var ctf_versions = [ '1.0' ];
var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
    'uint32_t', 'float', 'double' ];

function ctfParseInteger(entry, ctype)
{
	var name, sign, len, type;

	name = entry['name'];
	if (!('signed' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'signed value'));


	if (!('length' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'length value'));

	sign = entry['integer']['signed'];
	len = entry['integer']['length'];
	type = null;

	if (sign && len == 1)
		type = 'int8_t';
	else if (len == 1)
		type = 'uint8_t';
	else if (sign && len == 2)
		type = 'int16_t';
	else if (len == 2)
		type = 'uint16_t';
	else if (sign && len == 4)
		type = 'int32_t';
	else if (len == 4)
		type = 'uint32_t';
	else if (sign && len == 8)
		type = 'int64_t';
	else if (len == 8)
		type = 'uint64_t';

	if (type === null)
		throw (new Error('Malformed CTF JSON: integer has ' +
		    'unsupported length and sign - ' + len + '/' + sign));

	/*
	 * This means that this is the same as one of our built in types. If
	 * that's the case defining it would be an error. So instead of trying
	 * to typedef it, we'll return here.
	 */
	if (name == type)
		return;

	if (name == 'char') {
		ASSERT(type == 'int8_t');
		return;
	}

	ctype.typedef(name, type);
}

function ctfParseFloat(entry, ctype)
{
	var name, len;

	name = entry['name'];
	if (!('length' in entry['float']))
		throw (new Error('Malformed CTF JSON: float missing ' +
		    'length value'));

	len = entry['float']['length'];
	if (len != 4 && len != 8)
		throw (new Error('Malformed CTF JSON: float has invalid ' +
		    'length value'));

	if (len == 4) {
		if (name == 'float')
			return;
		ctype.typedef(name, 'float');
	} else if (len == 8) {
		if (name == 'double')
			return;
		ctype.typedef(name, 'double');
	}
}

function ctfParseTypedef(entry, ctype)
{
	var name, type, ii;

	name = entry['name'];
	if (typeof (entry['typedef']) != 'string')
		throw (new Error('Malformed CTF JSON: typedef value in not ' +
		    'a string'));

	type = entry['typedef'];

	/*
	 * We need to ensure that we're not looking at type that's one of our
	 * built in types. Traditionally in C a uint32_t would be a typedef to
	 * some kind of integer. However, those size types are built ins.
	 */
	for (ii = 0; ii < ctf_deftypes.length; ii++) {
		if (name == ctf_deftypes[ii])
			return;
	}

	ctype.typedef(name, type);
}

function ctfParseStruct(entry, ctype)
{
	var name, type, ii, val, index, member, push;

	member = [];
	if (!Array.isArray(entry['struct']))
		throw (new Error('Malformed CTF JSON: struct value is not ' +
		    'an array'));

	for (ii = 0; ii < entry['struct'].length; ii++) {
		val = entry['struct'][ii];
		if (!('name' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing name'));

		if (!('type' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing type'));

		if (typeof (val['name']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'name isn\'t a string'));

		if (typeof (val['type']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'type isn\'t a string'));

		/*
		 * CTF version 2 specifies array names as <type> [<num>] where
		 * as node-ctype does this as <type>[<num>].
		 */
		name = val['name'];
		type = val['type'];
		index = type.indexOf(' [');
		if (index != -1) {
			type = type.substring(0, index) +
			    type.substring(index + 1, type.length);
		}
		push = {};
		push[name] = { 'type': type };
		member.push(push);
	}

	name = entry['name'];
	ctype.typedef(name, member);
}

function ctfParseEntry(entry, ctype)
{
	var ii, found;

	if (!('name' in entry))
		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
		    'section'));

	for (ii = 0; ii < ctf_entries.length; ii++) {
		if (ctf_entries[ii] in entry)
			found++;
	}

	if (found === 0)
		throw (new Error('Malformed CTF JSON: found no entries'));

	if (found >= 2)
		throw (new Error('Malformed CTF JSON: found more than one ' +
		    'entry'));

	if ('integer' in entry) {
		ctfParseInteger(entry, ctype);
		return;
	}

	if ('float' in entry) {
		ctfParseFloat(entry, ctype);
		return;
	}

	if ('typedef' in entry) {
		ctfParseTypedef(entry, ctype);
		return;
	}

	if ('struct' in entry) {
		ctfParseStruct(entry, ctype);
		return;
	}

	ASSERT(false, 'shouldn\'t reach here');
}

function ctfParseJson(json, ctype)
{
	var version, ii;

	ASSERT(json);
	ASSERT(ctype);
	if (!('metadata' in json))
		throw (new Error('Invalid CTF JSON: missing metadata section'));

	if (!('ctf2json_version' in json['metadata']))
		throw (new Error('Invalid CTF JSON: missing ctf2json_version'));

	version = json['metadata']['ctf2json_version'];
	for (ii = 0; ii < ctf_versions.length; ii++) {
		if (ctf_versions[ii] == version)
			break;
	}

	if (ii == ctf_versions.length)
		throw (new Error('Unsuported ctf2json_version: ' + version));

	if (!('data' in json))
		throw (new Error('Invalid CTF JSON: missing data section'));

	if (!Array.isArray(json['data']))
		throw (new Error('Malformed CTF JSON: data section is not ' +
		    'an array'));

	for (ii = 0; ii < json['data'].length; ii++)
		ctfParseEntry(json['data'][ii], ctype);
}

exports.ctfParseJson = ctfParseJson;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/ctf.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/ctio.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctio.js"}
require.memoize("13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctio.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype';
/*
 * rm - Feb 2011
 * ctio.js:
 *
 * A simple way to read and write simple ctypes. Of course, as you'll find the
 * code isn't as simple as it might appear. The following types are currently
 * supported in big and little endian formats:
 *
 * 	uint8_t			int8_t
 * 	uint16_t		int16_t
 * 	uint32_t		int32_t
 *	float (single precision IEEE 754)
 *	double (double precision IEEE 754)
 *
 * This is designed to work in Node and v8. It may in fact work in other
 * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
 * If you find that it does in fact work, that's pretty cool. Try and pass word
 * back to the original author.
 *
 * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
 * weird.
 */

/*
 * Numbers in Javascript have a secret: all numbers must be represented with an
 * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
 * implicit one. Thus the range of integers that can be represented is limited
 * to the size of the mantissa, this makes reading and writing 64-bit integers
 * difficult, but far from impossible.
 *
 * Another side effect of this representation is what happens when you use the
 * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
 * each operand and the result is cast to a signed 32-bit number. However, in
 * the case of >>> the values are cast to an unsigned number.
 */

/*
 * A reminder on endian related issues:
 *
 * Big Endian: MSB -> First byte
 * Little Endian: MSB->Last byte
 */
var mod_assert = require('__SYSTEM__/assert');

/*
 * An 8 bit unsigned integer involves doing no significant work.
 */
function ruint8(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (buffer[offset]);
}

/*
 * For 16 bit unsigned numbers we can do all the casting that we want to do.
 */
function rgint16(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset] << 8;
		val |=  buffer[offset+1];
	} else {
		val = buffer[offset];
		val |= buffer[offset+1] << 8;
	}

	return (val);

}

function ruint16(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint16(buffer, endian, offset));
}

/*
 * Because most bitshifting is done using signed numbers, if we would go into
 * the realm where we use that 32nd bit, we'll end up going into the negative
 * range. i.e.:
 * > 200 << 24
 * -939524096
 *
 * Not the value you'd expect. To work around this, we end up having to do some
 * abuse of the JavaScript standard. in this case, we know that a >>> shift is
 * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
 * use that instead to save us some additional math, though it does feel a
 * little weird and it isn't obvious as to why you woul dwant to do this at
 * first.
 */
function rgint32(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset+1] << 16;
		val |= buffer[offset+2] << 8;
		val |= buffer[offset+3];
		val = val + (buffer[offset] << 24 >>> 0);
	} else {
		val = buffer[offset+2] << 16;
		val |= buffer[offset+1] << 8;
		val |= buffer[offset];
		val = val + (buffer[offset + 3] << 24 >>> 0);
	}

	return (val);
}

function ruint32(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint32(buffer, endian, offset));
}

/*
 * Reads a 64-bit unsigned number. The astue observer will note that this
 * doesn't quite work. Javascript has chosen to only have numbers that can be
 * represented by a double. A double only has 52 bits of mantissa with an
 * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
 * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
 * could you have possibly wanted to represent that was larger than that? Oh,
 * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
 * that happen?
 *
 * To get around this egregious language issue, we're going to instead construct
 * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
 * give the actual number. However, note that the above code probably won't
 * produce the desired results because of the way Javascript numbers are
 * doubles.
 */
function rgint64(buffer, endian, offset)
{
	var val = new Array(2);

	if (endian == 'big') {
		val[0] = ruint32(buffer, endian, offset);
		val[1] = ruint32(buffer, endian, offset+4);
	} else {
		val[0] = ruint32(buffer, endian, offset+4);
		val[1] = ruint32(buffer, endian, offset);
	}

	return (val);
}

function ruint64(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint64(buffer, endian, offset));
}


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 *
 * Doing it this way ends up allowing us to treat it appropriately in
 * Javascript. Sigh, that's really quite ugly for what should just be a few bit
 * shifts, ~ and &.
 */

/*
 * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
 * this case because the more traditional methods work, but for consistency,
 * we'll keep doing this the same way.
 */
function rsint8(buffer, endian, offset)
{
	var neg;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	neg = buffer[offset] & 0x80;
	if (!neg)
		return (buffer[offset]);

	return ((0xff - buffer[offset] + 1) * -1);
}

/*
 * The 16-bit version requires a bit more effort. In this case, we can leverage
 * our unsigned code to generate the value we want to return.
 */
function rsint16(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint16(buffer, endian, offset);
	neg = val & 0x8000;
	if (!neg)
		return (val);

	return ((0xffff - val + 1) * -1);
}

/*
 * We really shouldn't leverage our 32-bit code here and instead utilize the
 * fact that we know that since these are signed numbers, we can do all the
 * shifting and binary anding to generate the 32-bit number. But, for
 * consistency we'll do the same. If we want to do otherwise, we should instead
 * make the 32 bit unsigned code do the optimization. But as long as there
 * aren't floats secretly under the hood for that, we /should/ be okay.
 */
function rsint32(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint32(buffer, endian, offset);
	neg = val & 0x80000000;
	if (!neg)
		return (val);

	return ((0xffffffff - val + 1) * -1);
}

/*
 * The signed version of this code suffers from all of the same problems of the
 * other 64 bit version.
 */
function rsint64(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint64(buffer, endian, offset);
	neg = val[0] & 0x80000000;

	if (!neg)
		return (val);

	val[0] = (0xffffffff - val[0]) * -1;
	val[1] = (0xffffffff - val[1] + 1) * -1;

	/*
	 * If we had the key 0x8000000000000000, that would leave the lower 32
	 * bits as 0xffffffff, however, since we're goint to add one, that would
	 * actually leave the lower 32-bits as 0x100000000, which would break
	 * our ability to write back a value that we received. To work around
	 * this, if we actually get that value, we're going to bump the upper
	 * portion by 1 and set this to zero.
	 */
	mod_assert.ok(val[1] <= 0x100000000);
	if (val[1] == -0x100000000) {
		val[1] = 0;
		val[0]--;
	}

	return (val);
}

/*
 * We now move onto IEEE 754: The traditional form for floating point numbers
 * and what is secretly hiding at the heart of everything in this. I really hope
 * that someone is actually using this, as otherwise, this effort is probably
 * going to be more wasted.
 *
 * One might be tempted to use parseFloat here, but that wouldn't work at all
 * for several reasons. Mostly due to the way floats actually work, and
 * parseFloat only actually works in base 10. I don't see base 10 anywhere near
 * this file.
 *
 * In this case we'll implement the single and double precision versions. The
 * quadruple precision, while probably useful, wouldn't really be accepted by
 * Javascript, so let's not even waste our time.
 *
 * So let's review how this format looks like. A single precision value is 32
 * bits and has three parts:
 *   -  Sign bit
 *   -  Exponent (Using bias notation)
 *   -  Mantissa
 *
 * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
 * 31| 30-23  |  22    	-       0       |
 *
 * The exponent is stored in a biased input. The bias in this case 127.
 * Therefore, our exponent is equal to the 8-bit value - 127.
 *
 * By default, a number is normalized in IEEE, that means that the mantissa has
 * an implicit one that we don't see. So really the value stored is 1.m.
 * However, if the exponent is all zeros, then instead we have to shift
 * everything to the right one and there is no more implicit one.
 *
 * Special values:
 *  - Positive Infinity:
 *	Sign:		0
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - Negative Infinity:
 *	Sign:		1
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - NaN:
 *	Sign:		*
 *	Exponent: 	All 1s
 *	Mantissa:	non-zero
 *  - Zero:
 *	Sign:		*
 *	Exponent:	All 0s
 *	Mantissa:	0
 *
 * In the case of zero, the sign bit determines whether we get a positive or
 * negative zero. However, since Javascript cannot determine the difference
 * between the two: i.e. -0 == 0, we just always return 0.
 *
 */
function rfloat(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val;
	var bias = 127;
	var maxexp = 0xff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
	} else {
		bytes[3] = buffer[offset];
		bytes[2] = buffer[offset+1];
		bytes[1] = buffer[offset+2];
		bytes[0] = buffer[offset+3];
	}

	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 1;
	exponent |= (bytes[1] & 0x80) >>> 7;
	mantissa = (bytes[1] & 0x7f) << 16;
	mantissa |= bytes[2] << 8;
	mantissa |= bytes[3];

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Doubles in IEEE 754 are like their brothers except for a few changes and
 * increases in size:
 *   - The exponent is now 11 bits
 *   - The mantissa is now 52 bits
 *   - The bias is now 1023
 *
 * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
 * 63| 62 - 52   | 	51		-			0     |
 * 63| 62 - 52   |      51              -                       0     |
 *
 * While the size has increased a fair amount, we're going to end up keeping the
 * same general formula for calculating the final value. As a reminder, this
 * formula is:
 *
 * (-1)^s * (n + m) * 2^(e-b)
 *
 * Where:
 *	s	is the sign bit
 *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
 *					     or not
 *	m	is the mantissa
 *	e	is the exponent specified
 *	b	is the bias for the exponent
 *
 */
function rdouble(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val, lowmant;
	var bias = 1023;
	var maxexp = 0x7ff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
		bytes[4] = buffer[offset+4];
		bytes[5] = buffer[offset+5];
		bytes[6] = buffer[offset+6];
		bytes[7] = buffer[offset+7];
	} else {
		bytes[7] = buffer[offset];
		bytes[6] = buffer[offset+1];
		bytes[5] = buffer[offset+2];
		bytes[4] = buffer[offset+3];
		bytes[3] = buffer[offset+4];
		bytes[2] = buffer[offset+5];
		bytes[1] = buffer[offset+6];
		bytes[0] = buffer[offset+7];
	}

	/*
	 * We can construct the exponent and mantissa the same way as we did in
	 * the case of a float, just increase the range of the exponent.
	 */
	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 4;
	exponent |= (bytes[1] & 0xf0) >>> 4;

	/*
	 * This is going to be ugly but then again, we're dealing with IEEE 754.
	 * This could probably be done as a node add on in a few lines of C++,
	 * but oh we'll, we've made it this far so let's be native the rest of
	 * the way...
	 *
	 * What we're going to do is break the mantissa into two parts, the
	 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
	 * by the appropriate power and then add in the lower 24-bits. Not
	 * really that great. It's pretty much a giant kludge to deal with
	 * Javascript eccentricities around numbers.
	 */
	lowmant = bytes[7];
	lowmant |= bytes[6] << 8;
	lowmant |= bytes[5] << 16;
	mantissa = bytes[4];
	mantissa |= bytes[3] << 8;
	mantissa |= bytes[2] << 16;
	mantissa |= (bytes[1] & 0x0f) << 24;
	mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
	mantissa += lowmant;

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Now that we have gone through the pain of reading the individual types, we're
 * probably going to want some way to write these back. None of this is going to
 * be good. But since we have Javascript numbers this should certainly be more
 * interesting. Though we can constrain this end a little bit more in what is
 * valid. For now, let's go back to our friends the unsigned value.
 */

/*
 * Unsigned numbers seem deceptively easy. Here are the general steps and rules
 * that we are going to take:
 *   -  If the number is negative, throw an Error
 *   -  Truncate any floating point portion
 *   -  Take the modulus of the number in our base
 *   -  Write it out to the buffer in the endian format requested at the offset
 */

/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *	value		The number to check for validity
 *
 *	max		The maximum value
 */
function prepuint(value, max)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value < 0)
		throw (new Error('specified a negative value for writing an ' +
		    'unsigned value'));

	if (value > max)
		throw (new Error('value is larger than maximum value for ' +
		    'type'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * 8-bit version, classy. We can ignore endianness which is good.
 */
function wuint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xff);
	buffer[offset] = val;
}

/*
 * Pretty much the same as the 8-bit version, just this time we need to worry
 * about endian related issues.
 */
function wgint16(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val & 0xff00) >>> 8;
		buffer[offset+1] = val & 0x00ff;
	} else {
		buffer[offset+1] = (val & 0xff00) >>> 8;
		buffer[offset] = val & 0x00ff;
	}
}

function wuint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffff);
	wgint16(val, endian, buffer, offset);
}

/*
 * The 32-bit version is going to have to be a little different unfortunately.
 * We can't quite bitshift to get the largest byte, because that would end up
 * getting us caught by the signed values.
 *
 * And yes, we do want to subtract out the lower part by default. This means
 * that when we do the division, it will be treated as a bit shift and we won't
 * end up generating a floating point value. If we did generate a floating point
 * value we'd have to truncate it intelligently, this saves us that problem and
 * may even be somewhat faster under the hood.
 */
function wgint32(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
		buffer[offset+1] = (val >>> 16) & 0xff;
		buffer[offset+2] = (val >>> 8) & 0xff;
		buffer[offset+3] = val & 0xff;
	} else {
		buffer[offset+3] = (val - (val & 0x00ffffff)) /
		    Math.pow(2, 24);
		buffer[offset+2] = (val >>> 16) & 0xff;
		buffer[offset+1] = (val >>> 8) & 0xff;
		buffer[offset] = val & 0xff;
	}
}

function wuint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffffffff);
	wgint32(val, endian, buffer, offset);
}

/*
 * Unlike the other versions, we expect the value to be in the form of two
 * arrays where value[0] << 32 + value[1] would result in the value that we
 * want.
 */
function wgint64(value, endian, buffer, offset)
{
	if (endian == 'big') {
		wgint32(value[0], endian, buffer, offset);
		wgint32(value[1], endian, buffer, offset+4);
	} else {
		wgint32(value[0], endian, buffer, offset+4);
		wgint32(value[1], endian, buffer, offset);
	}
}

function wuint64(value, endian, buffer, offset)
{
	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	prepuint(value[0], 0xffffffff);
	prepuint(value[1], 0xffffffff);
	wgint64(value, endian, buffer, offset);
}

/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *	we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *	we do the following computation:
 *	mb + val + 1, where
 *	mb	is the maximum unsigned value in that byte size
 *	val	is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 *
 * Thus the overall flow is:
 *   -  Truncate the floating point part of the number
 *   -  We don't have to take the modulus, because the unsigned versions will
 *   	take care of that for us. And we don't have to worry about that
 *   	potentially causing bad things to happen because of sign extension
 *   -  Pass it off to the appropriate unsigned version, potentially modifying
 *	the negative portions as necessary.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function prepsint(value, max, min)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value > max)
		throw (new Error('value larger than maximum allowed value'));

	if (value < min)
		throw (new Error('value smaller than minimum allowed value'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * The 8-bit version of the signed value. Overall, fairly straightforward.
 */
function wsint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7f, -0x80);
	if (val >= 0)
		wuint8(val, endian, buffer, offset);
	else
		wuint8(0xff + val + 1, endian, buffer, offset);
}

/*
 * The 16-bit version of the signed value. Also, fairly straightforward.
 */
function wsint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fff, -0x8000);
	if (val >= 0)
		wgint16(val, endian, buffer, offset);
	else
		wgint16(0xffff + val + 1, endian, buffer, offset);

}

/*
 * We can do this relatively easily by leveraging the code used for 32-bit
 * unsigned code.
 */
function wsint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fffffff, -0x80000000);
	if (val >= 0)
		wgint32(val, endian, buffer, offset);
	else
		wgint32(0xffffffff + val + 1, endian, buffer, offset);
}

/*
 * The signed 64 bit integer should by in the same format as when received.
 * Mainly it should ensure that the value is an array of two integers where
 * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
 * need to be equal.
 */
function wsint64(value, endian, buffer, offset)
{
	var vzpos, vopos;
	var vals = new Array(2);

	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/*
	 * We need to make sure that we have the same sign on both values. The
	 * hokiest way to to do this is to multiply the number by +inf. If we do
	 * this, we'll get either +/-inf depending on the sign of the value.
	 * Once we have this, we can compare it to +inf to see if the number is
	 * positive or not.
	 */
	vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;
	vopos = (value[1] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;

	/*
	 * If either of these is zero, then we don't actually need this check.
	 */
	if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
		throw (new Error('Both entries in the array must have ' +
		    'the same sign'));

	/*
	 * Doing verification for a signed 64-bit integer is actually a big
	 * trickier than it appears. We can't quite use our standard techniques
	 * because we need to compare both sets of values. The first value is
	 * pretty straightforward. If the first value is beond the extremes than
	 * we error out. However, the valid range of the second value varies
	 * based on the first one. If the first value is negative, and *not* the
	 * largest negative value, than it can be any integer within the range [
	 * 0, 0xffffffff ]. If it is the largest negative number, it must be
	 * zero.
	 *
	 * If the first number is positive, than it doesn't matter what the
	 * value is. We just simply have to make sure we have a valid positive
	 * integer.
	 */
	if (vzpos) {
		prepuint(value[0], 0x7fffffff);
		prepuint(value[1], 0xffffffff);
	} else {
		prepsint(value[0], 0, -0x80000000);
		prepsint(value[1], 0, -0xffffffff);
		if (value[0] == -0x80000000 && value[1] != 0)
			throw (new Error('value smaller than minimum ' +
			    'allowed value'));
	}

	/* Fix negative numbers */
	if (value[0] < 0 || value[1] < 0) {
		vals[0] = 0xffffffff - Math.abs(value[0]);
		vals[1] = 0x100000000 - Math.abs(value[1]);
		if (vals[1] == 0x100000000) {
			vals[1] = 0;
			vals[0]++;
		}
	} else {
		vals[0] = value[0];
		vals[1] = value[1];
	}
	wgint64(vals, endian, buffer, offset);
}

/*
 * Now we are moving onto the weirder of these, the float and double. For this
 * we're going to just have to do something that's pretty weird. First off, we
 * have no way to get at the underlying float representation, at least not
 * easily. But that doesn't mean we can't figure it out, we just have to use our
 * heads.
 *
 * One might propose to use Number.toString(2). Of course, this is not really
 * that good, because the ECMAScript 262 v3 Standard says the following Section
 * 15.7.4.2-Number.prototype.toString (radix):
 *
 * If radix is an integer from 2 to 36, but not 10, the result is a string, the
 * choice of which is implementation-dependent.
 *
 * Well that doesn't really help us one bit now does it? We could use the
 * standard base 10 version of the string, but that's just going to create more
 * errors as we end up trying to convert it back to a binary value. So, really
 * this just means we have to be non-lazy and parse the structure intelligently.
 *
 * First off, we can do the basic checks: NaN, positive and negative infinity.
 *
 * Now that those are done we can work backwards to generate the mantissa and
 * exponent.
 *
 * The first thing we need to do is determine the sign bit, easy to do, check
 * whether the value is less than 0. And convert the number to its absolute
 * value representation. Next, we need to determine if the value is less than
 * one or greater than or equal to one and from there determine what power was
 * used to get there. What follows is now specific to floats, though the general
 * ideas behind this will hold for doubles as well, but the exact numbers
 * involved will change.
 *
 * Once we have that power we can determine the exponent and the mantissa. Call
 * the value that has the number of bits to reach the power ebits. In the
 * general case they have the following values:
 *
 *	exponent	127 + ebits
 *	mantissa	value * 2^(23 - ebits) & 0x7fffff
 *
 * In the case where the value of ebits is <= -127 we are now in the case where
 * we no longer have normalized numbers. In this case the values take on the
 * following values:
 *
 * 	exponent	0
 *	mantissa	value * 2^149 & 0x7fffff
 *
 * Once we have the values for the sign, mantissa, and exponent. We reconstruct
 * the four bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits from the exp
 *			sign << 7 | (exponent & 0xfe) >>> 1
 *
 *	byte1		lsb from the exponent and 7 top bits from the mantissa
 *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
 *
 *	byte2		bits 8-15 (zero indexing) from mantissa
 *			mantissa & 0xff00 >> 8
 *
 *	byte3		bits 0-7 from mantissa
 *			mantissa & 0xff
 *
 * Once we have this we have to assign them into the buffer in proper endian
 * order.
 */

/*
 * Compute the log base 2 of the value. Now, someone who remembers basic
 * properties of logarithms will point out that we could use the change of base
 * formula for logs, and in fact that would be astute, because that's what we'll
 * do for now. It feels cleaner, albeit it may be less efficient than just
 * iterating and dividing by 2. We may want to come back and revisit that some
 * day.
 */
function log2(value)
{
	return (Math.log(value) / Math.log(2));
}

/*
 * Helper to determine the exponent of the number we're looking at.
 */
function intexp(value)
{
	return (Math.floor(log2(value)));
}

/*
 * Helper to determine the exponent of the fractional part of the value.
 */
function fracexp(value)
{
	return (Math.floor(log2(value)));
}

function wfloat(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0xff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0xff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0xff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/* Time to deal with the issues surrounding normalization */
		if (ebits <= -127) {
			exponent = 0;
			mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
		} else {
			exponent = 127 + ebits;
			mantissa = value * Math.pow(2, 23 - ebits);
			mantissa &= 0x7fffff;
		}
	}

	bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
	bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
	bytes[2] = (mantissa & 0x00ff00) >>> 8;
	bytes[3] = mantissa & 0x0000ff;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
	} else {
		buffer[offset] = bytes[3];
		buffer[offset+1] = bytes[2];
		buffer[offset+2] = bytes[1];
		buffer[offset+3] = bytes[0];
	}
}

/*
 * Now we move onto doubles. Doubles are similar to floats in pretty much all
 * ways except that the processing isn't quite as straightforward because we
 * can't always use shifting, i.e. we have > 32 bit values.
 *
 * We're going to proceed in an identical fashion to floats and utilize the same
 * helper functions. All that really is changing are the specific values that we
 * use to do the calculations. Thus, to review we have to do the following.
 *
 * First get the sign bit and convert the value to its absolute value
 * representation. Next, we determine the number of bits that we used to get to
 * the value, branching whether the value is greater than or less than 1. Once
 * we have that value which we will again call ebits, we have to do the
 * following in the general case:
 *
 *	exponent	1023 + ebits
 *	mantissa	[value * 2^(52 - ebits)] % 2^52
 *
 * In the case where the value of ebits <= -1023 we no longer use normalized
 * numbers, thus like with floats we have to do slightly different processing:
 *
 *	exponent	0
 *	mantissa	[value * 2^1074] % 2^52
 *
 * Once we have determined the sign, exponent and mantissa we can construct the
 * bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits form the exp
 *			sign << 7 | (exponent & 0x7f0) >>> 4
 *
 *	byte1		Remaining 4 bits from the exponent and the four most
 *			significant bits from the mantissa 48-51
 *			(exponent & 0x00f) << 4 | mantissa >>> 48
 *
 *	byte2		Bits 40-47 from the mantissa
 *			(mantissa >>> 40) & 0xff
 *
 *	byte3		Bits 32-39 from the mantissa
 *			(mantissa >>> 32) & 0xff
 *
 *	byte4		Bits 24-31 from the mantissa
 *			(mantissa >>> 24) & 0xff
 *
 *	byte5		Bits 16-23 from the Mantissa
 *			(mantissa >>> 16) & 0xff
 *
 *	byte6		Bits 8-15 from the mantissa
 *			(mantissa >>> 8) & 0xff
 *
 *	byte7		Bits 0-7 from the mantissa
 *			mantissa & 0xff
 *
 * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
 * we'll have extended too far and we'll lose those values when we try and do
 * the shift. Instead we have to use an alternate approach. To try and stay out
 * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
 * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
 * that's ugly, but it seems to avoid using floating point (just based on how v8
 * seems to be optimizing for base 2 arithmetic).
 */
function wdouble(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0x7ff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/*
		 * This is a total hack to determine a denormalized value.
		 * Unfortunately, we sometimes do not get a proper value for
		 * ebits, i.e. we lose the values that would get rounded off.
		 *
		 *
		 * The astute observer may wonder why we would be
		 * multiplying by two Math.pows rather than just summing
		 * them. Well, that's to get around a small bug in the
		 * way v8 seems to implement the function. On occasion
		 * doing:
		 *
		 * foo * Math.pow(2, 1023 + 51)
		 *
		 * Causes us to overflow to infinity, where as doing:
		 *
		 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
		 *
		 * Does not cause us to overflow. Go figure.
		 *
		 */
		if (value <= 2.225073858507201e-308 || ebits <= -1023) {
			exponent = 0;
			mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
			mantissa %= Math.pow(2, 52);
		} else {
			/*
			 * We might have gotten fucked by our floating point
			 * logarithm magic. This is rather crappy, but that's
			 * our luck. If we just had a log base 2 or access to
			 * the stupid underlying representation this would have
			 * been much easier and we wouldn't have such stupid
			 * kludges or hacks.
			 */
			if (ebits > 1023)
				ebits = 1023;
			exponent = 1023 + ebits;
			mantissa = value * Math.pow(2, -ebits);
			mantissa *= Math.pow(2, 52);
			mantissa %= Math.pow(2, 52);
		}
	}

	/* Fill the bytes in backwards to deal with the size issues */
	bytes[7] = mantissa & 0xff;
	bytes[6] = (mantissa >>> 8) & 0xff;
	bytes[5] = (mantissa >>> 16) & 0xff;
	mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
	bytes[4] = mantissa & 0xff;
	bytes[3] = (mantissa >>> 8) & 0xff;
	bytes[2] = (mantissa >>> 16) & 0xff;
	bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
	bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
		buffer[offset+4] = bytes[4];
		buffer[offset+5] = bytes[5];
		buffer[offset+6] = bytes[6];
		buffer[offset+7] = bytes[7];
	} else {
		buffer[offset+7] = bytes[0];
		buffer[offset+6] = bytes[1];
		buffer[offset+5] = bytes[2];
		buffer[offset+4] = bytes[3];
		buffer[offset+3] = bytes[4];
		buffer[offset+2] = bytes[5];
		buffer[offset+1] = bytes[6];
		buffer[offset] = bytes[7];
	}
}

/*
 * Actually export our work above. One might argue that we shouldn't expose
 * these interfaces and just force people to use the higher level abstractions
 * around this work. However, unlike say other libraries we've come across, this
 * interface has several properties: it makes sense, it's simple, and it's
 * useful.
 */
exports.ruint8 = ruint8;
exports.ruint16 = ruint16;
exports.ruint32 = ruint32;
exports.ruint64 = ruint64;
exports.wuint8 = wuint8;
exports.wuint16 = wuint16;
exports.wuint32 = wuint32;
exports.wuint64 = wuint64;

exports.rsint8 = rsint8;
exports.rsint16 = rsint16;
exports.rsint32 = rsint32;
exports.rsint64 = rsint64;
exports.wsint8 = wsint8;
exports.wsint16 = wsint16;
exports.wsint32 = wsint32;
exports.wsint64 = wsint64;

exports.rfloat = rfloat;
exports.rdouble = rdouble;
exports.wfloat = wfloat;
exports.wdouble = wdouble;

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/ctio.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/node-uuid/uuid.js","mtime":0,"wrapper":"amd-ish","format":"amd-ish","id":"c0e0c010944c64f22cbef7cbf6c98c6f92ff0bee-node-uuid/uuid.js"}
require.memoize("c0e0c010944c64f22cbef7cbf6c98c6f92ff0bee-node-uuid/uuid.js", 
wrapAMD(function(require, define) {
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('__SYSTEM__/crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

})
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/node-uuid/uuid.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/mime/mime.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"605d0653b789e3de9801f6c70dc6806f10f3df59-mime/mime.js"}
require.memoize("605d0653b789e3de9801f6c70dc6806f10f3df59-mime/mime.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/mime';
var path = require('__SYSTEM__/path');
var fs = require('__SYSTEM__/fs');

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];

    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts]) {
        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {

  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Load local copy of
// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
mime.load(path.join(__dirname, 'types/mime.types'));

// Load additional types from node.js community
mime.load(path.join(__dirname, 'types/node.types'));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;

return {
    path: (typeof path !== "undefined") ? path : null,
    require: (typeof require !== "undefined") ? require : null,
    fs: (typeof fs !== "undefined") ? fs : null,
    Mime: (typeof Mime !== "undefined") ? Mime : null,
    Object: (typeof Object !== "undefined") ? Object : null,
    process: (typeof process !== "undefined") ? process : null,
    console: (typeof console !== "undefined") ? console : null,
    mime: (typeof mime !== "undefined") ? mime : null,
    __dirname: (typeof __dirname !== "undefined") ? __dirname : null,
    module: (typeof module !== "undefined") ? module : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/mime/mime.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/tunnel-agent/index.js","mtime":0,"wrapper":"commonjs","format":"commonjs","id":"d84bcf6c67f6981373f5d572f45044309b8869e9-tunnel-agent/index.js"}
require.memoize("d84bcf6c67f6981373f5d572f45044309b8869e9-tunnel-agent/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/tunnel-agent';
'use strict'

var net = require('__SYSTEM__/net')
  , tls = require('__SYSTEM__/tls')
  , http = require('__SYSTEM__/http')
  , https = require('__SYSTEM__/https')
  , events = require('__SYSTEM__/events')
  , assert = require('__SYSTEM__/assert')
  , util = require('__SYSTEM__/util')
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  return agent
}


function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {
  var self = this

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: host, port: port, request: req})
    return
  }

  // If we are under maxSockets create a new one.
  self.createSocket({host: host, port: port, request: req}, function(socket) {
    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    req.onSocket(socket)

    function onFree() {
      self.emit('free', socket, host, port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket()
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions, 
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  )
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse) // for v0.6
  connectReq.once('upgrade', onUpgrade)   // for v0.6
  connectReq.once('connect', onConnect)   // for v0.7 or later
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      assert.equal(head.length, 0)
      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      options.request.emit('error', error)
      self.removeSocket(placeholder)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) return
  
  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket)
    })
  }
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
      { servername: options.host
      , socket: socket
      }
    ))
    cb(secureSocket)
  })
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides)
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== undefined) {
          target[k] = overrides[k]
        }
      }
    }
  }
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments)
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0]
    } else {
      args.unshift('TUNNEL:')
    }
    console.error.apply(console, args)
  }
} else {
  debug = function() {}
}
exports.debug = debug // for test

}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/tunnel-agent/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/json-stringify-safe/stringify.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"676738dbbe6012d457627e1573854d4b0f783d3f-json-stringify-safe/stringify.js"}
require.memoize("676738dbbe6012d457627e1573854d4b0f783d3f-json-stringify-safe/stringify.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/json-stringify-safe';
module.exports = stringify;

function getSerialize (fn, decycle) {
  var seen = [], keys = [];
  decycle = decycle || function(key, value) {
    return '[Circular ' + getPath(value, seen, keys) + ']'
  };
  return function(key, value) {
    var ret = value;
    if (typeof value === 'object' && value) {
      if (seen.indexOf(value) !== -1)
        ret = decycle(key, value);
      else {
        seen.push(value);
        keys.push(key);
      }
    }
    if (fn) ret = fn(key, ret);
    return ret;
  }
}

function getPath (value, seen, keys) {
  var index = seen.indexOf(value);
  var path = [ keys[index] ];
  for (index--; index >= 0; index--) {
    if (seen[index][ path[0] ] === value) {
      value = seen[index];
      path.unshift(keys[index]);
    }
  }
  return '~' + path.join('.');
}

function stringify(obj, fn, spaces, decycle) {
  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);
}

stringify.getSerialize = getSerialize;

return {
    module: (typeof module !== "undefined") ? module : null,
    getSerialize: (typeof getSerialize !== "undefined") ? getSerialize : null,
    getPath: (typeof getPath !== "undefined") ? getPath : null,
    stringify: (typeof stringify !== "undefined") ? stringify : null,
    JSON: (typeof JSON !== "undefined") ? JSON : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/json-stringify-safe/stringify.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/forever-agent/index.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"7c9aa9a5db66cc2b7202a9768e97e9faa14bf42c-forever-agent/index.js"}
require.memoize("7c9aa9a5db66cc2b7202a9768e97e9faa14bf42c-forever-agent/index.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/forever-agent';
module.exports = ForeverAgent
ForeverAgent.SSL = ForeverAgentSSL

var util = require('__SYSTEM__/util')
  , Agent = require('__SYSTEM__/http').Agent
  , net = require('__SYSTEM__/net')
  , tls = require('__SYSTEM__/tls')
  , AgentSSL = require('__SYSTEM__/https').Agent

function ForeverAgent(options) {
  var self = this
  self.options = options || {}
  self.requests = {}
  self.sockets = {}
  self.freeSockets = {}
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
  self.on('free', function(socket, host, port) {
    var name = host + ':' + port
    if (self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket)
    } else if (self.sockets[name].length < self.minSockets) {
      if (!self.freeSockets[name]) self.freeSockets[name] = []
      self.freeSockets[name].push(socket)
      
      // if an error happens while we don't use the socket anyway, meh, throw the socket away
      var onIdleError = function() {
        socket.destroy()
      }
      socket._onIdleError = onIdleError
      socket.on('error', onIdleError)
    } else {
      // If there are no pending requests just destroy the
      // socket and it will get removed from the pool. This
      // gets us out of timeout issues and allows us to
      // default to Connection:keep-alive.
      socket.destroy()
    }
  })

}
util.inherits(ForeverAgent, Agent)

ForeverAgent.defaultMinSockets = 5


ForeverAgent.prototype.createConnection = net.createConnection
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = host + ':' + port
  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop()
    idleSocket.removeListener('error', idleSocket._onIdleError)
    delete idleSocket._onIdleError
    req._reusedSocket = true
    req.onSocket(idleSocket)
  } else {
    this.addRequestNoreuse(req, host, port)
  }
}

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  if (this.sockets[name]) {
    var index = this.sockets[name].indexOf(s)
    if (index !== -1) {
      this.sockets[name].splice(index, 1)
    }
  } else if (this.sockets[name] && this.sockets[name].length === 0) {
    // don't leak
    delete this.sockets[name]
    delete this.requests[name]
  }
  
  if (this.freeSockets[name]) {
    var index = this.freeSockets[name].indexOf(s)
    if (index !== -1) {
      this.freeSockets[name].splice(index, 1)
      if (this.freeSockets[name].length === 0) {
        delete this.freeSockets[name]
      }
    }
  }

  if (this.requests[name] && this.requests[name].length) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(name, host, port).emit('free')
  }
}

function ForeverAgentSSL (options) {
  ForeverAgent.call(this, options)
}
util.inherits(ForeverAgentSSL, ForeverAgent)

ForeverAgentSSL.prototype.createConnection = createConnectionSSL
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

function createConnectionSSL (port, host, options) {
  if (typeof port === 'object') {
    options = port;
  } else if (typeof host === 'object') {
    options = host;
  } else if (typeof options === 'object') {
    options = options;
  } else {
    options = {};
  }

  if (typeof port === 'number') {
    options.port = port;
  }

  if (typeof host === 'string') {
    options.host = host;
  }

  return tls.connect(options);
}

return {
    module: (typeof module !== "undefined") ? module : null,
    ForeverAgent: (typeof ForeverAgent !== "undefined") ? ForeverAgent : null,
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    Agent: (typeof Agent !== "undefined") ? Agent : null,
    net: (typeof net !== "undefined") ? net : null,
    tls: (typeof tls !== "undefined") ? tls : null,
    AgentSSL: (typeof AgentSSL !== "undefined") ? AgentSSL : null,
    ForeverAgentSSL: (typeof ForeverAgentSSL !== "undefined") ? ForeverAgentSSL : null,
    createConnectionSSL: (typeof createConnectionSSL !== "undefined") ? createConnectionSSL : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/forever-agent/index.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/lib/form_data.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"f701ab5006089176e28016f244aac960ca36eb37-form-data/lib/form_data.js"}
require.memoize("f701ab5006089176e28016f244aac960ca36eb37-form-data/lib/form_data.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/lib';
var CombinedStream = require('combined-stream');
var util = require('__SYSTEM__/util');
var path = require('__SYSTEM__/path');
var http = require('__SYSTEM__/http');
var https = require('__SYSTEM__/https');
var parseUrl = require('__SYSTEM__/url').parse;
var fs = require('__SYSTEM__/fs');
var mime = require('mime');
var async = require('async');

module.exports = FormData;
function FormData() {
  this._overheadLength = 0;
  this._valueLength = 0;
  this._lengthRetrievers = [];

  CombinedStream.call(this);
}
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';

FormData.prototype.append = function(field, value, options) {
  options = options || {};

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') value = ''+value;

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter(field, value, options);

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength)
  this._lengthRetrievers.push(function(next) {

    if (value.hasOwnProperty('fd')) {

      // take read range into a account
      // `end` = Infinity > read file till the end
      //
      // TODO: Looks like there is bug in Node fs.createReadStream
      // it doesn't respect `end` options without `start` options
      // Fix it when node fixes it.
      // https://github.com/joyent/node/issues/7819
      if (value.end != undefined && value.end != Infinity && value.start != undefined) {

        // when end specified
        // no need to calculate range
        // inclusive, starts with 0
        next(null, value.end+1 - (value.start ? value.start : 0));

      // not that fast snoopy
      } else {
        // still need to fetch file size from fs
        fs.stat(value.path, function(err, stat) {

          var fileSize;

          if (err) {
            next(err);
            return;
          }

          // update final size based on the range options
          fileSize = stat.size - (value.start ? value.start : 0);
          next(null, fileSize);
        });
      }

    // or http response
    } else if (value.hasOwnProperty('httpVersion')) {
      next(null, +value.headers['content-length']);

    // or request stream http://github.com/mikeal/request
    } else if (value.hasOwnProperty('httpModule')) {
      // wait till response come back
      value.on('response', function(response) {
        value.pause();
        next(null, +response.headers['content-length']);
      });
      value.resume();

    // something else
    } else {
      next('Unknown stream');
    }
  });
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  var boundary = this.getBoundary();
  var header = '';

  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (options.header != null) {
    header = options.header;
  } else {
    header += '--' + boundary + FormData.LINE_BREAK +
      'Content-Disposition: form-data; name="' + field + '"';

    // fs- and request- streams have path property
    // or use custom filename and/or contentType
    // TODO: Use request's response mime-type
    if (options.filename || value.path) {
      header +=
        '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));

    // http response has not
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
      header +=
        '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' + value.headers['content-type'];
    }

    header += FormData.LINE_BREAK + FormData.LINE_BREAK;
  }

  return header;
};

FormData.prototype._multiPartFooter = function(field, value, options) {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--';
};

FormData.prototype.getHeaders = function(userHeaders) {
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (var header in userHeaders) {
    formHeaders[header.toLowerCase()] = userHeaders[header];
  }

  return formHeaders;
}

FormData.prototype.getCustomHeaders = function(contentType) {
    contentType = contentType ? contentType : 'multipart/form-data';

    var formHeaders = {
        'content-type': contentType + '; boundary=' + this.getBoundary(),
        'content-length': this.getLengthSync()
    };

    return formHeaders;
}

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function(debug) {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/felixge/node-form-data/issues/40
  if (this._lengthRetrievers.length) {
    // Some async length retrivers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._lengthRetrievers.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  async.parallel(this._lengthRetrievers, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {

  var request
    , options
    , defaults = {
        method : 'post'
    };

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {
    params = parseUrl(params);

    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname
    }, defaults);
  }
  else // use custom params
  {
    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (params.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {

    // TODO: Add chunked encoding when no length (if err)

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (this.error) return;

  this.error = err;
  this.pause();
  this.emit('error', err);
};

/*
 * Santa's little helpers
 */

// populates missing values
function populate(dst, src) {
  for (var prop in src) {
    if (!dst[prop]) dst[prop] = src[prop];
  }
  return dst;
}

return {
    CombinedStream: (typeof CombinedStream !== "undefined") ? CombinedStream : null,
    require: (typeof require !== "undefined") ? require : null,
    util: (typeof util !== "undefined") ? util : null,
    path: (typeof path !== "undefined") ? path : null,
    http: (typeof http !== "undefined") ? http : null,
    https: (typeof https !== "undefined") ? https : null,
    parseUrl: (typeof parseUrl !== "undefined") ? parseUrl : null,
    fs: (typeof fs !== "undefined") ? fs : null,
    mime: (typeof mime !== "undefined") ? mime : null,
    async: (typeof async !== "undefined") ? async : null,
    module: (typeof module !== "undefined") ? module : null,
    FormData: (typeof FormData !== "undefined") ? FormData : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null,
    Math: (typeof Math !== "undefined") ? Math : null,
    process: (typeof process !== "undefined") ? process : null,
    populate: (typeof populate !== "undefined") ? populate : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/lib/form_data.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/lib/combined_stream.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"c8a9ce490875f9a5f05a0370574a0bd596c19ba5-combined-stream/lib/combined_stream.js"}
require.memoize("c8a9ce490875f9a5f05a0370574a0bd596c19ba5-combined-stream/lib/combined_stream.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/lib';
var util = require('__SYSTEM__/util');
var Stream = require('__SYSTEM__/stream').Stream;
var DelayedStream = require('delayed-stream');

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')    
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      stream.on('data', this._checkDataSize.bind(this));

      stream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this))
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

return {
    util: (typeof util !== "undefined") ? util : null,
    require: (typeof require !== "undefined") ? require : null,
    Stream: (typeof Stream !== "undefined") ? Stream : null,
    DelayedStream: (typeof DelayedStream !== "undefined") ? DelayedStream : null,
    module: (typeof module !== "undefined") ? module : null,
    CombinedStream: (typeof CombinedStream !== "undefined") ? CombinedStream : null,
    Buffer: (typeof Buffer !== "undefined") ? Buffer : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/lib/combined_stream.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/lib/delayed_stream.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"a2ea37a3a6533f9397892010c93174e37d25765b-delayed-stream/lib/delayed_stream.js"}
require.memoize("a2ea37a3a6533f9397892010c93174e37d25765b-delayed-stream/lib/delayed_stream.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/lib';
var Stream = require('__SYSTEM__/stream').Stream;
var util = require('__SYSTEM__/util');

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

DelayedStream.prototype.__defineGetter__('readable', function() {
  return this.source.readable;
});

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};

return {
    Stream: (typeof Stream !== "undefined") ? Stream : null,
    require: (typeof require !== "undefined") ? require : null,
    util: (typeof util !== "undefined") ? util : null,
    module: (typeof module !== "undefined") ? module : null,
    DelayedStream: (typeof DelayedStream !== "undefined") ? DelayedStream : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/lib/delayed_stream.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/async/lib/async.js","mtime":0,"wrapper":"amd-ish","format":"amd-ish","id":"c90badc3722442d4e2cbe8b8d9c1905879911a3e-async/lib/async.js"}
require.memoize("c90badc3722442d4e2cbe8b8d9c1905879911a3e-async/lib/async.js", 
wrapAMD(function(require, define) {
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

})
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/async/lib/async.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib/debug.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"685b4ff7635533ef39e3b122158d8cfa4980b301-request/lib/debug.js"}
require.memoize("685b4ff7635533ef39e3b122158d8cfa4980b301-request/lib/debug.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib';
module.exports =
function debug () {
  if (/\brequest\b/.test(process.env.NODE_DEBUG))
    console.error('REQUEST %s', util.format.apply(util, arguments))
}
return {
    module: (typeof module !== "undefined") ? module : null,
    process: (typeof process !== "undefined") ? process : null,
    util: (typeof util !== "undefined") ? util : null,
    console: (typeof console !== "undefined") ? console : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib/debug.js"});
// @pinf-bundle-module: {"file":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib/getSafe.js","mtime":0,"wrapper":"commonjs/leaky","format":"leaky","id":"685b4ff7635533ef39e3b122158d8cfa4980b301-request/lib/getSafe.js"}
require.memoize("685b4ff7635533ef39e3b122158d8cfa4980b301-request/lib/getSafe.js", 
function(require, exports, module) {var __dirname = TEST_ROOT_PATH + '/' + 'test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib';
// Safe toJSON
module.exports =
function getSafe (self, uuid) {
  if (typeof self === 'object' || typeof self === 'function') var safe = {}
  if (Array.isArray(self)) var safe = []

  var recurse = []

  Object.defineProperty(self, uuid, {})

  var attrs = Object.keys(self).filter(function (i) {
    if (i === uuid) return false
    if ( (typeof self[i] !== 'object' && typeof self[i] !== 'function') || self[i] === null) return true
    return !(Object.getOwnPropertyDescriptor(self[i], uuid))
  })


  for (var i=0;i<attrs.length;i++) {
    if ( (typeof self[attrs[i]] !== 'object' && typeof self[attrs[i]] !== 'function') ||
          self[attrs[i]] === null
        ) {
      safe[attrs[i]] = self[attrs[i]]
    } else {
      recurse.push(attrs[i])
      Object.defineProperty(self[attrs[i]], uuid, {})
    }
  }

  for (var i=0;i<recurse.length;i++) {
    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)
  }

  return safe
}
return {
    module: (typeof module !== "undefined") ? module : null,
    Array: (typeof Array !== "undefined") ? Array : null,
    Object: (typeof Object !== "undefined") ? Object : null
};
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/lib/getSafe.js"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/package.json"}
require.memoize("3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/package.json", 
{
    "main": "3d651410283fe41ff53775736a29d43f95b1f37f-pinf-for-nodejs/lib/pinf.js",
    "mappings": {
        "deepmerge": "98c6b74665bd9abac5c33394e3edfcf04ef251a1-deepmerge",
        "deepcopy": "36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy",
        "pinf-primitives-js": "76a2f12f0a8696a3a9d97df34f43db89b9601bda-pinf-primitives-js",
        "pinf-it-program-insight": "c6035683eb37f4f966e46471e9a2606bd8fc5934-pinf-it-program-insight",
        "pinf-it-bundler": "5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler",
        "request": "e8f0a2e912c12fb986839ec2212f3c6e4aa79037-request",
        "pinf-vfs": "ab49b00e842187d508f091e478b4238c6fe2d0a3-pinf-vfs"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"98c6b74665bd9abac5c33394e3edfcf04ef251a1-deepmerge/package.json"}
require.memoize("98c6b74665bd9abac5c33394e3edfcf04ef251a1-deepmerge/package.json", 
{
    "main": "98c6b74665bd9abac5c33394e3edfcf04ef251a1-deepmerge/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepmerge"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepmerge/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/package.json"}
require.memoize("36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/package.json", 
{
    "main": "36ebf7c610a6889fa8fe5be58716124489db5c81-deepcopy/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/deepcopy/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"76a2f12f0a8696a3a9d97df34f43db89b9601bda-pinf-primitives-js/package.json"}
require.memoize("76a2f12f0a8696a3a9d97df34f43db89b9601bda-pinf-primitives-js/package.json", 
{
    "main": "76a2f12f0a8696a3a9d97df34f43db89b9601bda-pinf-primitives-js/primitives.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-primitives-js"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-primitives-js/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"c6035683eb37f4f966e46471e9a2606bd8fc5934-pinf-it-program-insight/package.json"}
require.memoize("c6035683eb37f4f966e46471e9a2606bd8fc5934-pinf-it-program-insight/package.json", 
{
    "main": "c6035683eb37f4f966e46471e9a2606bd8fc5934-pinf-it-program-insight/lib/program-insight.js",
    "mappings": {
        "deepcopy": "c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/package.json"}
require.memoize("c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/package.json", 
{
    "main": "c066f376ac57b1a182e1f31b19fb0c461b323ecf-deepcopy/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-program-insight/node_modules/deepcopy/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/package.json"}
require.memoize("5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/package.json", 
{
    "main": "5aa4f8236a7c406bfaf61838e207a3e9254be2e6-pinf-it-bundler/lib/bundler.js",
    "mappings": {
        "deepcopy": "a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/package.json"}
require.memoize("a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/package.json", 
{
    "main": "a5e56301eb70d02275391bc5afde1cd2f62d0e69-deepcopy/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/deepcopy/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"e8f0a2e912c12fb986839ec2212f3c6e4aa79037-request/package.json"}
require.memoize("e8f0a2e912c12fb986839ec2212f3c6e4aa79037-request/package.json", 
{
    "main": "e8f0a2e912c12fb986839ec2212f3c6e4aa79037-request/index.js",
    "mappings": {
        "qs": "a13b2b95ca51018b6d405a7e337ddb2d9da913d6-qs",
        "oauth-sign": "0a2767d204df2a563b9513a5b12e7f2ef737e245-oauth-sign",
        "hawk": "ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk",
        "aws-sign": "8d0d8b76fc7fb074fae1f24236fc2c5c9db07428-aws-sign",
        "http-signature": "504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature",
        "node-uuid": "b360de4cfbd0215d27510c4fd03393d88d8c8ae8-node-uuid",
        "mime": "3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime",
        "tunnel-agent": "108b28d120f242b00befd693696b25134ac10bef-tunnel-agent",
        "json-stringify-safe": "b3eb0c4e174b4fd3de6278f94c1c93bfce68bd6c-json-stringify-safe",
        "forever-agent": "ac485b684341e74d2d223646d5b98969d287efa9-forever-agent",
        "form-data": "b31d9d8844fd9f42ca88afa16a6316e74e8a6409-form-data",
        "cookie-jar": "e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"a13b2b95ca51018b6d405a7e337ddb2d9da913d6-qs/package.json"}
require.memoize("a13b2b95ca51018b6d405a7e337ddb2d9da913d6-qs/package.json", 
{
    "main": "a13b2b95ca51018b6d405a7e337ddb2d9da913d6-qs/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/qs"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/qs/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"0a2767d204df2a563b9513a5b12e7f2ef737e245-oauth-sign/package.json"}
require.memoize("0a2767d204df2a563b9513a5b12e7f2ef737e245-oauth-sign/package.json", 
{
    "main": "0a2767d204df2a563b9513a5b12e7f2ef737e245-oauth-sign/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/oauth-sign"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/oauth-sign/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/package.json"}
require.memoize("ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/package.json", 
{
    "main": "ef2311c3452fcf0c060669446e9d1b7f2ae2fe07-hawk/index.js",
    "mappings": {
        "boom": "bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom",
        "sntp": "87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp",
        "hoek": "5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek",
        "cryptiles": "8f6b20ea73af0e78673599afe177926b017fe185-cryptiles"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/package.json"}
require.memoize("bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/package.json", 
{
    "main": "bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom/index.js",
    "mappings": {
        "hoek": "9579db8ec37f1c7107434638cd83ebcdde128669-hoek"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"9579db8ec37f1c7107434638cd83ebcdde128669-hoek/package.json"}
require.memoize("9579db8ec37f1c7107434638cd83ebcdde128669-hoek/package.json", 
{
    "main": "9579db8ec37f1c7107434638cd83ebcdde128669-hoek/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/boom/node_modules/hoek/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/package.json"}
require.memoize("87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/package.json", 
{
    "main": "87fef81bfb6e9c0756eb1aef7efafad814f6d037-sntp/index.js",
    "mappings": {
        "hoek": "733132ef85628339b6e1a78283093c2a9208ca8a-hoek"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"733132ef85628339b6e1a78283093c2a9208ca8a-hoek/package.json"}
require.memoize("733132ef85628339b6e1a78283093c2a9208ca8a-hoek/package.json", 
{
    "main": "733132ef85628339b6e1a78283093c2a9208ca8a-hoek/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/sntp/node_modules/hoek/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/package.json"}
require.memoize("5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/package.json", 
{
    "main": "5712c844784b75d73fa477ce4544c1fee1a73e9a-hoek/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/hoek/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/package.json"}
require.memoize("8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/package.json", 
{
    "main": "8f6b20ea73af0e78673599afe177926b017fe185-cryptiles/index.js",
    "mappings": {
        "boom": "bf5f6d759723b81e09f0e0987c6471c189b1d06c-boom"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/hawk/node_modules/cryptiles/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"8d0d8b76fc7fb074fae1f24236fc2c5c9db07428-aws-sign/package.json"}
require.memoize("8d0d8b76fc7fb074fae1f24236fc2c5c9db07428-aws-sign/package.json", 
{
    "main": "8d0d8b76fc7fb074fae1f24236fc2c5c9db07428-aws-sign/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/aws-sign"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/aws-sign/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/package.json"}
require.memoize("504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/package.json", 
{
    "main": "504dacc61af7bbe1211e508279a261f00f9f80a6-http-signature/lib/index.js",
    "mappings": {
        "assert-plus": "4577e8ae6126946aeedc02c249aefacb641b25de-assert-plus",
        "asn1": "58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1",
        "ctype": "59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"4577e8ae6126946aeedc02c249aefacb641b25de-assert-plus/package.json"}
require.memoize("4577e8ae6126946aeedc02c249aefacb641b25de-assert-plus/package.json", 
{
    "main": "4577e8ae6126946aeedc02c249aefacb641b25de-assert-plus/assert.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/assert-plus"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/assert-plus/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/package.json"}
require.memoize("58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/package.json", 
{
    "main": "58bf8a5049a1321dd747766ae49de85b0d7c437b-asn1/lib/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/asn1/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/package.json"}
require.memoize("59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/package.json", 
{
    "main": "59f3c6d403691c2aed6f9d3b8b397d193e93dee6-ctype/ctype.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/http-signature/node_modules/ctype/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"b360de4cfbd0215d27510c4fd03393d88d8c8ae8-node-uuid/package.json"}
require.memoize("b360de4cfbd0215d27510c4fd03393d88d8c8ae8-node-uuid/package.json", 
{
    "main": "b360de4cfbd0215d27510c4fd03393d88d8c8ae8-node-uuid/uuid.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/node-uuid"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/node-uuid/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime/package.json"}
require.memoize("3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime/package.json", 
{
    "main": "3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime/mime.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/mime"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/mime/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"108b28d120f242b00befd693696b25134ac10bef-tunnel-agent/package.json"}
require.memoize("108b28d120f242b00befd693696b25134ac10bef-tunnel-agent/package.json", 
{
    "main": "108b28d120f242b00befd693696b25134ac10bef-tunnel-agent/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/tunnel-agent"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/tunnel-agent/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"b3eb0c4e174b4fd3de6278f94c1c93bfce68bd6c-json-stringify-safe/package.json"}
require.memoize("b3eb0c4e174b4fd3de6278f94c1c93bfce68bd6c-json-stringify-safe/package.json", 
{
    "main": "b3eb0c4e174b4fd3de6278f94c1c93bfce68bd6c-json-stringify-safe/stringify.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/json-stringify-safe"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/json-stringify-safe/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"ac485b684341e74d2d223646d5b98969d287efa9-forever-agent/package.json"}
require.memoize("ac485b684341e74d2d223646d5b98969d287efa9-forever-agent/package.json", 
{
    "main": "ac485b684341e74d2d223646d5b98969d287efa9-forever-agent/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/forever-agent"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/forever-agent/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"b31d9d8844fd9f42ca88afa16a6316e74e8a6409-form-data/package.json"}
require.memoize("b31d9d8844fd9f42ca88afa16a6316e74e8a6409-form-data/package.json", 
{
    "main": "b31d9d8844fd9f42ca88afa16a6316e74e8a6409-form-data/lib/form_data.js",
    "mappings": {
        "combined-stream": "060655d1be854e806dc31729ef59e2992f3626c0-combined-stream",
        "mime": "3224ac8e300a1626a99ef5dd8b50d9fed0d71852-mime",
        "async": "2e7a010e5b40e11bb94eb021d6eca99d00679e86-async"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"060655d1be854e806dc31729ef59e2992f3626c0-combined-stream/package.json"}
require.memoize("060655d1be854e806dc31729ef59e2992f3626c0-combined-stream/package.json", 
{
    "main": "060655d1be854e806dc31729ef59e2992f3626c0-combined-stream/lib/combined_stream.js",
    "mappings": {
        "delayed-stream": "1bec134004038e4c00058fd84d773149d7b2e1c9-delayed-stream"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"1bec134004038e4c00058fd84d773149d7b2e1c9-delayed-stream/package.json"}
require.memoize("1bec134004038e4c00058fd84d773149d7b2e1c9-delayed-stream/package.json", 
{
    "main": "1bec134004038e4c00058fd84d773149d7b2e1c9-delayed-stream/lib/delayed_stream.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"2e7a010e5b40e11bb94eb021d6eca99d00679e86-async/package.json"}
require.memoize("2e7a010e5b40e11bb94eb021d6eca99d00679e86-async/package.json", 
{
    "main": "2e7a010e5b40e11bb94eb021d6eca99d00679e86-async/lib/async.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/async"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/form-data/node_modules/async/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/package.json"}
require.memoize("e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/package.json", 
{
    "main": "e33e833ecc82726cf7ce002eee574891314ea230-cookie-jar/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/request/node_modules/cookie-jar/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"ab49b00e842187d508f091e478b4238c6fe2d0a3-pinf-vfs/package.json"}
require.memoize("ab49b00e842187d508f091e478b4238c6fe2d0a3-pinf-vfs/package.json", 
{
    "main": "ab49b00e842187d508f091e478b4238c6fe2d0a3-pinf-vfs/lib/vfs.js",
    "mappings": {
        "pinf-proxy": "48ac305cf012aab581c31105053b4890047c5b6d-pinf-proxy"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"48ac305cf012aab581c31105053b4890047c5b6d-pinf-proxy/package.json"}
require.memoize("48ac305cf012aab581c31105053b4890047c5b6d-pinf-proxy/package.json", 
{
    "main": "48ac305cf012aab581c31105053b4890047c5b6d-pinf-proxy/lib/proxy.js",
    "mappings": {
        "http-proxy": "b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy",
        "empty-port": "ced8d3a56b61a7bac1f8aa0f1d76859b38a5c95b-empty-port",
        "request": "685b4ff7635533ef39e3b122158d8cfa4980b301-request"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/package.json"}
require.memoize("b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/package.json", 
{
    "main": "b6173b2c3e91af39055a6a41b7506a3421da49e0-http-proxy/lib/node-http-proxy.js",
    "mappings": {
        "pkginfo": "b8a541404830c1d27cc31b32993830e7093c74ee-pkginfo",
        "utile": "d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"b8a541404830c1d27cc31b32993830e7093c74ee-pkginfo/package.json"}
require.memoize("b8a541404830c1d27cc31b32993830e7093c74ee-pkginfo/package.json", 
{
    "main": "b8a541404830c1d27cc31b32993830e7093c74ee-pkginfo/lib/pkginfo.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/pkginfo"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/pkginfo/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/package.json"}
require.memoize("d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/package.json", 
{
    "main": "d9d5999ac73aa88cff64de97f1d035e6e8ee8c1c-utile/lib/index.js",
    "mappings": {
        "async": "0c08d0ba45e15dd8f8ceecf76c44bee1a9a1b30d-async",
        "i": "6c4d72f866c8ff5607a472534b0f399c3d86c49f-i",
        "mkdirp": "9dee272ed9e5c28263eb5731e369dc4604b912a0-mkdirp",
        "deep-equal": "e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal",
        "rimraf": "10366b02d071a3b553102db687f0f7cf7de08547-rimraf",
        "ncp": "a434266567e763036a95b1043481a5a65bf21aed-ncp"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"0c08d0ba45e15dd8f8ceecf76c44bee1a9a1b30d-async/package.json"}
require.memoize("0c08d0ba45e15dd8f8ceecf76c44bee1a9a1b30d-async/package.json", 
{
    "main": "0c08d0ba45e15dd8f8ceecf76c44bee1a9a1b30d-async/lib/async.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/async"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/async/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/package.json"}
require.memoize("6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/package.json", 
{
    "main": "6c4d72f866c8ff5607a472534b0f399c3d86c49f-i/lib/inflect.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/i/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"9dee272ed9e5c28263eb5731e369dc4604b912a0-mkdirp/package.json"}
require.memoize("9dee272ed9e5c28263eb5731e369dc4604b912a0-mkdirp/package.json", 
{
    "main": "9dee272ed9e5c28263eb5731e369dc4604b912a0-mkdirp/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/mkdirp"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/mkdirp/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/package.json"}
require.memoize("e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/package.json", 
{
    "main": "e5d63fec7a293cea2d3fe394908e396e2a312959-deep-equal/index.js",
    "directories": {
        "lib": "."
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/deep-equal/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"10366b02d071a3b553102db687f0f7cf7de08547-rimraf/package.json"}
require.memoize("10366b02d071a3b553102db687f0f7cf7de08547-rimraf/package.json", 
{
    "main": "10366b02d071a3b553102db687f0f7cf7de08547-rimraf/rimraf.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/rimraf"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/rimraf/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"a434266567e763036a95b1043481a5a65bf21aed-ncp/package.json"}
require.memoize("a434266567e763036a95b1043481a5a65bf21aed-ncp/package.json", 
{
    "main": "a434266567e763036a95b1043481a5a65bf21aed-ncp/lib/ncp.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/ncp"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/http-proxy/node_modules/utile/node_modules/ncp/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"ced8d3a56b61a7bac1f8aa0f1d76859b38a5c95b-empty-port/package.json"}
require.memoize("ced8d3a56b61a7bac1f8aa0f1d76859b38a5c95b-empty-port/package.json", 
{
    "main": "ced8d3a56b61a7bac1f8aa0f1d76859b38a5c95b-empty-port/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/empty-port"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/empty-port/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"685b4ff7635533ef39e3b122158d8cfa4980b301-request/package.json"}
require.memoize("685b4ff7635533ef39e3b122158d8cfa4980b301-request/package.json", 
{
    "main": "685b4ff7635533ef39e3b122158d8cfa4980b301-request/index.js",
    "mappings": {
        "cookie-jar": "73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar",
        "qs": "c70b9b617a7da4031b6086f59e85be2a33adb799-qs",
        "oauth-sign": "a539f9d7ca6a8781e1ff659d774d5f222017a60d-oauth-sign",
        "hawk": "21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk",
        "aws-sign": "fd19611375576f45cadda2116c3987363f8c18f2-aws-sign",
        "http-signature": "7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature",
        "node-uuid": "c0e0c010944c64f22cbef7cbf6c98c6f92ff0bee-node-uuid",
        "mime": "605d0653b789e3de9801f6c70dc6806f10f3df59-mime",
        "tunnel-agent": "d84bcf6c67f6981373f5d572f45044309b8869e9-tunnel-agent",
        "json-stringify-safe": "676738dbbe6012d457627e1573854d4b0f783d3f-json-stringify-safe",
        "forever-agent": "7c9aa9a5db66cc2b7202a9768e97e9faa14bf42c-forever-agent",
        "form-data": "f701ab5006089176e28016f244aac960ca36eb37-form-data"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/package.json"}
require.memoize("73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/package.json", 
{
    "main": "73bea46536a96037ec9d8ea77af2437c759af32f-cookie-jar/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/cookie-jar/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"c70b9b617a7da4031b6086f59e85be2a33adb799-qs/package.json"}
require.memoize("c70b9b617a7da4031b6086f59e85be2a33adb799-qs/package.json", 
{
    "main": "c70b9b617a7da4031b6086f59e85be2a33adb799-qs/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/qs"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/qs/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"a539f9d7ca6a8781e1ff659d774d5f222017a60d-oauth-sign/package.json"}
require.memoize("a539f9d7ca6a8781e1ff659d774d5f222017a60d-oauth-sign/package.json", 
{
    "main": "a539f9d7ca6a8781e1ff659d774d5f222017a60d-oauth-sign/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/oauth-sign"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/oauth-sign/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/package.json"}
require.memoize("21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/package.json", 
{
    "main": "21b992eb47787ae5f2a2504b6e19ebe669798d74-hawk/index.js",
    "mappings": {
        "boom": "534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom",
        "sntp": "0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp",
        "hoek": "8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek",
        "cryptiles": "2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/package.json"}
require.memoize("534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/package.json", 
{
    "main": "534b5360ded0c3c17e9ae90e3ee7827aaa6afd7c-boom/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/boom/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/package.json"}
require.memoize("0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/package.json", 
{
    "main": "0db6895d23a6b3ed7e47e5424765fddf9872645a-sntp/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/sntp/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/package.json"}
require.memoize("8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/package.json", 
{
    "main": "8b5ffa12b07b655d7ddd822fe6f304cbcba27506-hoek/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/hoek/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/package.json"}
require.memoize("2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/package.json", 
{
    "main": "2436c1f20cb989f24dc08457a81b5583c29bca0e-cryptiles/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/hawk/node_modules/cryptiles/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"fd19611375576f45cadda2116c3987363f8c18f2-aws-sign/package.json"}
require.memoize("fd19611375576f45cadda2116c3987363f8c18f2-aws-sign/package.json", 
{
    "main": "fd19611375576f45cadda2116c3987363f8c18f2-aws-sign/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/aws-sign"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/aws-sign/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/package.json"}
require.memoize("7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/package.json", 
{
    "main": "7833b9d03c0ee9e88086520874a535ab933e4e12-http-signature/lib/index.js",
    "mappings": {
        "assert-plus": "8f17ce5faccfa48645e3b9e946567a604b0f9f82-assert-plus",
        "asn1": "51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1",
        "ctype": "13ae81dc847476dd3831d19e014331db131f77a8-ctype"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"8f17ce5faccfa48645e3b9e946567a604b0f9f82-assert-plus/package.json"}
require.memoize("8f17ce5faccfa48645e3b9e946567a604b0f9f82-assert-plus/package.json", 
{
    "main": "8f17ce5faccfa48645e3b9e946567a604b0f9f82-assert-plus/assert.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/assert-plus"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/assert-plus/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/package.json"}
require.memoize("51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/package.json", 
{
    "main": "51bc2634e96db9b6e2392b3cd8683d6b46ae5ca8-asn1/lib/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/asn1/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"13ae81dc847476dd3831d19e014331db131f77a8-ctype/package.json"}
require.memoize("13ae81dc847476dd3831d19e014331db131f77a8-ctype/package.json", 
{
    "main": "13ae81dc847476dd3831d19e014331db131f77a8-ctype/ctype.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/http-signature/node_modules/ctype/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"c0e0c010944c64f22cbef7cbf6c98c6f92ff0bee-node-uuid/package.json"}
require.memoize("c0e0c010944c64f22cbef7cbf6c98c6f92ff0bee-node-uuid/package.json", 
{
    "main": "c0e0c010944c64f22cbef7cbf6c98c6f92ff0bee-node-uuid/uuid.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/node-uuid"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/node-uuid/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"605d0653b789e3de9801f6c70dc6806f10f3df59-mime/package.json"}
require.memoize("605d0653b789e3de9801f6c70dc6806f10f3df59-mime/package.json", 
{
    "main": "605d0653b789e3de9801f6c70dc6806f10f3df59-mime/mime.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/mime"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/mime/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"d84bcf6c67f6981373f5d572f45044309b8869e9-tunnel-agent/package.json"}
require.memoize("d84bcf6c67f6981373f5d572f45044309b8869e9-tunnel-agent/package.json", 
{
    "main": "d84bcf6c67f6981373f5d572f45044309b8869e9-tunnel-agent/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/tunnel-agent"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/tunnel-agent/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"676738dbbe6012d457627e1573854d4b0f783d3f-json-stringify-safe/package.json"}
require.memoize("676738dbbe6012d457627e1573854d4b0f783d3f-json-stringify-safe/package.json", 
{
    "main": "676738dbbe6012d457627e1573854d4b0f783d3f-json-stringify-safe/stringify.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/json-stringify-safe"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/json-stringify-safe/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"7c9aa9a5db66cc2b7202a9768e97e9faa14bf42c-forever-agent/package.json"}
require.memoize("7c9aa9a5db66cc2b7202a9768e97e9faa14bf42c-forever-agent/package.json", 
{
    "main": "7c9aa9a5db66cc2b7202a9768e97e9faa14bf42c-forever-agent/index.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/forever-agent"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/forever-agent/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"f701ab5006089176e28016f244aac960ca36eb37-form-data/package.json"}
require.memoize("f701ab5006089176e28016f244aac960ca36eb37-form-data/package.json", 
{
    "main": "f701ab5006089176e28016f244aac960ca36eb37-form-data/lib/form_data.js",
    "mappings": {
        "combined-stream": "c8a9ce490875f9a5f05a0370574a0bd596c19ba5-combined-stream",
        "async": "c90badc3722442d4e2cbe8b8d9c1905879911a3e-async"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"c8a9ce490875f9a5f05a0370574a0bd596c19ba5-combined-stream/package.json"}
require.memoize("c8a9ce490875f9a5f05a0370574a0bd596c19ba5-combined-stream/package.json", 
{
    "main": "c8a9ce490875f9a5f05a0370574a0bd596c19ba5-combined-stream/lib/combined_stream.js",
    "mappings": {
        "delayed-stream": "a2ea37a3a6533f9397892010c93174e37d25765b-delayed-stream"
    },
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"a2ea37a3a6533f9397892010c93174e37d25765b-delayed-stream/package.json"}
require.memoize("a2ea37a3a6533f9397892010c93174e37d25765b-delayed-stream/package.json", 
{
    "main": "a2ea37a3a6533f9397892010c93174e37d25765b-delayed-stream/lib/delayed_stream.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/combined-stream/node_modules/delayed-stream/package.json"});
// @pinf-bundle-module: {"file":null,"mtime":0,"wrapper":"json","format":"json","id":"c90badc3722442d4e2cbe8b8d9c1905879911a3e-async/package.json"}
require.memoize("c90badc3722442d4e2cbe8b8d9c1905879911a3e-async/package.json", 
{
    "main": "c90badc3722442d4e2cbe8b8d9c1905879911a3e-async/lib/async.js",
    "dirpath": "test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/async"
}
, {"filename":"test/assets/packages/require-async-deep-pkg/node_modules/pinf-for-nodejs/node_modules/pinf-vfs/node_modules/pinf-proxy/node_modules/request/node_modules/form-data/node_modules/async/package.json"});
// @pinf-bundle-ignore: 
});
// @pinf-bundle-report: {}